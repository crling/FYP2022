{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"{\\n        value: \", \",\\n        unit: 1,\\n        offset: \", \",\\n    }\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport { oneLineTrim } from \"common-tags\";\nimport { GEOMETRY_LITERAL } from \"../../defs/geometry\";\nimport { UIDGenerator } from \"../../utils/uid\";\nimport { isRootElement, newNode } from \"./ast-node\";\nvar indent = \"    \";\n\nfunction t(str) {\n  return indent + str.replace(/\\n/g, \"\\n\".concat(indent));\n}\n\nfunction serialize(obj) {\n  if (_typeof(obj) === \"object\") return \"{\".concat(Object.keys(obj).map(function (k) {\n    return \"'\".concat(k, \"': \").concat(serialize(obj[k]));\n  }).join(\",\"), \"}\");\n  return obj.toString();\n}\n\nfunction wrappedWithLocalData(node, wrapped) {\n  return \"(function() { \".concat(genLocalData(node), \" return (\\n\").concat(wrapped, \")})()\");\n}\n\nfunction genLocalData(node) {\n  return node.localData.map(function (d) {\n    return d.name === \"@expr\" ? \"\".concat(d.expr, \";\") : \"let \".concat(d.name, \" = \").concat(d.expr, \";\");\n  }).join(\"\");\n}\n\nfunction genGeoExpr(match) {\n  // (100), 100, +, (1), 1\n  var value = match[2] || match[1];\n  var offset = (match[3] === \"-\" ? \"-\" : \"\") + (match[5] || match[4] || \"0\");\n  return oneLineTrim(_templateObject(), value, offset);\n}\n\nfunction genExpr(expr, name) {\n  // wip\n  return expr;\n}\n\nfunction genAttrs(node) {\n  var attrStrings = [];\n  var normalProps = [];\n  var delegates = {};\n  var hasDelegate = false;\n\n  var _iterator = _createForOfIteratorHelper(node.props),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _p = _step.value;\n\n      if (_p.delegate) {\n        var m = _p.delegate.match(/(.+?)\\(:(.+?)\\)/);\n\n        if (m) {\n          if (!delegates[m[1]]) delegates[m[1]] = {};\n          var d = delegates[m[1]];\n          if (!d._stages) d._stages = _defineProperty({}, m[2], {});\n          d._stages[m[2]][_p.name] = _p.expr;\n        } else {\n          if (!delegates[_p.delegate]) delegates[_p.delegate] = {};\n          var _d = delegates[_p.delegate];\n\n          if (_p.name.startsWith(\"on:\")) {\n            var eventName = _p.name.substr(3);\n\n            if (!_d._on) _d._on = {};\n            _d._on[eventName] = genEventListener(_p.expr);\n          } else if (_p.name.startsWith(\"behavior:\")) {\n            var bName = _p.name.substr(9);\n\n            if (!_d._behavior) _d._behavior = {};\n            _d._behavior[bName] = _p.expr;\n          } else {\n            _d[_p.name] = _p.expr;\n          }\n        }\n\n        hasDelegate = true;\n      } else {\n        normalProps.push(_p);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  for (var _i = 0, _normalProps = normalProps; _i < _normalProps.length; _i++) {\n    var p = _normalProps[_i];\n    var name = p.name;\n\n    if (name === \"__dynamic__\") {\n      attrStrings.push(\"...\".concat(p.expr));\n      continue;\n    }\n\n    var match = void 0;\n    var expr = (match = p.expr.match(GEOMETRY_LITERAL)) ? genGeoExpr(match) : p.expr;\n    attrStrings.push(\"'\".concat(name, \"': \").concat(genExpr(expr, name)));\n  }\n\n  if (hasDelegate) {\n    attrStrings.push(\"opt: \".concat(serialize(delegates)));\n  }\n\n  if (node.initArg && node.name !== \"Component\") {\n    attrStrings.push(\"_initArg: \".concat(node.initArg));\n  }\n\n  return \"props: {\".concat(attrStrings.join(\",\"), \"},\");\n}\n\nvar EVT_FUNC_CALL = new RegExp(\"^([A-z0-9_]+)\\\\((.+?)\\\\)$\");\n\nfunction genEventListener(handler) {\n  var match;\n\n  if (handler.startsWith(\"function\") || handler.match(/^\\(.+?\\) *=>/) || handler[0] === \"[\" || handler[0] === \"@\") {\n    return handler;\n  } else if (handler.match(/^[A-z0-9_]+$/)) {\n    return \"_b(\".concat(handler, \")\");\n  } else if (match = handler.match(EVT_FUNC_CALL)) {\n    return \"_b(\".concat(match[1], \", \").concat(match[2], \")\");\n  } else {\n    return \"(function($ev, $el) { \".concat(handler, \" }).bind(this)\");\n  }\n}\n\nfunction genEventHdl(node) {\n  if (node.on.length === 0) return \"\";\n  var events = node.on.map(function (o) {\n    return \"\".concat(o.name, \": \").concat(genEventListener(o.handler));\n  }).join(\",\");\n  return \"on: { \".concat(events, \" },\");\n}\n\nfunction genStyle(node) {\n  if (node.styles.length === 0) return \"\";\n  var styles = node.styles.map(function (s) {\n    return \"'\".concat(s.name, \"': \").concat(s.expr);\n  }).join(\",\");\n  return \"styles: { \".concat(styles, \" },\");\n}\n\nfunction genBehavior(node) {\n  if (node.behavior.length === 0) return \"\";\n  var behaviors = node.behavior.map(function (s) {\n    return \"'\".concat(s.name, \"': {\").concat(s.args.map(function (a) {\n      return \"\".concat(a.name, \": \").concat(a.expr);\n    }).join(\", \"), \"}\");\n  }).join(\",\");\n  return \"behaviors: { \".concat(behaviors, \" },\");\n}\n\nfunction genStage(node) {\n  if (node.stage.length === 0) return \"\";\n  var stages = node.stage.map(function (s) {\n    return \"'\".concat(s.name, \"': {\").concat(s.args.map(function (a) {\n      return \"\".concat(a.name, \": \").concat(a.expr);\n    }).join(\", \"), \"}\");\n  }).join(\",\");\n  return \"stages: { \".concat(stages, \" },\");\n}\n\nfunction genNamedChildren(node, u) {\n  var keys = Object.keys(node.namedChildren);\n  if (keys.length === 0) return \"\";\n  var str = keys.map(function (k) {\n    var nc = node.namedChildren[k];\n    var children = genChildren(nc, u);\n    var func = Array.isArray(nc.dataName) ? \"function ($data) { \".concat(nc.dataName.map(function (n) {\n      return \"const \".concat(n, \" = $data['\").concat(n, \"'];\");\n    }).join(\"\"), \" return [\\n\").concat(children, \"];}\") : \"function (\".concat(nc.dataName || \"\", \") { return [\").concat(children, \"] }\");\n    return \"\".concat(k, \": \").concat(func, \",\");\n  }).join(\"\");\n  return t(\"\\nnamedChildren: {\\n\".concat(t(str), \"},\"));\n}\n\nfunction gatherCondBlocks(node) {\n  // if (node.type === \"children\") return;\n  if (node.type === \"cond\" || !node.children.some(function (c) {\n    return c.type === \"op-if\";\n  })) {\n    return;\n  }\n\n  var newChildren = [];\n  var inCondBlock = false;\n\n  var newCondNode = function newCondNode() {\n    return newNode(\"cond\");\n  };\n\n  var currCondition = newCondNode();\n\n  var _iterator2 = _createForOfIteratorHelper(node.children),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var child = _step2.value;\n\n      switch (child.type) {\n        case \"op-if\":\n          if (inCondBlock) {\n            newChildren.push(currCondition);\n            currCondition = newCondNode();\n          }\n\n          inCondBlock = true;\n          currCondition.children.push(child);\n          break;\n\n        case \"op-else\":\n        case \"op-elsif\":\n          currCondition.children.push(child);\n          break;\n\n        default:\n          if (inCondBlock) {\n            newChildren.push(currCondition);\n            currCondition = newCondNode();\n            inCondBlock = false;\n          }\n\n          newChildren.push(child);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  if (inCondBlock) newChildren.push(currCondition);\n  node.children = newChildren;\n}\n\nfunction genChildren(node, u) {\n  gatherCondBlocks(node);\n  return node.children.map(function (n) {\n    return node2code(n, u);\n  }).join(\",\\n\");\n} // nodes\n\n\nfunction genNodeComp(node, u) {\n  var hasLocalData = node.localData.length > 0;\n  var n = node;\n  var tag = n.name === \"Component\" && n.initArg ? n.initArg : \"\\\"\".concat(n.name, \"\\\"\");\n  var noKey = n.key === undefined;\n  var key = noKey ? \"'\".concat(u.gen(), \"$'\") : n.key;\n  var useAutoKey = noKey && u.inList();\n  u.enterComponent();\n  var str;\n\n  if (isRootElement(node)) {\n    str = genChildren(node, u);\n  } else {\n    var i = \"{\" + [genAttrs(n), genEventHdl(n), genStyle(n), genBehavior(n), genStage(n), genNamedChildren(n, u)].filter(function (s) {\n      return s;\n    }).join(\" \") // remove the last comma\n    .slice(0, -1) + \"},[\\n\" + genChildren(node, u) + \"]\";\n\n    if (n.isLazy || n.staticVal) {\n      var ld = genLocalData(node);\n      str = \"_z(\".concat(tag, \", \").concat(key, \", \").concat(useAutoKey, \", \").concat(n.staticVal, \", function() { \").concat(ld, \" return [\").concat(i, \"]})\");\n    } else {\n      str = \"_c(\".concat(tag, \", \").concat(key, \", \").concat(useAutoKey, \", \").concat(i, \")\");\n    }\n  }\n\n  u.exitComponent();\n  return t(hasLocalData && !node.isLazy ? wrappedWithLocalData(node, str) : str);\n}\n\nfunction genNodeFor(node, u) {\n  var hasLocalData = node.localData.length > 0;\n  var forName = node.forName,\n      forIndex = node.forIndex,\n      expr = node.expr;\n  var args = forIndex ? \"\".concat(forName, \", \").concat(forIndex) : forName;\n  var notInLoop = !u.inList();\n  u.enterLoop();\n  var result = \"_l(\".concat(expr, \", function(\").concat(args, \") {\") + (hasLocalData ? genLocalData(node) : \"\") + \" return [\\n\".concat(genChildren(node, u), \"];\\n    }, \").concat(notInLoop, \")\");\n  u.exitLoop();\n  return t(result);\n}\n\nfunction genNodeCond(node, u) {\n  var nodes = node.children;\n  var result = nodes.map(function (n, i) {\n    var isLast = i === nodes.length - 1;\n    var hasLocalData = n.localData.length > 0;\n    var str = \"[\\n\".concat(genChildren(n, u), \"\\n]\");\n    var childrenStr = hasLocalData ? wrappedWithLocalData(n, str) : str;\n\n    if (\"condition\" in n) {\n      return \"\".concat(n.condition, \" ? \").concat(childrenStr, \" : \").concat(isLast ? \"null\" : \"\");\n    } else {\n      return childrenStr;\n    }\n  }).join(\"\");\n  return t(result);\n}\n\nfunction genNodeYield(node, u) {\n  var data = node.data || \"undefined\";\n  var children = genChildren(node, u);\n  var str = \"_y(prop, \\\"\".concat(node.name, \"\\\", \").concat(data, \", [\\n\").concat(children, \"])\");\n  return t(node.processor ? \"\".concat(node.processor, \"(\").concat(str, \")\") : str);\n}\n\nfunction node2code(node, u) {\n  gatherCondBlocks(node);\n\n  switch (node.type) {\n    case \"comp\":\n      return genNodeComp(node, u);\n\n    case \"op-for\":\n      return genNodeFor(node, u);\n\n    case \"cond\":\n      return genNodeCond(node, u);\n\n    case \"yield\":\n      return genNodeYield(node, u);\n\n    default:\n      throw Error(\"Internal error: Unknown node type when generating code: \".concat(node.type));\n  }\n}\n\nexport function gencode(ast) {\n  return \"with (this) { return (\\n\".concat(node2code(ast, new UIDGenerator()), \")}\");\n}","map":null,"metadata":{},"sourceType":"module"}