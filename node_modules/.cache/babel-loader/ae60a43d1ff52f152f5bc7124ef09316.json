{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport * as d3 from \"d3-hierarchy\";\nimport { currentEventContext } from \"../../event\";\nimport { useTemplate } from \"../../ext/decorator\";\nimport { Component } from \"../component\";\n\nvar HyperbolicTree =\n/** @class */\nfunction () {\n  var HyperbolicTree = /*#__PURE__*/function (_Component) {\n    _inherits(HyperbolicTree, _Component);\n\n    var _super = _createSuper(HyperbolicTree);\n\n    function HyperbolicTree() {\n      var _this;\n\n      _classCallCheck(this, HyperbolicTree);\n\n      _this = _super.apply(this, arguments);\n      _this.radius = 0;\n      _this.dragging = false;\n      _this.startPos = {\n        x: 0,\n        y: 0\n      };\n      _this.moved = false;\n\n      _this.moveListener = function (e) {\n        if (!_this.dragging) return;\n        _this.moved = true;\n        e.stopPropagation();\n        e.preventDefault();\n        var dx = e.screenX - _this.startPos.x;\n        var dy = e.screenY - _this.startPos.y;\n\n        var nx = _this.fromScreen(_this.draggedNode.x + e.movementX);\n\n        var ny = _this.fromScreen(_this.draggedNode.y + e.movementY);\n\n        if (nx * nx + ny * ny > 0.9) {\n          return;\n        }\n\n        _this.drawFrame(_this.fromScreen(dx), _this.fromScreen(dy));\n      };\n\n      _this.upListener = function () {\n        _this.dragging = false;\n\n        if (!_this.moved) {\n          _this.clicked(_this.draggedNode);\n        }\n\n        _this.moved = false;\n        document.body.removeEventListener(\"mousemove\", _this.moveListener);\n        document.body.removeEventListener(\"mouseup\", _this.upListener);\n\n        _this._root.endTranslation();\n      };\n\n      return _this;\n    }\n\n    _createClass(HyperbolicTree, [{\n      key: \"init\",\n      value: function init() {\n        this.state = {\n          activePath: new Set()\n        };\n        this._extMethods = {};\n      }\n    }, {\n      key: \"willRender\",\n      value: function willRender() {\n        if (this._firstRender) {\n          var data = this.prop.data;\n          var totalR = this.prop.r || Math.min(this.$geometry.width, this.$geometry.height) / 2;\n\n          if (totalR <= 0) {\n            console.warn(\"Tree: radius is 0. The tree should have a proper size.\");\n          }\n\n          this.radius = totalR;\n          var hierarchy = d3.hierarchy(data).sum(function (d) {\n            return d.children ? 0 : 1;\n          });\n          this._root = Node.fromHierarchy(this, hierarchy);\n\n          this._root.layout(0, 2 * Math.PI);\n\n          console.log(this._root);\n          this._links = _toConsumableArray(this._root.links());\n          this._nodes = _toConsumableArray(this._root.nodes());\n        }\n      }\n    }, {\n      key: \"clicked\",\n      value: function clicked(n) {\n        var _this2 = this;\n\n        var time = 300;\n        var steps = 8;\n        var currX = this.fromScreen(n.x);\n        var currY = this.fromScreen(n.y);\n        var endX = this.fromScreen(0);\n        var endY = this.fromScreen(0);\n        var dx = (endX - currX) / steps;\n        var dy = (endY - currY) / steps;\n\n        var animate = function animate(n) {\n          if (n !== 0) {\n            _this2.drawFrame(dx * n, dy * n);\n          }\n\n          if (n < steps) {\n            setTimeout(function () {\n              return animate(n + 1);\n            }, time / steps);\n          } else {\n            _this2._root.endTranslation();\n          }\n        };\n\n        animate(0);\n      }\n    }, {\n      key: \"dragStart\",\n      value: function dragStart(n) {\n        this.dragging = true;\n        this.draggedNode = n;\n        var e = currentEventContext.event;\n        this.startPos.x = e.screenX;\n        this.startPos.y = e.screenY;\n        document.body.addEventListener(\"mousemove\", this.moveListener);\n        document.body.addEventListener(\"mouseup\", this.upListener);\n      }\n    }, {\n      key: \"drawFrame\",\n      value: function drawFrame(dx, dy) {\n        if (dx === 0 && dy === 0) return;\n\n        this._root.updateTranslation(Point.create(dx, dy));\n\n        this.redraw();\n      }\n    }, {\n      key: \"fromScreen\",\n      value: function fromScreen(n) {\n        return n / this.radius;\n      }\n    }, {\n      key: \"toScreen\",\n      value: function toScreen(n) {\n        return n * this.radius;\n      }\n    }, {\n      key: \"getPath\",\n      value: function getPath(_ref) {\n        var source = _ref.source,\n            target = _ref.target;\n        var s = {\n          x: source.pos.x,\n          y: source.pos.y\n        };\n        var t = {\n          x: target.pos.x,\n          y: target.pos.y\n        };\n        var d = s.x * t.y - t.x * s.y;\n\n        if (d === 0) {\n          return \"M\".concat(source.x, \",\").concat(source.y, \" L\").concat(target.x, \",\").concat(target.y);\n        } // const s2 = s.x * s.x + s.y + s.y + 1;\n        // const t2 = t.x * t.x + t.y + t.y + 1;\n        // const cX = (s2 * t.y - t2 * s.y) / (d * 2);\n        // const cY = (t2 * s.x - s2 * t.x) / (d * 2);\n        // const r = Math.sqrt((s.x - cX) * (s.x - cX) + (s.y - cY) * (s.y - cY));\n        // const sr = this.toScreen(r);\n\n\n        var sr = this.toScreen(1.5);\n        return \"M\".concat(source.x, \",\").concat(source.y, \" A\").concat(sr, \",\").concat(sr, \",0,0,1,\").concat(target.x, \",\").concat(target.y);\n      }\n    }, {\n      key: \"defaultProp\",\n      value: function defaultProp() {\n        return Object.assign(Object.assign({}, _get(_getPrototypeOf(HyperbolicTree.prototype), \"defaultProp\", this).call(this)), {\n          deg: 360,\n          scale: \"none\",\n          direction: \"bottom\",\n          treeRotation: 0,\n          leafSize: 20,\n          branchInteraction: true\n        });\n      }\n    }, {\n      key: \"isActiveLink\",\n      value: function isActiveLink(link) {\n        if (!this.prop.branchInteraction) return;\n        return this.state.activePath.has(link.source.data) && this.state.activePath.has(link.target.data);\n      }\n    }]);\n\n    return HyperbolicTree;\n  }(Component);\n\n  HyperbolicTree = __decorate([useTemplate(\"//bvt\\nComponent {\\n    @let tree = _extMethods\\n    Component {\\n        x = 50%; y = 50%\\n        Circle.centered {\\n            r = radius\\n            fill = \\\"#f4f4f4\\\"\\n        }\\n        @for (link, i) in _links {\\n            Component {\\n                key = \\\"l\\\" + i\\n                @yield link with { link, tree } default {\\n                    Path {\\n                        stroke = \\\"#000\\\"; fill = \\\"none\\\"\\n                        d = getPath(link)\\n                    }\\n                }\\n            }\\n        }\\n        @for (node, i) in _nodes {\\n            Component {\\n                key = \\\"c\\\" + i\\n                coord = \\\"cartesian\\\"\\n                x = node.x\\n                y = node.y\\n                on:mousedown = dragStart(node)\\n                @yield node with { node, tree } default {\\n                    Circle.centered {\\n                        r = 8\\n                        fill = node.parent ? \\\"#999\\\" : \\\"#f00\\\"\\n                        @props prop.opt.node\\n                    }\\n                    Text {\\n                        text = node.data.name\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\")], HyperbolicTree);\n  return HyperbolicTree;\n}();\n\nexport { HyperbolicTree }; // @ts-ignore\n\nfunction getMinLength(d) {\n  var min = 99999999;\n  d.each(function (node) {\n    var len = node.data.length;\n\n    if (len > 0 && len < min) {\n      min = len;\n    }\n  });\n  return min;\n}\n\nvar Point = /*#__PURE__*/function () {\n  function Point() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, Point);\n\n    this.x = x;\n    this.y = y;\n  }\n\n  _createClass(Point, [{\n    key: \"copyFrom\",\n    value: function copyFrom(p) {\n      this.x = p.x;\n      this.y = p.y;\n    }\n  }, {\n    key: \"toE\",\n    value: function toE() {\n      this.x = Math.tanh(this.x);\n      this.y = Math.tanh(this.y);\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(p) {\n      var d_r = this.x * p.x + this.y * p.y + 1;\n      var d_i = this.y * p.x - this.x * p.y;\n      var d = d_r * d_r + d_i * d_i;\n      var r = this.x + p.x;\n      var i = this.y + p.y;\n      this.x = (r * d_r + i * d_i) / d;\n      this.y = (i * d_r - r * d_i) / d;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(x, y) {\n      return new Point(x, y);\n    }\n  }]);\n\n  return Point;\n}();\n\nvar Node = /*#__PURE__*/function () {\n  function Node(tree, parent, data, depth, height, weight) {\n    _classCallCheck(this, Node);\n\n    this.tree = tree;\n    this.parent = parent;\n    this.data = data;\n    this.depth = depth;\n    this.height = height;\n    this.weight = weight;\n    this.pos = new Point();\n    this.originalPos = new Point();\n  }\n\n  _createClass(Node, [{\n    key: \"layout\",\n    value: function layout(angle, wedge) {\n      if (this.parent) {\n        this.pos.x = 0.45 * Math.cos(angle);\n        this.pos.y = 0.45 * Math.sin(angle);\n        this.pos.toE();\n        this.pos.translate(this.parent.pos);\n        this.originalPos = new Point();\n        this.originalPos.copyFrom(this.pos);\n      }\n\n      if (!this.children) return;\n\n      if (this.parent && wedge > Math.PI) {\n        wedge = Math.PI;\n      }\n\n      var startAngle = angle - wedge / 2;\n\n      var _iterator = _createForOfIteratorHelper(this.children),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var c = _step.value;\n          var p = c.weight / this.weight;\n          var childWidth = p * wedge;\n          var childAngle = startAngle + childWidth / 2;\n          c.layout(childAngle, childWidth);\n          startAngle += childWidth;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"updateTranslation\",\n    value: function updateTranslation(t) {\n      this.pos.copyFrom(this.originalPos);\n      this.pos.translate(t);\n\n      if (this.data.name === \"A\") {\n        console.log(this.pos.x, this.pos.y);\n      }\n\n      if (this.children) {\n        var _iterator2 = _createForOfIteratorHelper(this.children),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var c = _step2.value;\n            c.updateTranslation(t);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }\n  }, {\n    key: \"endTranslation\",\n    value: function endTranslation() {\n      this.originalPos.copyFrom(this.pos);\n\n      if (this.children) {\n        var _iterator3 = _createForOfIteratorHelper(this.children),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var c = _step3.value;\n            c.endTranslation();\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n    }\n  }, {\n    key: \"links\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function links() {\n      var _iterator4, _step4, c, _iterator5, _step5, _c;\n\n      return _regeneratorRuntime.wrap(function links$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!this.children) {\n                _context.next = 34;\n                break;\n              }\n\n              _iterator4 = _createForOfIteratorHelper(this.children);\n              _context.prev = 2;\n\n              _iterator4.s();\n\n            case 4:\n              if ((_step4 = _iterator4.n()).done) {\n                _context.next = 10;\n                break;\n              }\n\n              c = _step4.value;\n              _context.next = 8;\n              return {\n                source: this,\n                target: c\n              };\n\n            case 8:\n              _context.next = 4;\n              break;\n\n            case 10:\n              _context.next = 15;\n              break;\n\n            case 12:\n              _context.prev = 12;\n              _context.t0 = _context[\"catch\"](2);\n\n              _iterator4.e(_context.t0);\n\n            case 15:\n              _context.prev = 15;\n\n              _iterator4.f();\n\n              return _context.finish(15);\n\n            case 18:\n              _iterator5 = _createForOfIteratorHelper(this.children);\n              _context.prev = 19;\n\n              _iterator5.s();\n\n            case 21:\n              if ((_step5 = _iterator5.n()).done) {\n                _context.next = 26;\n                break;\n              }\n\n              _c = _step5.value;\n              return _context.delegateYield(_c.links(), \"t1\", 24);\n\n            case 24:\n              _context.next = 21;\n              break;\n\n            case 26:\n              _context.next = 31;\n              break;\n\n            case 28:\n              _context.prev = 28;\n              _context.t2 = _context[\"catch\"](19);\n\n              _iterator5.e(_context.t2);\n\n            case 31:\n              _context.prev = 31;\n\n              _iterator5.f();\n\n              return _context.finish(31);\n\n            case 34:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, links, this, [[2, 12, 15, 18], [19, 28, 31, 34]]);\n    })\n  }, {\n    key: \"nodes\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function nodes() {\n      var _iterator6, _step6, c;\n\n      return _regeneratorRuntime.wrap(function nodes$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this;\n\n            case 2:\n              if (!this.children) {\n                _context2.next = 19;\n                break;\n              }\n\n              _iterator6 = _createForOfIteratorHelper(this.children);\n              _context2.prev = 4;\n\n              _iterator6.s();\n\n            case 6:\n              if ((_step6 = _iterator6.n()).done) {\n                _context2.next = 11;\n                break;\n              }\n\n              c = _step6.value;\n              return _context2.delegateYield(c.nodes(), \"t0\", 9);\n\n            case 9:\n              _context2.next = 6;\n              break;\n\n            case 11:\n              _context2.next = 16;\n              break;\n\n            case 13:\n              _context2.prev = 13;\n              _context2.t1 = _context2[\"catch\"](4);\n\n              _iterator6.e(_context2.t1);\n\n            case 16:\n              _context2.prev = 16;\n\n              _iterator6.f();\n\n              return _context2.finish(16);\n\n            case 19:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, nodes, this, [[4, 13, 16, 19]]);\n    })\n  }, {\n    key: \"x\",\n    get: function get() {\n      return this.pos.x * this.tree.radius;\n    }\n  }, {\n    key: \"y\",\n    get: function get() {\n      return this.pos.y * this.tree.radius;\n    }\n  }], [{\n    key: \"fromHierarchy\",\n    value: function fromHierarchy(tree, h) {\n      var _a;\n\n      var node = new Node(tree, undefined, h.data, h.depth, h.height, h.value);\n      node.children = (_a = h.children) === null || _a === void 0 ? void 0 : _a.map(function (c) {\n        var n = Node.fromHierarchy(tree, c);\n        n.parent = node;\n        return n;\n      });\n      return node;\n    }\n  }]);\n\n  return Node;\n}();","map":null,"metadata":{},"sourceType":"module"}