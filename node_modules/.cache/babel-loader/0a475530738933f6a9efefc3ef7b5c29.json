{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport config from \"../config\";\nimport { Component } from \"../element/component\";\nimport { getComponent } from \"../element/get-component\";\nimport { isRenderable } from \"../element/is\";\nimport { adjustByAnchor, layoutElement } from \"../layout/layout\";\nimport { kLazyElement } from \"./element-def\"; // @ts-ignore\n\nimport shallowEqArrays from \"shallow-equal/arrays\";\nvar INHERITED_PROPS = [\"x\", \"y\", \"width\", \"height\", \"anchor\", \"rotation\", \"visible\"];\nvar currElements = [];\n\nvar currElement = function currElement() {\n  return currElements[currElements.length - 1];\n};\n\nvar currElementInheriting = false;\nvar currCoordRoots = [];\n\nvar currCoordRoot = function currCoordRoot() {\n  return currCoordRoots.length === 0 ? null : currCoordRoots[currCoordRoots.length - 1];\n};\n\nvar currCoordSystems = [\"cartesian\"];\n\nvar currCoordSystem = function currCoordSystem() {\n  return currCoordSystems[currCoordSystems.length - 1];\n};\n\nvar xScaleSystemChanged = false;\nvar yScaleSystemChanged = false;\n\nfunction findComponent(component, name, id) {\n  var ctor = getComponent(isRenderable(component) ? component : component.$parent, name);\n  var comp = component.findChild(id, name || \"Component\");\n\n  if (comp) {\n    comp._isActive = true;\n    comp._reordered = false;\n    return [comp, false];\n  }\n\n  var newElm = new ctor(id);\n  newElm._name = name;\n  component.append(newElm);\n  var c;\n\n  if (c = currElement()) {\n    newElm.$parent = c;\n\n    if (currElementInheriting) {\n      newElm.logicalParent = c;\n    }\n  }\n\n  return [newElm, true];\n}\n\nfunction shouldUpdateElement(elm, opt) {\n  if (elm.$v.forceRedraw) return true;\n\n  if (elm.forceUpdate) {\n    elm.forceUpdate = false;\n    return true;\n  }\n\n  if (elm.shouldUpdate) {\n    var result = elm.shouldUpdate();\n    if (typeof result === \"boolean\") return result;\n  }\n\n  if (!(xScaleSystemChanged && elm.isInXScaleSystem || yScaleSystemChanged && elm.isInYScaleSystem) && elm.compareProps(opt.props)) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function updateTree(parent, def_, order) {\n  var _a;\n\n  var elm;\n  var created;\n  var xScaleChangeRoot = false,\n      yScaleChangeRoot = false;\n  var def;\n\n  if (!def_) {\n    elm = parent;\n  } else {\n    var _findComponent = findComponent(parent, def_.tag, def_.id);\n\n    var _findComponent2 = _slicedToArray(_findComponent, 2);\n\n    elm = _findComponent2[0];\n    created = _findComponent2[1];\n    def = def_[kLazyElement] ? def_.unfold(elm) : def_;\n    var _def = def,\n        opt = _def.opt;\n    if (order !== undefined) elm._order = order;\n\n    if (opt.props.debug) {\n      console.log(\"Rendering component:\");\n    } // inherit props\n\n\n    if (currElementInheriting) {\n      var p = currElement().prop;\n\n      var _iterator = _createForOfIteratorHelper(INHERITED_PROPS),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var prop = _step.value;\n\n          if (!(prop in opt.props) && prop in p) {\n            opt.props[prop] = p[prop];\n            if (prop === \"width\") elm._inheritedWidth = true;\n            if (prop === \"height\") elm._inheritedHeight = true;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    if (\"_initArg\" in opt.props) {\n      var initArgPropName = elm.constructor.propNameForInitializer();\n\n      if (initArgPropName === null) {\n        throw new Error(\"An initializer \".concat(opt.props._initArg, \" is provided, but the component doesn't accept one.\"));\n      }\n\n      opt.props[initArgPropName] = opt.props._initArg;\n    }\n\n    opt.props.children = def.children;\n    opt.props.namedChildren = def.opt.namedChildren || {};\n    if (opt.on) elm.setEventHandlers(opt.on);\n    if (opt.styles) elm.setStyles(opt.styles);\n    if (opt.behaviors) elm.setBehaviors(opt.behaviors);\n    if (opt.stages) elm.$stages = opt.stages;\n    var o = opt.props._on;\n\n    if (o) {\n      elm.setEventHandlers(o);\n    }\n\n    var b = opt.props._behavior;\n\n    if (b) {\n      elm.setBehaviors(b);\n    }\n\n    var s = opt.props._stages;\n\n    if (s) {\n      Object.keys(s).forEach(function (k) {\n        if (elm.$stages[k]) {\n          elm.$stages[k] = Object.assign(Object.assign({}, elm.$stages[k]), s[k]);\n        } else {\n          elm.$stages[k] = s[k];\n        }\n      });\n    }\n\n    if (\"stage\" in opt.props) {\n      elm.state.stage = opt.props.stage;\n    } // ref\n\n\n    var ce = currElement(),\n        ref = opt.props.ref;\n\n    if (ce && ref) {\n      if (ref.endsWith(\"[]\")) {\n        var name = ref.substr(0, ref.length - 2),\n            r = ce.$ref[name];\n\n        if (Array.isArray(r)) {\n          r.push(elm);\n        } else {\n          ce.$ref[name] = [elm];\n        }\n      } else {\n        ce.$ref[ref] = elm;\n      }\n    }\n\n    if (!elm._firstRender) {\n      if (isRenderable(elm)) {\n        if (!shouldUpdateElement(elm, opt)) return;\n      } else {\n        if (opt.props[\"xScale\"]) {\n          var _s2 = opt.props.xScale;\n          var sn = elm[\"_prop\"].xScale;\n\n          if (_s2.__scale__ && sn.__scale__ && _s2.type === sn.type && (_s2.domain === sn.domain || shallowEqArrays(_s2.domain, sn.domain)) && (_s2.range === sn.range || shallowEqArrays(_s2.range, sn.range))) {\n            xScaleSystemChanged = false;\n          } else {\n            xScaleChangeRoot = true;\n            xScaleSystemChanged = true;\n          }\n        }\n\n        if (opt.props[\"yScale\"]) {\n          var _s3 = opt.props.yScale;\n          var _sn = elm[\"_prop\"].yScale;\n\n          if (_s3.__scale__ && _sn.__scale__ && _s3.type === _sn.type && (_s3.domain === _sn.domain || shallowEqArrays(_s3.domain, _sn.domain)) && (_s3.range === _sn.range || shallowEqArrays(_s3.range, _sn.range))) {\n            yScaleSystemChanged = false;\n          } else {\n            yScaleChangeRoot = true;\n            yScaleSystemChanged = true;\n          }\n        }\n      }\n    }\n\n    if (elm instanceof Component) elm.$ref = {};\n    elm.setProp(opt.props);\n    if (created) elm.$callHook(\"didCreate\");\n  }\n\n  var newCoordSystem = elm instanceof Component && elm.prop.coord && elm.prop.coord !== currCoordSystem();\n  elm.$coord = currCoordRoot();\n\n  if (newCoordSystem) {\n    currCoordRoots.push(elm);\n    currCoordSystems.push(elm.prop.coord);\n    elm.$isCoordRoot = true;\n  } else {\n    elm.$isCoordRoot = false;\n  }\n\n  elm.$callHook(\"willUpdate\");\n\n  elm._findActiveStage();\n\n  elm.parseInternalProps();\n  if (config.typeCheck) elm.performTypeCheck();\n  layoutElement(elm);\n  if (elm.prop.debug) console.log(elm);\n  elm.$callHook(\"didLayout\");\n\n  if (isRenderable(elm)) {\n    currElements.push(elm);\n    currElementInheriting = true;\n    elm.$callHook(\"willRender\");\n    var tree = elm.render();\n    elm.$callHook(\"didRender\");\n    updateTree(elm, tree);\n    currElements.pop();\n  } else if (elm instanceof Component) {\n    currElementInheriting = false;\n\n    if (!elm.isStatic || elm._firstRender) {\n      // reset isActive status\n      elm.children.forEach(function (c) {\n        return c._isActive = false;\n      }); // z-index\n\n      for (var i = 0, l = def.children.length; i < l; i++) {\n        var c = def.children[i];\n\n        if (\"opt\" in c && ((_a = c.opt.props) === null || _a === void 0 ? void 0 : _a.zIndex)) {\n          // move element to the start\n          def.children.splice(i, 1);\n          def.children.push(c);\n        }\n      } // update children\n\n\n      for (var _i2 = 0, _l = def.children.length; _i2 < _l; _i2++) {\n        updateTree(elm, def.children[_i2], _i2);\n      } // sort\n\n\n      var tmp, _o;\n\n      var d = elm.children;\n\n      for (var _i3 = 0, _l2 = d.length; _i3 < _l2; _i3++) {\n        if (d[_i3]._reordered || !d[_i3]._isActive) continue; // if the order is wrong, there must exist a loop,\n        // in which each element's order is the correct order of the previous one\n\n        if (_o !== _i3) {\n          // exchange the order with the next element, until all elements in this loop have correct orders\n          while (1) {\n            tmp = d[_i3];\n            if (!tmp._isActive || tmp._order === _i3) break;\n            _o = tmp._order;\n            d[_i3] = d[_o];\n            d[_o] = tmp;\n            tmp._reordered = true;\n          }\n        } else {\n          d[_i3]._reordered = true;\n        } // loop through all elements to make sure all such loops are handled\n\n      }\n    }\n  }\n\n  if (newCoordSystem) {\n    currCoordRoots.pop();\n    currCoordSystems.pop();\n  }\n\n  if (xScaleChangeRoot) xScaleSystemChanged = false;\n  if (yScaleChangeRoot) yScaleSystemChanged = false;\n  elm.$callHook(\"didLayoutSubTree\");\n  elm.$callHook(\"willAdjustAnchor\");\n  adjustByAnchor(elm);\n  elm.$callHook(\"didUpdate\");\n  elm._firstRender = false;\n}","map":null,"metadata":{},"sourceType":"module"}