{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(ancestor);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport * as d3 from \"d3-hierarchy\";\nimport { scaleLinear, scaleLog } from \"d3-scale\";\nimport { max, min } from \"../../utils/math\";\nimport { useTemplate } from \"../../ext/decorator\";\nimport { Component } from \"../component\";\n\nvar Tree =\n/** @class */\nfunction () {\n  var Tree = /*#__PURE__*/function (_Component) {\n    _inherits(Tree, _Component);\n\n    var _super = _createSuper(Tree);\n\n    function Tree() {\n      var _this;\n\n      _classCallCheck(this, Tree);\n\n      _this = _super.apply(this, arguments); // @ts-ignore\n\n      _this._scaleY = null;\n      _this.isRadical = false;\n      _this.isHorizontal = false;\n      _this.isInversed = false; // @ts-ignore\n\n      _this.isScaled = false;\n      return _this;\n    }\n\n    _createClass(Tree, [{\n      key: \"init\",\n      value: function init() {\n        var _this2 = this;\n\n        this.state = {\n          activePath: new Set()\n        };\n        this._extMethods = {};\n        [\"leafRotation\", \"leafAnchor\", \"isRightHalf\", \"getPath\", \"isActiveLink\"].forEach(function (name) {\n          _this2._extMethods[name] = _this2._bindMethod(_this2[name]);\n        });\n      }\n    }, {\n      key: \"willRender\",\n      value: function willRender() {\n        var _this3 = this;\n\n        var data = this.prop.data;\n        this.isRadical = this.prop.direction === \"radical\";\n        var width, height;\n\n        switch (this.prop.direction) {\n          case \"radical\":\n            var totalR = this.prop.r || Math.min(this.$geometry.width, this.$geometry.height) / 2;\n\n            if (totalR <= 0) {\n              console.warn(\"Tree: radius is 0. The tree should have a proper size.\");\n            }\n\n            width = this.prop.deg;\n            height = totalR - this.prop.leafSize;\n            this.isHorizontal = false;\n            this.isInversed = false;\n            break;\n\n          case \"top\":\n          case \"bottom\":\n            this.width = width = this.$geometry.width;\n            this.height = height = this.$geometry.height - this.prop.leafSize;\n            this.isHorizontal = false;\n            this.isInversed = this.prop.direction === \"top\";\n            break;\n\n          case \"right\":\n          case \"left\":\n            this.width = width = this.$geometry.height;\n            this.height = height = this.$geometry.width - this.prop.leafSize;\n            this.isHorizontal = true;\n            this.isInversed = this.prop.direction === \"left\";\n            break;\n\n          default:\n            width = 0;\n            height = 0;\n        }\n\n        var hierarchy = d3.hierarchy(data).sum(function (d) {\n          return d.length;\n        });\n        var cluster = d3.cluster().size([width, height]).separation(function () {\n          return 1;\n        });\n        this._root = cluster(hierarchy);\n\n        switch (this.prop.scale) {\n          case \"none\":\n            this._scaleY = null;\n            this.isScaled = false;\n            break;\n\n          case \"scale\":\n            this._scaleY = scaleLinear().range([0, height]).domain([0, getMaxLength(this._root)]);\n            this.isScaled = true;\n            break;\n\n          case \"log\":\n            this._scaleY = scaleLog().range([0, height]).domain([1, getMaxLength(this._root) + 1]);\n            this.isScaled = true;\n            break;\n        }\n\n        this._root.eachBefore(function (n) {\n          if (n.parent) {\n            n.data._radius = n.data.length + n.parent.data._radius;\n          } else {\n            n.data._radius = 0;\n          }\n        }); // min and max angle\n\n\n        this._root.eachAfter(function (n) {\n          if (n.children) {\n            n.data._minAngle = min(n.children, function (c) {\n              return c.data._minAngle;\n            });\n            n.data._maxAngle = max(n.children, function (c) {\n              return c.data._maxAngle;\n            });\n          } else {\n            n.data._minAngle = n.data._maxAngle = n.x;\n          }\n        });\n\n        this._links = this._root.links(); // console.log(this);\n\n        this._leafLinks = this._links.filter(function (d) {\n          return !d.target.children;\n        });\n        this._leaves = [];\n        this._nodes = [];\n\n        this._root.each(function (n) {\n          if (n.children) {\n            _this3._nodes.push(n);\n          } else {\n            _this3._leaves.push(n);\n          }\n        });\n\n        this._nodeCount = this._nodes.length;\n        this._leafCount = this._leaves.length;\n        this._leafDeg = this.prop.deg / this._leafCount;\n      }\n    }, {\n      key: \"didUpdate\",\n      value: function didUpdate() {// console.log(this.$ref.links);\n      }\n    }, {\n      key: \"defaultProp\",\n      value: function defaultProp() {\n        return Object.assign(Object.assign({}, _get(_getPrototypeOf(Tree.prototype), \"defaultProp\", this).call(this)), {\n          deg: 360,\n          scale: \"none\",\n          direction: \"bottom\",\n          treeRotation: 0,\n          leafSize: 20,\n          branchInteraction: true\n        });\n      } // @ts-ignore\n\n    }, {\n      key: \"getPath\",\n      value: function getPath(x1, y1, x2, y2) {\n        if (this.isRadical) {\n          var xDiff = Math.abs(x2 - x1);\n          var c0 = Math.cos(x1 = (x1 - 90) / 180 * Math.PI);\n          var s0 = Math.sin(x1);\n          var c1 = Math.cos(x2 = (x2 - 90) / 180 * Math.PI);\n          var s1 = Math.sin(x2);\n          var path;\n\n          switch (this.prop.linkStyle) {\n            case \"straight\":\n              return \"M\".concat(y1 * c0, \",\").concat(y1 * s0, \" L\").concat(y2 * c1, \",\").concat(y2 * s1);\n\n            default:\n              path = \"M\".concat(y1 * c0, \",\").concat(y1 * s0, \" \");\n\n              if (x2 !== x1) {\n                path += \"A\".concat(y1, \",\").concat(y1, \" 0 \").concat(xDiff > 180 ? 1 : 0, \" \").concat(x2 > x1 ? 1 : 0, \" \").concat(y1 * c1, \",\").concat(y1 * s1);\n              }\n\n              path += \"L\".concat(y2 * c1, \",\").concat(y2 * s1);\n              return path;\n          }\n        } else {\n          if (this.isHorizontal) {\n            return \"M\".concat(x1, \",\").concat(y1, \" L\").concat(x1, \",\").concat(y2, \" L\").concat(x2, \",\").concat(y2);\n          } else {\n            return \"M\".concat(x1, \",\").concat(y1, \" L\").concat(x2, \",\").concat(y1, \" L\").concat(x2, \",\").concat(y2);\n          }\n        }\n      } // @ts-ignore\n\n    }, {\n      key: \"getX\",\n      value: function getX(node) {\n        var forceEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        if (this.isHorizontal) {\n          var y = forceEnd || this.prop.scale === \"none\" ? node.y : this._scaleY(node.data._radius);\n          return this.isInversed ? this.height - y + this.prop.leafSize : y;\n        } else {\n          return this.isInversed ? this.width - node.x : node.x;\n        }\n      } // @ts-ignore\n\n    }, {\n      key: \"getY\",\n      value: function getY(node) {\n        var forceEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        if (this.isHorizontal) {\n          return this.isInversed ? this.width - node.x : node.x;\n        } else {\n          var y = forceEnd || this.prop.scale === \"none\" ? node.y : this._scaleY(node.data._radius);\n          return this.isInversed ? this.height - y + this.prop.leafSize : y;\n        }\n      } // @ts-ignore\n\n    }, {\n      key: \"leafRotation\",\n      value: function leafRotation(leaf) {\n        var isRight = this.isRightHalf(leaf.x);\n\n        switch (this.prop.direction) {\n          case \"radical\":\n            return [isRight ? leaf.x - 90 : leaf.x + 90, \"_\", \"_\"];\n\n          case \"bottom\":\n            return [90, \"_\", \"_\"];\n\n          case \"top\":\n            return [270, \"_\", \"_\"];\n\n          default:\n            return 0;\n        }\n      } // @ts-ignore\n\n    }, {\n      key: \"leafAnchor\",\n      value: function leafAnchor(leaf) {\n        var isRight = this.isRightHalf(leaf.x);\n\n        switch (this.prop.direction) {\n          case \"radical\":\n            return (isRight ? 16\n            /* Left */\n            : 64\n            /* Right */\n            ) | 4\n            /* Middle */\n            ;\n\n          case \"left\":\n            return 64\n            /* Right */\n            | 4\n            /* Middle */\n            ;\n\n          case \"top\":\n          case \"bottom\":\n          case \"right\":\n            return 16\n            /* Left */\n            | 4\n            /* Middle */\n            ;\n        }\n      } // @ts-ignore\n\n    }, {\n      key: \"isRightHalf\",\n      value: function isRightHalf(deg) {\n        switch (this.prop.direction) {\n          case \"radical\":\n            var thres1 = 180 - this.prop.treeRotation;\n            var thres2 = 360 - this.prop.treeRotation;\n            return deg < thres1 || deg > thres2;\n\n          case \"left\":\n            return false;\n\n          default:\n            return true;\n        }\n      } // @ts-ignore\n\n    }, {\n      key: \"setActive\",\n      value: function setActive(node_) {\n        var node;\n\n        if (typeof node_ === \"string\") {\n          var n = this._leaves.find(function (x) {\n            return x.data.name === node_;\n          });\n\n          if (!n) {\n            console.warn(\"Tree: setActive: cannot find a leaf with name \\\"\".concat(node_, \"\\\"\"));\n            return;\n          }\n\n          node = n;\n        } else {\n          node = node_;\n        }\n\n        if (node === null) {\n          this.setState({\n            activePath: new Set()\n          });\n        } else {\n          this.setState({\n            activePath: new Set(ancestor(node))\n          });\n        }\n      }\n    }, {\n      key: \"isActiveLink\",\n      value: function isActiveLink(link) {\n        if (!this.prop.branchInteraction) return;\n        return this.state.activePath.has(link.source.data) && this.state.activePath.has(link.target.data);\n      }\n    }, {\n      key: \"isLinkOnTop\",\n      value: function isLinkOnTop(link) {\n        return this.prop.branchShouldStayOnTop ? this.prop.branchShouldStayOnTop(link, this) : false;\n      }\n    }, {\n      key: \"ancestorOfNode\",\n      value: function ancestorOfNode(node) {\n        return ancestor(node);\n      }\n    }]);\n\n    return Tree;\n  }(Component);\n\n  Tree = __decorate([useTemplate(\"//bvt\\nComponent {\\n    @let tree = _extMethods\\n    Component {\\n        width = 100%; height = 100%\\n        coord = isRadical ? \\\"polar\\\" : \\\"cartesian\\\"\\n        @for (link, i) in _links {\\n            Component {\\n                @let isActive = isActiveLink(link)\\n                @let isOnTop = isLinkOnTop(link)\\n                @let pos = [getX(link.source), getY(link.source), getX(link.target), getY(link.target)]\\n                key = \\\"l\\\" + i\\n                zIndex = isActive || isOnTop ? 1 : null\\n                @yield link with { link, pos, tree, isActive } default {\\n                    Path {\\n                        stroke = isActive ? \\\"#000\\\" : \\\"#aaa\\\"\\n                        fill = \\\"none\\\"\\n                        d = getPath(...pos)\\n                        @props isActive ? prop.opt.activeLink : prop.opt.link\\n                    }\\n                }\\n            }\\n        }\\n        @for (node, i) in _nodes {\\n            Component {\\n                key = \\\"c\\\" + i\\n                coord = \\\"cartesian\\\"\\n                x = getX(node); y = getY(node);\\n                @yield node with { node, tree } default {\\n                    Circle.centered {\\n                        r = 2\\n                        fill = \\\"#999\\\"\\n                        behavior:tooltip {\\n                            content = node.data._radius.toString()\\n                        }\\n                        @props prop.opt.node\\n                    }\\n                }\\n            }\\n        }\\n        @for (leaf, i) in _leaves {\\n            Component {\\n                key = \\\"f\\\" + i\\n                x = getX(leaf, prop.isCluster)\\n                y = getY(leaf, prop.isCluster)\\n                width = 0\\n                rotation = leafRotation(leaf)\\n                coord = \\\"cartesian\\\"\\n                on:mouseenter = setActive(leaf)\\n                on:mouseleave = setActive(null)\\n                @yield leaf with { leaf, tree } default {\\n                    Container {\\n                        anchor = leafAnchor(leaf)\\n                        padding = 4\\n                        Text {\\n                            text = leaf.data.name\\n                        }\\n                        behavior:tooltip {\\n                            content = leaf.data._radius.toString()\\n                        }\\n                        @props prop.opt.leaf\\n                    }\\n                }\\n            }\\n            @if isScaled && prop.isCluster {\\n                Component(isRadical ? \\\"RadicalLine\\\" : \\\"Line\\\") {\\n                    x = getX(leaf);\\n                    x1 = getX(leaf);\\n                    x2 = getX(leaf, true);\\n                    y1 = getY(leaf)\\n                    y2 = getY(leaf, true)\\n                    stroke = \\\"#ccc\\\"\\n                    @props prop.opt.linkExtension\\n                }\\n            }\\n        }\\n    }\\n}\\n\")], Tree);\n  return Tree;\n}();\n\nexport { Tree };\n\nfunction ancestor(node) {\n  var n;\n  return _regeneratorRuntime.wrap(function ancestor$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          n = node;\n\n        case 1:\n          if (!n) {\n            _context.next = 7;\n            break;\n          }\n\n          _context.next = 4;\n          return n.data;\n\n        case 4:\n          n = n.parent;\n          _context.next = 1;\n          break;\n\n        case 7:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nfunction getMaxLength(d) {\n  return d.data.length + (d.children ? max(d.children, function (dd) {\n    return getMaxLength(dd);\n  }) : 0);\n} // @ts-ignore\n\n\nfunction getMinLength(d) {\n  var min = 99999999;\n  d.each(function (node) {\n    var len = node.data.length;\n\n    if (len > 0 && len < min) {\n      min = len;\n    }\n  });\n  return min;\n}","map":null,"metadata":{},"sourceType":"module"}