{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport Oviz from \"crux\";\nimport { ColorSchemeCategory, ColorSchemeGradient } from \"crux/dist/color\";\nimport { minmax } from \"crux/dist/utils/math\";\nimport { ascending, descending } from \"d3-array\";\nimport { cluster, hierarchy } from \"d3-hierarchy\";\nimport { scaleLinear } from \"d3-scale\";\nimport { groupedColors2 } from \"oviz-common/palette\";\nimport { findBoundsForValues } from \"utils/maths\";\nvar defaultScheme = groupedColors2; // const rainbow = [\n//     \"hsl(340, 82%, 73%)\",\n//     \"hsl(355, 82%, 73%)\",\n//     \"hsl(0, 73%, 72%)\",\n//     \"hsl(14, 100%, 75%)\",\n//     \"hsl(36, 100%, 74%)\",\n//     \"hsl(45, 100%, 74%)\",\n//     \"hsl(54, 90%, 72%)\",\n//     \"hsl(66, 71%, 77%)\",\n//     \"hsl(88, 50%, 76%)\",\n//     \"hsl(100, 50%, 76%)\",\n//     \"hsl(122, 37%, 74%)\",\n//     \"hsl(148, 37%, 74%)\",\n//     \"hsl(174, 42%, 65%)\",\n//     \"hsl(187, 72%, 71%)\",\n//     \"hsl(199, 92%, 74%)\",\n//     \"hsl(207, 90%, 77%)\",\n//     \"hsl(207, 90%, 77%)\",\n//     \"hsl(231, 44%, 74%)\",\n//     \"hsl(261, 46%, 74%)\",\n//     \"hsl(287, 46%, 74%)\",\n//     \"hsl(320, 47%, 71%)\",\n//     \"#AF7AC5\",\n// ];\n\nexport var brewPalette = [\"#8dd3c7\", \"#ffffb3\", \"#bebada\", \"#fb8072\", \"#80b1d3\", \"#fdb462\", \"#b3de69\", \"#fccde5\", \"#d9d9d9\", \"#bc80bd\", \"#ccebc5\", \"#ffed6f\"];\nvar rainbow2 = [\"#EC7063\", \"#E74C3C\", \"#F5B7B1\", \"#E59866\", \"#DC7633\", \"#D35400\", \"#F0B27A\", \"#F5B041\", \"#F39C12\", \"#F7DC6F\", \"#F4D03F\", \"#F1C40F\", \"#82E0AA\", \"#58D68D\", \"#28B463\", \"#76D7C4\", \"#3498DB\", \"#85C1E9\", \"#3498DB\", \"#D2B4DE\", \"#AF7AC5\"];\nvar rainbow3 = [\"#FE2712\", \"#E74C3C\", \"#CB4335\", \"#FB9902\", \"#FCBA12\", \"#FDDC22\", \"#FDED2A\", \"#FEFE33\", \"#CBE432\", \"#98CA32\", \"#66B032\", \"#559E54\", \"#448D76\", \"#347B98\", \"#6395F2\", \"#678FFE\", \"#8C78E8\", \"#905BEC\", \"#A33AF2\", \"#C91BFE\", \"#ED5094\"]; // const paletteColors = [\"#9e0142\", \"#ffffbf\", \"#313695\"];\n\nvar nodeList = [];\nexport function getLeafOrder(rootNode) {\n  nodeList = [];\n  sortTree(rootNode);\n  return nodeList;\n}\n\nfunction sortTree(d) {\n  if (d.children) {\n    d.children.forEach(function (c) {\n      sortTree(c);\n    });\n  } else {\n    nodeList.push(d.name);\n  }\n}\n\nfunction setTreeLength(node) {\n  var _node$children;\n\n  (_node$children = node.children) === null || _node$children === void 0 ? void 0 : _node$children.forEach(function (x) {\n    setTreeLength(x);\n  });\n  node.length = 200 - node.y;\n}\n\nexport function main(d) {\n  var _this = this;\n\n  var speciesLabel = d.columns[0];\n  var species = d.map(function (x) {\n    return x[speciesLabel];\n  }); // process tree\n\n  if (!this.data.ovTree) {\n    var rootNode = new TreeNode(\"root\");\n    species.forEach(function (phylum) {\n      if (phylum.startsWith(\"k_\")) {\n        var allRanks = phylum.split(\"|\");\n        var currNode = rootNode;\n        allRanks.forEach(function (_, i) {\n          var fullName = allRanks.slice(0, i + 1).join(\"|\");\n          currNode = currNode.addChild(new TreeNode(fullName));\n        });\n      } else {\n        rootNode.addChild(new TreeNode(phylum));\n      }\n    });\n    var root = hierarchy(rootNode).sort(function (a, b) {\n      return descending(a.height, b.height) || ascending(a.data.name, b.data.name);\n    });\n    root.dx = 10;\n    root.dy = 200 / (root.height + 1);\n    var clusterRoot = cluster().nodeSize([root.dx, root.dy])(root); // setTreeLength(clusterRoot);\n\n    this.data.ovTree = clusterRoot;\n    var sortedNodes = [];\n\n    var localSort = function localSort(d) {\n      if (d.children) d.children.forEach(function (c) {\n        localSort(c);\n      });else {\n        sortedNodes.push(d.name);\n      }\n    };\n\n    localSort(rootNode);\n    this.data.species = sortedNodes;\n  }\n\n  this.data.samples = this.data.filteredSamples = d.columns.splice(1, d.columns.length - 1);\n  this.data.mainDict = {};\n  d.forEach(function (x) {\n    var temp = _objectSpread({}, x);\n\n    var speciesID = temp[speciesLabel];\n    delete temp[speciesLabel];\n    Object.keys(temp).forEach(function (k) {\n      temp[k] = parseFloat(temp[k]);\n    });\n    _this.data.mainDict[speciesID] = temp;\n  });\n  this.data.mainHeatmap = [];\n  var spComp = [];\n  this.data.species.forEach(function (s) {\n    var row = [];\n    d.forEach(function (x) {\n      if (x[speciesLabel] === s) {\n        _this.data.samples.forEach(function (k) {\n          row.push(parseFloat(x[k]));\n        });\n      }\n    });\n    spComp.push({\n      id: s,\n      sum: row.reduce(function (a, b) {\n        return a + b;\n      }, 0)\n    });\n\n    _this.data.mainHeatmap.push(row);\n  });\n  var top5species = spComp.sort(function (a, b) {\n    return a.sum - b.sum;\n  }).splice(0, 21).map(function (x) {\n    return x.id;\n  }).sort(function (a, b) {\n    if (a === \"Other\") return 1;else if (b === \"Other\") return -1;else {\n      var getLastRank = function getLastRank(s) {\n        var names = s.split(\"|\");\n        var name = names[names.length - 1];\n        return name.split(\"_\")[2];\n      };\n\n      if (getLastRank(a) < getLastRank(b)) return -1;else return 1;\n    }\n  });\n  var spDict = {};\n  d.forEach(function (x) {\n    var datum = _objectSpread({}, x);\n\n    delete datum[speciesLabel];\n    Object.keys(datum).forEach(function (k) {\n      return datum[k] = parseFloat(datum[k]);\n    });\n    spDict[x[speciesLabel]] = datum;\n  });\n  this.data.hist = {\n    indexes: _toConsumableArray(top5species).reverse(),\n    result: {}\n  };\n  top5species.forEach(function (k) {\n    _this.data.hist.result[k] = Object.keys(spDict[k]).map(function (x) {\n      return [x, spDict[k][x]];\n    });\n    delete spDict[k];\n  });\n  var otherData = {};\n  Object.keys(spDict).forEach(function (sp) {\n    Object.keys(spDict[sp]).forEach(function (sm) {\n      if (!otherData[sm]) otherData[sm] = spDict[sp][sm];else otherData[sm] += spDict[sp][sm];\n    });\n  });\n  this.data.hist.colorMap = {}; // const palette = scaleLinear().domain([0, 1, 2]).range(paletteColors);\n\n  top5species.forEach(function (x, i) {\n    _this.data.hist.colorMap[x] = rainbow2[i];\n  });\n}\nexport function removeNodeLength(rootNode) {\n  var _rootNode$children;\n\n  delete rootNode.length;\n  (_rootNode$children = rootNode.children) === null || _rootNode$children === void 0 ? void 0 : _rootNode$children.forEach(function (node) {\n    removeNodeLength(node);\n  });\n  return rootNode;\n}\nexport function meta(d) {\n  var _this2 = this;\n\n  var sampleIdKey = d.columns[0];\n  this.data.metaFeatures = d.columns.slice(1, d.columns.length);\n  this.data.metaDict = {};\n  d.forEach(function (x) {\n    var sampleId = x[sampleIdKey];\n    delete x[sampleIdKey];\n    _this2.data.metaDict[sampleId] = x;\n  });\n  this.data.metaData = {};\n  this.data.metaInfo = {};\n  this.data.discaredFeatures = [];\n  var curPos = 0;\n  this.data.metaFeatures.forEach(function (k, i) {\n    if (k === \"Age\" || k === \"age\" || k === \"BMI\" || !isNaN(parseFloat(d[0][k]))) {\n      var _minmax = minmax(d.map(function (x) {\n        return x[k];\n      })),\n          _minmax2 = _slicedToArray(_minmax, 2),\n          _min = _minmax2[0],\n          _max = _minmax2[1];\n\n      _this2.data.metaInfo[k] = new MetaInfo(k, true, _min, _max, []);\n      _this2.data.metaData[k] = _this2.data.samples.map(function (x) {\n        return _this2.data.metaDict[x][k];\n      });\n    } else {\n      var _values = d.map(function (x) {\n        return x[k];\n      }).reduce(function (a, x) {\n        if (a.indexOf(x) < 0 && x !== \"NA\") a.push(x);\n        return a;\n      }, []);\n\n      if (_values.length > 6) {\n        _this2.data.discaredFeatures.push(k);\n\n        _this2.data.metaFeatures.splice(i, 1); // alert(`Meta info \"${k}\" contains more than 6 categories, will not be drawn`);\n\n      } else {\n        _this2.data.metaInfo[k] = new MetaInfo(k, false, null, null, _values, curPos + _values.length <= brewPalette.length ? brewPalette.slice(curPos, curPos + _values.length) : null);\n        _this2.data.metaData[k] = _this2.data.samples.map(function (x) {\n          return _this2.data.metaDict[x][k];\n        });\n        curPos += _values.length;\n      }\n    }\n  }); // compute left boxplot\n\n  var categories = _toConsumableArray(this.data.species);\n\n  var classifications = this.data.metaInfo[\"Group\"].values;\n  var boxData = [{\n    values: [],\n    outliers: [],\n    means: [],\n    categories: categories\n  }, {\n    values: [],\n    outliers: [],\n    means: [],\n    categories: categories\n  }];\n  var allValues = [];\n  categories.forEach(function (c, i) {\n    var initialData = [[], []];\n\n    _this2.data.samples.forEach(function (s) {\n      allValues.push(_this2.data.mainDict[c][s]);\n\n      if (_this2.data.metaDict[s].Group === classifications[0]) {\n        initialData[0].push(_this2.data.mainDict[c][s]); // initialData[0].push(Math.log10(parseFloat(mainDict[c][s])));\n      } else {\n        initialData[1].push(_this2.data.mainDict[c][s]); // initialData[1].push(Math.log10(parseFloat(mainDict[c][s])));\n      }\n    });\n\n    classifications.forEach(function (_, j) {\n      var result = [];\n      var stat1 = new Oviz.algo.Statistics(initialData[j]);\n      var interQuartileRange = stat1.Q3() - stat1.Q1();\n      initialData[j].forEach(function (d) {\n        if (d < stat1.Q3() - 1.5 * interQuartileRange || d > stat1.Q3() + 1.5 * interQuartileRange) {\n          boxData[j].outliers.push([i, d]);\n        } else {\n          result.push(d);\n        }\n      });\n      var stat2 = new Oviz.algo.Statistics(result);\n      boxData[j].values.push([stat2.min(), stat2.Q1(), stat2.median(), stat2.Q3(), stat2.max()]);\n      boxData[j].means.push(stat2.mean());\n    });\n  });\n  var valueRange = findBoundsForValues(allValues, 2);\n  this.data.boxplot = {\n    categories: categories,\n    classifications: classifications,\n    boxData: boxData,\n    valueRange: valueRange\n  };\n}\n\nvar TreeNode = /*#__PURE__*/function () {\n  function TreeNode(name) {\n    _classCallCheck(this, TreeNode);\n\n    this.name = void 0;\n    this.children = void 0;\n    this.name = name;\n  }\n\n  _createClass(TreeNode, [{\n    key: \"addChild\",\n    value: function addChild(node) {\n      if (!this.children) this.children = [];\n      if (!this.children.find(function (x) {\n        return x.name === node.name;\n      })) this.children.push(node);\n      return this.children[this.children.length - 1];\n    }\n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return this.name;\n    }\n  }]);\n\n  return TreeNode;\n}();\n\nexport var MetaInfo = /*#__PURE__*/function () {\n  // public colorEnd = \"#006d2c\";\n  function MetaInfo(key, isNumber, min, max, values) {\n    var schemeSet = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : defaultScheme;\n\n    _classCallCheck(this, MetaInfo);\n\n    this.key = key;\n    this.isNumber = isNumber;\n    this.min = min;\n    this.max = max;\n    this.values = values;\n    this.useNumber = false;\n    this.useGroup = false;\n    this.groupCount = 4;\n    this.useThres = false;\n    this.thres = [];\n    this.minDistinct = false;\n    this.maxDistinct = false;\n    this.rangeMin = void 0;\n    this.rangeMax = void 0;\n    this.colorStart = \"#f7fcfd\";\n    this.colorEnd = \"#0247FE\";\n    this.colorMap = null;\n    this.simpleKey = void 0;\n    this.scheme = void 0;\n    this.schemeSet = void 0;\n    this.useNumber = isNumber;\n    this.rangeMin = min;\n    this.rangeMax = max;\n    this.simpleKey = key.replace(/\\(|\\)| /g, \"_\");\n    this.schemeSet = schemeSet;\n    this.updateColorGetter();\n  }\n\n  _createClass(MetaInfo, [{\n    key: \"updateColorGetter\",\n    value: function updateColorGetter() {\n      if (this.colorMap === null && this.values) {\n        this.colorMap = ColorSchemeCategory.create(this.values, this.schemeSet).colors;\n      }\n\n      if (this.useNumber) {\n        var opt;\n\n        if (this.useGroup) {\n          if (this.useThres) {\n            opt = {\n              type: \"threshold\",\n              thresholds: this.thres,\n              domain: [this.min, this.max],\n              minDistinct: this.minDistinct,\n              maxDistinct: this.maxDistinct\n            };\n          } else {\n            opt = {\n              type: \"quantize\",\n              groups: this.groupCount,\n              domain: [this.min, this.max]\n            };\n          }\n        } else {\n          opt = {\n            type: \"linear\",\n            domain: [this.rangeMin, this.rangeMax]\n          };\n        }\n\n        this.scheme = ColorSchemeGradient.create(this.colorStart, this.colorEnd, opt); // v.defineGradient(`md_${this.simpleKey}`, \"horizontal\", [this.colorStart, this.colorEnd]);\n      } else {\n        this.scheme = new ColorSchemeCategory(this.colorMap);\n      }\n    }\n  }, {\n    key: \"color\",\n    value: function color(c) {\n      if (c === \"NA\" || Number.isNaN(c)) return NaN;\n      return this.scheme.get(c);\n    }\n  }, {\n    key: \"legendData\",\n    value: function legendData() {\n      if (this.useNumber && !this.useGroup) {\n        return [null, \"md_\".concat(this.simpleKey), this.rangeMin, this.rangeMax];\n      }\n\n      var lgData = this.scheme.legendData();\n      return this.useNumber ? lgData : this.values.map(function (v) {\n        return lgData.find(function (x) {\n          return x.label === v;\n        });\n      });\n    }\n  }, {\n    key: \"toObject\",\n    value: function toObject() {\n      var obj = {\n        hasValues: !!this.values\n      };\n\n      var _iterator = _createForOfIteratorHelper(MetaInfo.keys),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var k = _step.value;\n          obj[k] = this[k];\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return obj;\n    }\n  }, {\n    key: \"update\",\n    value: function update(v, obj) {\n      var _iterator2 = _createForOfIteratorHelper(MetaInfo.keys),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var k = _step2.value;\n\n          if (k === \"thres\" || k === \"valcolorues\" && obj[k]) {\n            this[k] = _toConsumableArray(obj[k]);\n          } else {\n            this[k] = obj[k];\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      this.updateColorGetter();\n    }\n  }]);\n\n  return MetaInfo;\n}();\nMetaInfo.keys = [\"isNumber\", \"useNumber\", \"useGroup\", \"min\", \"max\", \"groupCount\", \"useThres\", \"thres\", \"minDistinct\", \"maxDistinct\", \"values\", \"colorMap\", \"colorStart\", \"colorEnd\", \"rangeMin\", \"rangeMax\"];\nexport function filterSamples(v) {\n  var hidden = v.data.hiddenSamples;\n  v.data.filteredSamples = v.data.samples.filter(function (s) {\n    return !hidden.has(s);\n  });\n  v.data.sampleCount = v.data.filteredSamples.length;\n  Object.keys(v.data.hist.result).forEach(function (k) {\n    v.data.hist.result[k] = v.data.filteredSamples.map(function (x) {\n      return [x, v.data.mainDict[k][x]];\n    });\n  });\n  Object.keys(v.data.metaData).forEach(function (k) {\n    v.data.metaData[k] = v.data.filteredSamples.map(function (x) {\n      return v.data.metaDict[x][k];\n    });\n  });\n  v.data.mainHeatmap = v.data.mainHeatmap.map(function (_, i) {\n    return v.data.filteredSamples.map(function (s) {\n      return v.data.mainDict[v.data.species[i]][s];\n    });\n  });\n}\nexport var GradientBar = function GradientBar(colors, stops) {\n  _classCallCheck(this, GradientBar);\n\n  this.colors = void 0;\n  this.stops = void 0;\n  this.getColor = void 0;\n  this.colors = colors;\n  this.stops = stops;\n  this.getColor = scaleLinear().range(colors).domain(stops);\n};","map":{"version":3,"sources":["/Users/wangzhenyu/Desktop/fyp_workspace/meta_platform/app/javascript/viz/meta-overview/data.ts"],"names":["Oviz","ColorSchemeCategory","ColorSchemeGradient","minmax","ascending","descending","cluster","hierarchy","scaleLinear","groupedColors2","findBoundsForValues","defaultScheme","brewPalette","rainbow2","rainbow3","nodeList","getLeafOrder","rootNode","sortTree","d","children","forEach","c","push","name","setTreeLength","node","x","length","y","main","speciesLabel","columns","species","map","data","ovTree","TreeNode","phylum","startsWith","allRanks","split","currNode","_","i","fullName","slice","join","addChild","root","sort","a","b","height","dx","dy","clusterRoot","nodeSize","sortedNodes","localSort","samples","filteredSamples","splice","mainDict","temp","speciesID","Object","keys","k","parseFloat","mainHeatmap","spComp","s","row","id","sum","reduce","top5species","getLastRank","names","spDict","datum","hist","indexes","reverse","result","otherData","sp","sm","colorMap","removeNodeLength","meta","sampleIdKey","metaFeatures","metaDict","sampleId","metaData","metaInfo","discaredFeatures","curPos","isNaN","min","max","MetaInfo","values","indexOf","categories","classifications","boxData","outliers","means","allValues","initialData","Group","j","stat1","algo","Statistics","interQuartileRange","Q3","Q1","stat2","median","mean","valueRange","boxplot","find","key","isNumber","schemeSet","useNumber","useGroup","groupCount","useThres","thres","minDistinct","maxDistinct","rangeMin","rangeMax","colorStart","colorEnd","simpleKey","scheme","replace","updateColorGetter","create","colors","opt","type","thresholds","domain","groups","Number","NaN","get","lgData","legendData","v","label","obj","hasValues","filterSamples","hidden","hiddenSamples","filter","has","sampleCount","GradientBar","stops","getColor","range"],"mappings":"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","sourcesContent":["import Oviz from \"crux\";\nimport { ColorScheme, ColorSchemeCategory, ColorSchemeGradient } from \"crux/dist/color\";\nimport { minmax } from \"crux/dist/utils/math\";\nimport { ascending, descending} from \"d3-array\";\nimport { cluster,  hierarchy } from \"d3-hierarchy\";\nimport { scaleLinear } from \"d3-scale\";\nimport { groupedColors2, rainbow1, rainbowL} from \"oviz-common/palette\";\nimport { findBoundsForValues} from \"utils/maths\";\n\nconst defaultScheme = groupedColors2;\n// const rainbow = [\n//     \"hsl(340, 82%, 73%)\",\n//     \"hsl(355, 82%, 73%)\",\n//     \"hsl(0, 73%, 72%)\",\n//     \"hsl(14, 100%, 75%)\",\n//     \"hsl(36, 100%, 74%)\",\n//     \"hsl(45, 100%, 74%)\",\n//     \"hsl(54, 90%, 72%)\",\n//     \"hsl(66, 71%, 77%)\",\n//     \"hsl(88, 50%, 76%)\",\n//     \"hsl(100, 50%, 76%)\",\n//     \"hsl(122, 37%, 74%)\",\n//     \"hsl(148, 37%, 74%)\",\n//     \"hsl(174, 42%, 65%)\",\n//     \"hsl(187, 72%, 71%)\",\n//     \"hsl(199, 92%, 74%)\",\n//     \"hsl(207, 90%, 77%)\",\n//     \"hsl(207, 90%, 77%)\",\n//     \"hsl(231, 44%, 74%)\",\n//     \"hsl(261, 46%, 74%)\",\n//     \"hsl(287, 46%, 74%)\",\n//     \"hsl(320, 47%, 71%)\",\n//     \"#AF7AC5\",\n// ];\n\nexport const brewPalette = [\n    \"#8dd3c7\",\n    \"#ffffb3\",\n    \"#bebada\",\n    \"#fb8072\",\n    \"#80b1d3\",\n    \"#fdb462\",\n    \"#b3de69\",\n    \"#fccde5\",\n    \"#d9d9d9\",\n    \"#bc80bd\",\n    \"#ccebc5\",\n    \"#ffed6f\",\n];\n\nconst rainbow2 = [\n    \"#EC7063\", \"#E74C3C\", \"#F5B7B1\", \"#E59866\", \"#DC7633\",\n    \"#D35400\", \"#F0B27A\", \"#F5B041\", \"#F39C12\", \"#F7DC6F\",\n    \"#F4D03F\", \"#F1C40F\", \"#82E0AA\", \"#58D68D\", \"#28B463\",\n    \"#76D7C4\", \"#3498DB\", \"#85C1E9\", \"#3498DB\", \"#D2B4DE\",\n    \"#AF7AC5\",\n];\nconst rainbow3 = [\n    \"#FE2712\", \"#E74C3C\", \"#CB4335\", \"#FB9902\", \"#FCBA12\",\n    \"#FDDC22\", \"#FDED2A\", \"#FEFE33\", \"#CBE432\", \"#98CA32\",\n    \"#66B032\", \"#559E54\", \"#448D76\", \"#347B98\", \"#6395F2\",\n    \"#678FFE\", \"#8C78E8\", \"#905BEC\", \"#A33AF2\", \"#C91BFE\",\n    \"#ED5094\",\n];\n// const paletteColors = [\"#9e0142\", \"#ffffbf\", \"#313695\"];\nlet nodeList = [];\nexport function getLeafOrder(rootNode): string[] {\n    nodeList = [];\n    sortTree(rootNode);\n    return nodeList;\n}\nfunction sortTree(d): any {\n    if (d.children) {\n        d.children.forEach(c => {\n            sortTree(c);\n        });\n    } else {\n        nodeList.push(d.name);\n    }\n}\nfunction setTreeLength(node) {\n    node.children?.forEach(x => {\n        setTreeLength(x);\n    });\n    node.length = 200 - node.y;\n}\n\nexport function main(d) {\n    const speciesLabel = d.columns[0];\n    const species = d.map(x => x[speciesLabel]);\n\n    // process tree\n    if (!this.data.ovTree) {\n        const rootNode = new TreeNode(\"root\");\n        species.forEach(phylum => {\n            if (phylum.startsWith(\"k_\")) {\n                const allRanks = phylum.split(\"|\");\n                let currNode = rootNode;\n                allRanks.forEach((_, i) => {\n                    const fullName = allRanks.slice(0, i + 1).join(\"|\");\n                    currNode = currNode.addChild(new TreeNode(fullName));\n                });\n            } else {\n                rootNode.addChild(new TreeNode(phylum));\n            }\n        });\n        const root = hierarchy(rootNode).sort((a, b) =>\n            descending(a.height, b.height) || ascending(a.data.name, b.data.name));\n        root.dx = 10;\n        root.dy = 200 / (root.height + 1);\n        const clusterRoot = cluster().nodeSize([root.dx, root.dy])(root);\n        // setTreeLength(clusterRoot);\n        this.data.ovTree = clusterRoot;\n        const sortedNodes = [];\n        const localSort = (d) => {\n            if (d.children)\n                d.children.forEach(c => {\n                    localSort(c);\n                });\n            else {\n                sortedNodes.push(d.name);\n            }\n        };\n        localSort(rootNode);\n        this.data.species = sortedNodes;\n    }\n\n    this.data.samples = this.data.filteredSamples = d.columns.splice(1, d.columns.length - 1);\n    this.data.mainDict = {};\n    d.forEach(x => {\n        const temp = {...x};\n        const speciesID = temp[speciesLabel];\n        delete temp[speciesLabel];\n        Object.keys(temp).forEach(k => {\n            temp[k] = parseFloat(temp[k]);\n        });\n        this.data.mainDict[speciesID] = temp;\n    });\n    this.data.mainHeatmap = [];\n    const spComp = [];\n    this.data.species.forEach(s => {\n        const row = [];\n        d.forEach(x => {\n            if (x[speciesLabel] === s) {\n                this.data.samples.forEach(k => {\n                    row.push(parseFloat(x[k]));\n                });\n            }\n        });\n        spComp.push({\n            id: s,\n            sum: row.reduce((a, b) => a + b, 0),\n        });\n        this.data.mainHeatmap.push(row);\n    });\n    const top5species = spComp.sort((a, b) => a.sum - b.sum)\n          .splice(0, 21)\n          .map(x => x.id)\n          .sort((a, b) => {\n              if (a === \"Other\") return 1;\n              else if (b === \"Other\") return -1;\n              else {\n                const getLastRank = (s): string => {\n                    const names = s.split(\"|\");\n                    const name = names[names.length - 1];\n                    return name.split(\"_\")[2];\n                };\n                if (getLastRank(a) < getLastRank(b)) return -1;\n                else return 1;\n              }\n          });\n    const spDict = {};\n    d.forEach(x => {\n        const datum = {...x};\n        delete datum[speciesLabel];\n        Object.keys(datum).forEach(k => datum[k] = parseFloat(datum[k]));\n        spDict[x[speciesLabel]] = datum;\n    });\n    this.data.hist = {\n                    indexes: [...top5species].reverse(),\n                    result: {}};\n    top5species.forEach(k => {\n        this.data.hist.result[k] = Object.keys(spDict[k])\n                            .map(x => [x, spDict[k][x]]);\n        delete spDict[k];\n    });\n    const otherData = {};\n    Object.keys(spDict).forEach(sp => {\n        Object.keys(spDict[sp]).forEach(sm => {\n            if (!otherData[sm]) otherData[sm] = spDict[sp][sm];\n            else\n                otherData[sm] += spDict[sp][sm];\n        });\n    });\n\n    this.data.hist.colorMap = {};\n    // const palette = scaleLinear().domain([0, 1, 2]).range(paletteColors);\n    top5species.forEach((x, i) => {\n        this.data.hist.colorMap[x] = rainbow2[i];\n    });\n}\n\nexport function removeNodeLength(rootNode): any {\n    delete rootNode.length;\n    rootNode.children?.forEach(node => {\n        removeNodeLength(node);\n    });\n    return rootNode;\n}\n\nexport function meta(d) {\n    const sampleIdKey = d.columns[0];\n    this.data.metaFeatures = d.columns.slice(1, d.columns.length);\n    this.data.metaDict = {};\n    d.forEach(x => {\n        const sampleId = x[sampleIdKey];\n        delete x[sampleIdKey];\n        this.data.metaDict[sampleId] = x;\n    });\n    this.data.metaData = {};\n    this.data.metaInfo = {};\n    this.data.discaredFeatures = [];\n    let curPos = 0;\n    this.data.metaFeatures.forEach((k, i) => {\n        if (k === \"Age\" || k === \"age\" || k === \"BMI\" || !isNaN(parseFloat(d[0][k]))) {\n            const [min, max] = minmax(d.map(x => x[k]));\n            this.data.metaInfo[k] = new MetaInfo(k, true, min, max, []);\n            this.data.metaData[k] = this.data.samples.map(x => this.data.metaDict[x][k]);\n        } else {\n            const values = d.map(x => x[k]).reduce((a, x) => {\n                if (a.indexOf(x) < 0 && x !== \"NA\") a.push(x);\n                return a;\n            }, []);\n            if (values.length > 6) {\n                this.data.discaredFeatures.push(k);\n                this.data.metaFeatures.splice(i, 1);\n                // alert(`Meta info \"${k}\" contains more than 6 categories, will not be drawn`);\n            } else {\n                this.data.metaInfo[k] = new MetaInfo(k, false, null, null, values,\n                    curPos + values.length <= brewPalette.length ?\n                        brewPalette.slice(curPos, curPos + values.length) : null);\n                this.data.metaData[k] = this.data.samples.map(x => this.data.metaDict[x][k]);\n                curPos += values.length;\n            }\n        }\n    });\n    // compute left boxplot\n    const categories = [...this.data.species];\n    const classifications = this.data.metaInfo[\"Group\"].values;\n    const boxData = [{values: [], outliers: [], means: [], categories}, {values: [], outliers: [], means: [], categories}];\n    const allValues = [];\n    categories.forEach((c, i) => {\n        const initialData = [[], []];\n        this.data.samples.forEach(s => {\n            allValues.push(this.data.mainDict[c][s]);\n            if (this.data.metaDict[s].Group === classifications[0]) {\n                initialData[0].push(this.data.mainDict[c][s]);\n                // initialData[0].push(Math.log10(parseFloat(mainDict[c][s])));\n            } else {\n                initialData[1].push(this.data.mainDict[c][s]);\n                // initialData[1].push(Math.log10(parseFloat(mainDict[c][s])));\n            }\n        });\n        classifications.forEach((_, j) => {\n            const result = [];\n            const stat1 = new Oviz.algo.Statistics(initialData[j]);\n            const interQuartileRange = stat1.Q3() - stat1.Q1();\n            initialData[j].forEach(d => {\n                if ((d < stat1.Q3() - 1.5 * interQuartileRange) || (d > stat1.Q3() + 1.5 * interQuartileRange))  {\n                    boxData[j].outliers.push([i, d]);\n                } else {\n                    result.push(d);\n                }\n            });\n            const stat2 = new Oviz.algo.Statistics(result);\n            boxData[j].values.push([stat2.min(), stat2.Q1(), stat2.median(), stat2.Q3(), stat2.max()]);\n            boxData[j].means.push(stat2.mean());\n        });\n    });\n    const valueRange = findBoundsForValues(allValues, 2);\n    this.data.boxplot = {categories, classifications, boxData, valueRange};\n}\nclass TreeNode {\n    protected name: string;\n    protected children?: TreeNode[];\n\n    constructor(name: string) {\n        this.name = name;\n    }\n\n    public addChild(node: TreeNode): TreeNode {\n        if (!this.children) this.children = [];\n        if (!this.children.find(x => x.name === node.name))\n            this.children.push(node);\n        return this.children[this.children.length - 1];\n    }\n    public getName() { return this.name; }\n}\n\nexport class MetaInfo {\n    public static keys = [\n        \"isNumber\",\n        \"useNumber\",\n        \"useGroup\",\n        \"min\",\n        \"max\",\n        \"groupCount\",\n        \"useThres\",\n        \"thres\",\n        \"minDistinct\",\n        \"maxDistinct\",\n        \"values\",\n        \"colorMap\",\n        \"colorStart\",\n        \"colorEnd\",\n        \"rangeMin\",\n        \"rangeMax\",\n    ];\n    public useNumber = false;\n    public useGroup = false;\n    public groupCount = 4;\n    public useThres = false;\n    public thres: number[] = [];\n    public minDistinct = false;\n    public maxDistinct = false;\n\n    public rangeMin: number;\n    public rangeMax: number;\n    public colorStart = \"#f7fcfd\";\n    // public colorEnd = \"#006d2c\";\n    public colorEnd = \"#0247FE\";\n    public colorMap: Record<string, string> = null;\n\n    private simpleKey: string;\n    private scheme: ColorScheme;\n    private schemeSet;\n\n    constructor(public key: string, public isNumber: boolean, public min: number,\n                public max: number, public values: string[], schemeSet = defaultScheme) {\n        this.useNumber = isNumber;\n        this.rangeMin = min;\n        this.rangeMax = max;\n        this.simpleKey = key.replace(/\\(|\\)| /g, \"_\");\n        this.schemeSet = schemeSet;\n        this.updateColorGetter();\n    }\n\n    public updateColorGetter() {\n        if (this.colorMap === null && this.values) {\n            this.colorMap = ColorSchemeCategory.create(this.values, this.schemeSet as string[]).colors;\n        }\n        if (this.useNumber) {\n            let opt;\n            if (this.useGroup) {\n                if (this.useThres) {\n                    opt = {\n                        type: \"threshold\",\n                        thresholds: this.thres,\n                        domain: [this.min, this.max],\n                        minDistinct: this.minDistinct,\n                        maxDistinct: this.maxDistinct,\n                    };\n                } else {\n                    opt = {\n                        type: \"quantize\",\n                        groups: this.groupCount,\n                        domain: [this.min, this.max],\n                    };\n                }\n            } else {\n                opt = { type: \"linear\", domain: [this.rangeMin, this.rangeMax] };\n            }\n            this.scheme = ColorSchemeGradient.create(this.colorStart, this.colorEnd, opt);\n            // v.defineGradient(`md_${this.simpleKey}`, \"horizontal\", [this.colorStart, this.colorEnd]);\n        } else {\n            this.scheme = new ColorSchemeCategory(this.colorMap);\n        }\n    }\n\n    public color(c: number | string) {\n        if (c === \"NA\" || Number.isNaN(c) ) return NaN;\n        return this.scheme.get(c);\n    }\n\n    public legendData() {\n        if (this.useNumber && !this.useGroup) {\n            return [null, `md_${this.simpleKey}`, this.rangeMin, this.rangeMax];\n        }\n        const lgData = this.scheme.legendData();\n        return this.useNumber ? lgData : this.values.map(v => lgData.find(x => x.label === v));\n    }\n\n    public toObject() {\n        const obj = { hasValues: !!this.values };\n        for (const k of MetaInfo.keys) obj[k] = this[k];\n        return obj;\n    }\n\n    public update(v: any, obj: any) {\n        for (const k of MetaInfo.keys) {\n            if (k === \"thres\" || (k === \"valcolorues\" && obj[k])) {\n                this[k] = [...obj[k]];\n            } else {\n                this[k] = obj[k];\n            }\n        }\n        this.updateColorGetter();\n    }\n}\n\nexport function filterSamples(v: any) {\n    const hidden: Set<string> = v.data.hiddenSamples;\n    v.data.filteredSamples = v.data.samples.filter(s => !hidden.has(s));\n    v.data.sampleCount = v.data.filteredSamples.length;\n    Object.keys(v.data.hist.result).forEach(k => {\n        v.data.hist.result[k] = v.data.filteredSamples.map(x => [x, v.data.mainDict[k][x]]);\n    });\n    Object.keys(v.data.metaData).forEach(k => {\n        v.data.metaData[k] = v.data.filteredSamples.map(x => v.data.metaDict[x][k]);\n    });\n    v.data.mainHeatmap = v.data.mainHeatmap.map((_, i) => {\n        return v.data.filteredSamples.map(s =>\n            v.data.mainDict[v.data.species[i]][s]);\n    });\n}\n\nexport class GradientBar {\n    public colors: string[];\n    public stops: number[];\n    private getColor: any;\n    constructor(colors, stops) {\n        this.colors = colors;\n        this.stops = stops;\n        this.getColor = scaleLinear().range(colors).domain(stops);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}