{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { getBehavior } from \"../behavior\";\nimport { GeometryUnit, GeometryValue } from \"../defs/geometry\";\nimport { toCartesian } from \"../utils/math\";\nimport Type from \"../utils/type-check\";\nimport { defaultUIDGenerator } from \"../utils/uid\";\nimport { Component } from \"./component\"; // @ts-ignore\n\nimport shallowEqArrays from \"shallow-equal/arrays\"; // @ts-ignore\n\nimport shallowEqObjects from \"shallow-equal/objects\";\nimport { scaled } from \"./scale\";\nexport var BaseElement = /*#__PURE__*/function () {\n  function BaseElement() {\n    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    _classCallCheck(this, BaseElement);\n\n    this.isRoot = false;\n    this._isActive = true;\n    this._order = 0;\n    this._reordered = false;\n    this._isFocused = false;\n    this._firstRender = true;\n    this._isRenderRoot = false;\n    this.forceUpdate = false;\n    this._activeState = null;\n    this.isInXScaleSystem = false;\n    this.isInYScaleSystem = false;\n    this.$on = {};\n    this.$styles = {};\n    this.$behavior = {};\n    this.$stages = {};\n    this.$defaultProp = {};\n    this.$geometryProps = [[], []];\n    this.$detached = false;\n    this._stateListeners = {};\n    this._stateCallbacks = {};\n    this._boundMethods = new Map();\n    this._hasBufferedRedraw = false;\n    this._isReDrawing = false;\n    /* geometry */\n\n    this.positionDetached = false;\n    this.id = id;\n    this.uid = defaultUIDGenerator.gen();\n    this.$geometry = {\n      _xOffset: {},\n      _yOffset: {}\n    };\n    this._prop = {};\n    this.setupPropProxy();\n    this.init();\n\n    if (!this.state) {\n      this.state = {\n        stage: null\n      };\n    } else if (!(\"stage\" in this.state)) {\n      this.state.stage = null;\n    }\n  }\n\n  _createClass(BaseElement, [{\n    key: \"init\",\n    value: function init() {\n      /* empty */\n    }\n  }, {\n    key: \"__didCreate\",\n    value: function __didCreate() {\n      this.$defaultProp = this.defaultProp();\n\n      var _this$geometryProps = this.geometryProps(),\n          h = _this$geometryProps.h,\n          v = _this$geometryProps.v;\n\n      this.$geometryProps = [h, v];\n      this.$geometryPropsSet = new Set([].concat(_toConsumableArray(h), _toConsumableArray(v)));\n    }\n    /* properties */\n\n  }, {\n    key: \"defaultProp\",\n    value: function defaultProp() {\n      return {};\n    }\n  }, {\n    key: \"setupPropProxy\",\n    value: function setupPropProxy() {\n      var _this = this;\n\n      this.prop = new Proxy(this._prop, {\n        get: function get(target, p) {\n          var s;\n\n          if (p === \"opt\") {\n            return target[\"opt\"] || {};\n          }\n\n          if (_this._activeState && (s = _this.$stages[_this._activeState]) && p in s) {\n            return s[p];\n          }\n\n          if (p in target) {\n            return target[p];\n          }\n\n          return _this.$defaultProp[p];\n        },\n        set: function set(target, p, value) {\n          console.warn(\"this.prop is readonly.\");\n          return false;\n        }\n      });\n    }\n  }, {\n    key: \"setProp\",\n    value: function setProp(prop) {\n      var _this2 = this;\n\n      var propsWithMods = {};\n      Object.keys(prop).forEach(function (k) {\n        var value = prop[k];\n        if (typeof value === \"undefined\") return;\n\n        var _k$split = k.split(\".\"),\n            _k$split2 = _toArray(_k$split),\n            name = _k$split2[0],\n            mods = _k$split2.slice(1);\n\n        if (mods.length > 0) {\n          mods.forEach(function (m) {\n            if (!(m in propsWithMods)) propsWithMods[m] = {};\n            propsWithMods[m][name] = value;\n          });\n        }\n\n        _this2._prop[k] = value;\n      }); // modifier\n\n      Object.keys(propsWithMods).forEach(function (m) {\n        _this2._setPropsWithModifier(m, propsWithMods[m]);\n      });\n    }\n  }, {\n    key: \"_setPropsWithModifier\",\n    value: function _setPropsWithModifier(mod, props) {// wip\n    }\n  }, {\n    key: \"compareProps\",\n    value: function compareProps(p) {\n      var k1 = Object.keys(p); // , k2 = Object.keys(this._prop);\n      // if (!shallowEqArrays(k1, k2)) return false;\n\n      var k, p1, p2, t1, t2;\n\n      for (var _i = 0, _k = k1; _i < _k.length; _i++) {\n        k = _k[_i];\n        p1 = p[k];\n        p2 = this._prop[k];\n\n        if (this.$geometryPropsSet.has(k)) {\n          if (typeof p1 === \"number\" && typeof p2 === \"number\") {\n            if (p1 !== p2) return false;\n            continue;\n          }\n\n          return false;\n        }\n\n        if (k === \"opt\") {\n          var p1k = Object.keys(p1);\n          if (p1k.length !== Object.keys(p2).length) return false; // tslint:disable-next-line: no-for-in-array\n\n          for (var n in p1k) {\n            if (!shallowEqObjects(p1[n], p2[n])) return false;\n          }\n\n          continue;\n        }\n\n        t1 = _typeof(p1);\n        t2 = _typeof(p2);\n        if (t1 !== t2) return false;\n\n        switch (t1) {\n          case \"string\":\n          case \"number\":\n          case \"undefined\":\n          case \"boolean\":\n          case \"function\":\n          case \"bigint\":\n          case \"symbol\":\n            if (p1 !== p2) return false;\n            continue;\n\n          default:\n            if (Array.isArray(p1)) {\n              if (Array.isArray(p2) && shallowEqArrays(p1, p2)) {\n                continue;\n              }\n\n              return false;\n            }\n\n            if (!shallowEqObjects(p1, p2)) return false;\n            continue;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"parseInternalProps\",\n    value: function parseInternalProps() {\n      var _this3 = this;\n\n      Object.keys(this._prop).forEach(function (key) {\n        var value = _this3.prop[key];\n\n        if (typeof value === \"function\" && \"__internal__\" in value) {\n          _this3._prop[key] = value.call(_this3);\n        }\n      });\n      this.$detached = !!this.prop.detached;\n    }\n  }, {\n    key: \"setEventHandlers\",\n    value: function setEventHandlers(h) {\n      var _this4 = this;\n\n      Object.keys(h).forEach(function (k) {\n        var v = h[k];\n        _this4.$on[k] = _typeof(v) === \"object\" && v.handler ? _this4[v.handler] : v;\n      });\n    }\n  }, {\n    key: \"setStyles\",\n    value: function setStyles(s) {\n      this.$styles = s;\n    }\n  }, {\n    key: \"setBehaviors\",\n    value: function setBehaviors(s) {\n      var _this5 = this;\n\n      Object.keys(s).forEach(function (k) {\n        var behavior = getBehavior(k);\n\n        if (!behavior) {\n          throw new Error(\"Unknown behavior: \".concat(k));\n        }\n\n        var def = s[k];\n\n        if (_this5.$behavior[k]) {\n          _this5.$behavior[k].updateProps(def);\n        } else {\n          _this5.$behavior[k] = new behavior(_this5, def);\n        }\n      });\n    }\n  }, {\n    key: \"performTypeCheck\",\n    value: function performTypeCheck() {\n      var _this6 = this;\n\n      if (this.constructor.propTypes) {\n        Object.keys(this._prop).forEach(function (k) {\n          var t = _this6.constructor.propTypes[k];\n\n          if (t !== undefined) {\n            var _Type$check = Type.check(_this6._prop[k], t),\n                _Type$check2 = _slicedToArray(_Type$check, 2),\n                result = _Type$check2[0],\n                error = _Type$check2[1];\n\n            if (!result) {\n              console.error(\"Type checking failed for prop \\\"\".concat(k, \"\\\".\\n\").concat(Type.trace(error)));\n            }\n          }\n        });\n      }\n    }\n    /* event */\n\n  }, {\n    key: \"on\",\n    value: function on(event, handler) {\n      if (!this.$on[event]) this.$on[event] = [];\n      this.$on[event].push(handler);\n    }\n    /* state */\n\n  }, {\n    key: \"_findActiveStage\",\n    value: function _findActiveStage() {\n      if (this.stage) {\n        this._activeState = this.stage;\n        return;\n      }\n\n      var el = this.parent;\n\n      while (el && !el.render) {\n        if (el.stage) {\n          this._activeState = el.stage;\n          return;\n        }\n\n        el = el.parent;\n      }\n\n      this._activeState = null;\n    }\n  }, {\n    key: \"setState\",\n    value: function setState(s) {\n      var _this7 = this;\n\n      var changedKeys = [];\n      Object.keys(s).forEach(function (k) {\n        if (_this7.state[k] === s[k]) return;\n        _this7.state[k] = s[k];\n        changedKeys.push(k);\n      });\n      var callbackSymbols = changedKeys.flatMap(function (k) {\n        return _this7._stateListeners[k];\n      }).filter(Boolean);\n\n      var _iterator = _createForOfIteratorHelper(new Set(callbackSymbols)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var sym = _step.value;\n\n          this._stateCallbacks[sym].call(this, this.state, changedKeys);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var elm = null;\n\n      if (this instanceof Component) {\n        if (typeof this.render === \"function\") {\n          elm = this;\n        } else if (this.$parent) {\n          elm = this.$parent;\n        }\n      } else {\n        elm = this;\n      }\n\n      if (elm) {\n        elm.redraw();\n      }\n    }\n  }, {\n    key: \"watchState\",\n    value: function watchState(s, callback) {\n      var keys = Array.isArray(s) ? s : [s];\n      var cbKey = Symbol();\n      this._stateCallbacks[cbKey] = callback;\n\n      var _iterator2 = _createForOfIteratorHelper(keys),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var key = _step2.value;\n          if (!this._stateListeners[key]) this._stateListeners[key] = [];\n\n          this._stateListeners[key].push(cbKey);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"setStage\",\n    value: function setStage(s) {\n      this.setState({\n        stage: s\n      });\n    }\n  }, {\n    key: \"_bindMethod\",\n    value: function _bindMethod(m) {\n      var bound;\n      if (bound = this._boundMethods.get(m)) return bound;\n      bound = m.bind(this);\n\n      this._boundMethods.set(m, bound);\n\n      return bound;\n    }\n  }, {\n    key: \"_b\",\n    value: function _b(m) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return [this._bindMethod(m)].concat(args);\n    }\n    /* drawing */\n\n  }, {\n    key: \"renderTree\",\n    value: function renderTree() {\n      this._findActiveStage();\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      this._isRenderRoot = true;\n      this.renderTree();\n      this.$v.renderer.render(this, this.$v.rendererCtx);\n      this.$callHook(\"didPaint\");\n      this._isRenderRoot = false;\n    }\n  }, {\n    key: \"shouldDraw\",\n    value: function shouldDraw() {\n      if (this.$v._isInTransaction) {\n        this.$v._changedElements.add(this);\n\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"redraw\",\n    value: function redraw() {\n      if (!this.shouldDraw()) {\n        return;\n      }\n\n      if (this.$v.isCanavs) {\n        this._hasBufferedRedraw = true;\n\n        if (!this._isReDrawing) {\n          window.requestAnimationFrame(this._performRedraw.bind(this));\n        }\n      } else {\n        this.draw();\n      }\n    }\n  }, {\n    key: \"_performRedraw\",\n    value: function _performRedraw() {\n      this._hasBufferedRedraw = false;\n      this._isReDrawing = true;\n      if (this.shouldDraw()) this.draw();\n\n      if (!this._hasBufferedRedraw) {\n        this._isReDrawing = false;\n        return;\n      }\n\n      window.requestAnimationFrame(this._performRedraw.bind(this));\n    }\n  }, {\n    key: \"translatePoint\",\n    value: function translatePoint(x, y) {\n      if (this.inPolorCoordSystem) {\n        return toCartesian(x, y, this.$coord.$polar.rad);\n      }\n\n      return [x, y];\n    }\n    /* scale */\n\n  }, {\n    key: \"_scale\",\n    value: function _scale(val, horizontal) {\n      if (this.$parent) {\n        if (horizontal) this.$parent.isInXScaleSystem = true;else this.$parent.isInYScaleSystem = true;\n      }\n\n      if (horizontal) this.isInXScaleSystem = true;else this.isInYScaleSystem = true;\n      var scale = this.parent.getScale(horizontal);\n      return typeof scale === \"function\" ? scaled(scale, val) : val;\n    }\n  }, {\n    key: \"_rotate\",\n    value: function _rotate(val, x, y) {\n      return [val, typeof x === \"number\" ? x : \"_\", typeof y === \"number\" ? y : \"_\"];\n    }\n  }, {\n    key: \"_geo\",\n    value: function _geo(val, offset) {\n      return GeometryValue.create(val, GeometryUnit.Percent, offset);\n    }\n  }, {\n    key: \"geometryProps\",\n    value: function geometryProps() {\n      return {\n        h: [\"x\"],\n        v: [\"y\"]\n      };\n    }\n  }, {\n    key: \"$callHook\",\n\n    /* Hooks */\n    value: function $callHook(name) {\n      var hook;\n      if (hook = this[\"__\".concat(name)]) hook.call(this);\n      if (hook = this[name]) hook.call(this);\n    }\n  }, {\n    key: \"stage\",\n    get: function get() {\n      return this.state.stage;\n    },\n    set: function set(s) {\n      this.setState({\n        stage: s\n      });\n    }\n  }, {\n    key: \"inPolorCoordSystem\",\n    get: function get() {\n      return this.$coord && this.$coord.$polar;\n    }\n  }, {\n    key: \"maxX\",\n    get: function get() {\n      return this.$geometry.x;\n    }\n  }, {\n    key: \"maxY\",\n    get: function get() {\n      return this.$geometry.y;\n    }\n  }, {\n    key: \"layoutWidth\",\n    get: function get() {\n      return this.$geometry.width;\n    }\n  }, {\n    key: \"layoutHeight\",\n    get: function get() {\n      return this.$geometry.height;\n    }\n  }], [{\n    key: \"propNameForInitializer\",\n    value: function propNameForInitializer() {\n      return null;\n    }\n  }]);\n\n  return BaseElement;\n}();","map":null,"metadata":{},"sourceType":"module"}