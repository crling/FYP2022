{"ast":null,"code":"function _templateObject() {\n  var data = _taggedTemplateLiteral([\"_i(function() { return \", \" })\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport { oneLineTrim } from \"common-tags\";\nimport { PROP_NAME } from \"../tokens\";\nimport { transformHelper } from \"./helper\";\nexport function parseProp(p, node) {\n  var name = p.expect(PROP_NAME, \"prop name\")[0];\n  p.skipSpaces();\n  p.expect(\"=\");\n  p.skipSpaces();\n  parseExpr(node, name, consumeExpr(p));\n}\nexport function consumeExpr(p) {\n  var leftBracketCount = 0;\n  var leftBracketCount2 = 0;\n  var leftBracketCount3 = 0;\n  var expr = p.consume(function (ch) {\n    switch (ch) {\n      case \";\":\n        if (leftBracketCount > 0) p._error(\"Unbalanced brackets: \\\"}\\\" expected.\");\n        return [true, true];\n\n      case \"\\n\":\n        if (leftBracketCount > 0 || leftBracketCount2 > 0 || leftBracketCount3 > 0) return [false, false];\n        return [true, true];\n\n      case \"{\":\n        leftBracketCount++;\n        break;\n\n      case \"}\":\n        if (leftBracketCount > 0) {\n          leftBracketCount--;\n          break;\n        }\n\n        return [true, false];\n\n      case \"[\":\n        leftBracketCount2++;\n        break;\n\n      case \"]\":\n        leftBracketCount2--;\n        break;\n\n      case \"(\":\n        leftBracketCount3++;\n        break;\n\n      case \")\":\n        leftBracketCount3--;\n        break;\n    }\n\n    return [false, false];\n  }, \"property expression\");\n  return expr.replace(\"\\n\", \"\");\n}\nexport function parseExpr(node, name, expr) {\n  if (name.startsWith(\"on:\")) {\n    var eventName = name.slice(3);\n    node.on.push({\n      name: eventName,\n      handler: expr\n    });\n  } else if (name.startsWith(\"style:\")) {\n    var styleName = name.slice(6);\n    node.styles.push({\n      name: styleName,\n      expr: expr\n    });\n  } else {\n    if (expr.indexOf(\"@\") >= 0) {\n      expr = replacePropHelpers(expr);\n    }\n\n    if (name.indexOf(\".\") > 0) {\n      var _name$split = name.split(\".\"),\n          _name$split2 = _slicedToArray(_name$split, 2),\n          delegateName = _name$split2[0],\n          propName = _name$split2[1];\n\n      node.props.push({\n        delegate: delegateName,\n        name: propName,\n        expr: expr\n      });\n    } else if (name === \"key\") {\n      node.key = expr;\n    } else {\n      node.props.push({\n        name: name,\n        expr: expr\n      });\n\n      if (name === \"static\") {\n        node.staticVal = expr;\n      }\n    }\n  }\n}\n\nfunction replacePropHelpers(expr) {\n  var _replaceHelpers = replaceHelpers(expr),\n      _replaceHelpers2 = _slicedToArray(_replaceHelpers, 2),\n      replaced = _replaceHelpers2[0],\n      lazy = _replaceHelpers2[1];\n\n  return lazy ? oneLineTrim(_templateObject(), replaced) : replaced;\n}\n\nexport function replaceHelpers(expr) {\n  var lazy = false;\n  var replaced = expr.replace(/@([\\w\\d_\\-]*)\\(/g, function (str, name) {\n    var _transformHelper = transformHelper(name),\n        _transformHelper2 = _slicedToArray(_transformHelper, 2),\n        t = _transformHelper2[0],\n        lazy_ = _transformHelper2[1];\n\n    if (lazy_) lazy = true;\n    return t;\n  });\n  return [replaced, lazy];\n}","map":null,"metadata":{},"sourceType":"module"}