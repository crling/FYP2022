{"ast":null,"code":"function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport { ColorSchemeCategory, getThemeColor, getThemeScheme } from \"../color\";\nimport { GeometryUnit, GeometryValue } from \"../defs/geometry\";\nimport { max as _max, min as _min, minmax as _minmax, toDeg } from \"../utils/math\";\nvar ANCHOR = {\n  top: 2\n  /* Top */\n  ,\n  t: 2\n  /* Top */\n  ,\n  middle: 4\n  /* Middle */\n  ,\n  m: 4\n  /* Middle */\n  ,\n  bottom: 8\n  /* Bottom */\n  ,\n  b: 8\n  /* Bottom */\n  ,\n  left: 16\n  /* Left */\n  ,\n  l: 16\n  /* Left */\n  ,\n  center: 32\n  /* Center */\n  ,\n  c: 32\n  /* Center */\n  ,\n  right: 64\n  /* Right */\n  ,\n  r: 64\n  /* Right */\n\n};\nexport default {\n  geo: function geo(percentage) {\n    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return GeometryValue.create(percentage, GeometryUnit.Percent, offset);\n  },\n  clip: function clip(type) {\n    switch (type) {\n      case \"bound\":\n        var radius = arguments[1];\n        return {\n          type: \"bound\",\n          inset: 0,\n          rx: radius,\n          ry: radius\n        };\n\n      case \"polygon\":\n        return {\n          type: \"polygon\",\n          points: arguments[1]\n        };\n\n      default:\n        throw new Error(\"Unknown clip path type: \".concat(type));\n    }\n  },\n  anchor: function anchor(s1, s2) {\n    var a1 = ANCHOR[s1],\n        a2 = ANCHOR[s2];\n\n    if (!a1 || !a2) {\n      throw new Error(\"Unknown anchor (\".concat(s1, \", \").concat(s2, \")\"));\n    }\n\n    return a1 | a2;\n  },\n  rotate: function rotate(self, value) {\n    if (arguments.length >= 4) {\n      var x = arguments[2],\n          y = arguments[3],\n          unit = arguments[4];\n      if (unit === \"rad\") value = toDeg(value);\n      return self._rotate(value, x, y);\n    } else {\n      var _unit = arguments[2];\n      if (_unit === \"rad\") value = toDeg(value);\n      return self._rotate(value);\n    }\n  },\n  scaledX: function scaledX(self, value) {\n    if (Array.isArray(value)) {\n      return value.map(function (v) {\n        return self._scale(v, true);\n      });\n    } else {\n      return self._scale(value, true);\n    }\n  },\n  scaledY: function scaledY(self, value) {\n    if (Array.isArray(value)) {\n      return value.map(function (v) {\n        return self._scale(v, false);\n      });\n    } else {\n      return self._scale(value, false);\n    }\n  },\n  scaled: function scaled(self, value, direction) {\n    if (Array.isArray(value)) {\n      return value.map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            x = _ref2[0],\n            y = _ref2[1];\n\n        return [self._scale(x, true), self._scale(y, false)];\n      });\n    } else {\n      return self._scale(value, direction);\n    }\n  },\n  scaleLinear: function scaleLinear(d1, d2, r1, r2) {\n    var domain = d1 !== undefined && d2 !== undefined ? [d1, d2] : null;\n    var range = r1 !== undefined && r2 !== undefined ? [r1, r2] : null;\n    return {\n      __scale__: true,\n      type: \"linear\",\n      domain: domain,\n      range: range\n    };\n  },\n  scaleLog: function scaleLog(d1, d2, r1, r2) {\n    var domain = d1 !== undefined && d2 !== undefined ? [d1, d2] : null;\n    var range = r1 !== undefined && r2 !== undefined ? [r1, r2] : null;\n    return {\n      __scale__: true,\n      type: \"log\",\n      domain: domain,\n      range: range,\n      base: 10\n    };\n  },\n  scaleLog2: function scaleLog2(d1, d2, r1, r2) {\n    var domain = d1 !== undefined && d2 !== undefined ? [d1, d2] : null;\n    var range = r1 !== undefined && r2 !== undefined ? [r1, r2] : null;\n    return {\n      __scale__: true,\n      type: \"log\",\n      domain: domain,\n      range: range,\n      base: 2\n    };\n  },\n  scaleLogN: function scaleLogN(base, d1, d2, r1, r2) {\n    var domain = d1 !== undefined && d2 !== undefined ? [d1, d2] : null;\n    var range = r1 !== undefined && r2 !== undefined ? [r1, r2] : null;\n    return {\n      __scale__: true,\n      type: \"log\",\n      domain: domain,\n      range: range,\n      base: base\n    };\n  },\n  gradient: function gradient(self, name) {\n    if (arguments.length >= 4) {\n      var _arguments = Array.prototype.slice.call(arguments),\n          id = _arguments[1],\n          deg = _arguments[2],\n          stops = _arguments.slice(3);\n\n      self.$v.defineGradient(id, deg, stops);\n    }\n\n    return self.$v.renderer.getGradient(name, self.$v, self.$v.rendererCtx);\n  },\n  color: function color(self, name) {\n    if (typeof name === \"number\") {\n      return getThemeScheme(self.$v.theme, \"main\")[name];\n    }\n\n    return getThemeColor(self.$v.theme, name);\n  },\n  colorMap: function colorMap(self, k) {\n    var scheme = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"main\";\n    var colors = typeof scheme === \"string\" ? getThemeScheme(self.$v.theme, scheme) : scheme;\n    return ColorSchemeCategory.create(k, colors);\n  },\n  themeColor: function themeColor(theme) {\n    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"theme\";\n\n    if (typeof name === \"number\") {\n      return getThemeScheme(theme, \"main\")[name];\n    }\n\n    return getThemeColor(theme, name);\n  },\n  themeColorScheme: function themeColorScheme(theme, k) {\n    var scheme = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"main\";\n    var colors = getThemeScheme(theme, scheme);\n    return ColorSchemeCategory.create(k, colors);\n  },\n  min: function min(data, iter) {\n    return _min(data, iter);\n  },\n  max: function max(data, iter) {\n    return _max(data, iter);\n  },\n  minmax: function minmax(data, iter) {\n    return _minmax(data, iter);\n  },\n  ANCHOR: ANCHOR\n};","map":null,"metadata":{},"sourceType":"module"}