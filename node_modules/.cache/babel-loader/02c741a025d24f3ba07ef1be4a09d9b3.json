{"ast":null,"code":"function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { GeometryValue } from \"../defs/geometry\";\nimport { registerDefaultGlobalComponents } from \"../element/global\";\nimport { addRenderer, renderers } from \"../rendering/renderer\";\nimport { compile } from \"../template/compiler\";\nimport { RootComponent } from \"./root\";\nimport canvasRenderer from \"../rendering/canvas/canvas\";\nimport svgOfflineRenderer from \"../rendering/svg-offline/svg-offline\";\nimport svgRenderer from \"../rendering/svg/svg\";\nimport IS_NODE from \"../utils/is-node\";\naddRenderer(\"canvas\", canvasRenderer);\naddRenderer(\"svg\", svgRenderer);\naddRenderer(\"svg-offline\", svgOfflineRenderer);\n\nvar Visualizer =\n/** @class */\nfunction () {\n  var Visualizer = /*#__PURE__*/function () {\n    function Visualizer(opt) {\n      var _this = this;\n\n      _classCallCheck(this, Visualizer);\n\n      this._focusedElements = new Set();\n      this._currentCursor = null;\n      this.forceRedraw = false;\n      this._isInTransaction = false;\n      this._queuedTransactions = [];\n      this._changedElements = new Set();\n      this.firstRun = true;\n      this.uid = Visualizer.uidCounter++;\n      this._registeredEvents = new Set();\n\n      if (!IS_NODE) {\n        var el = getOpt(opt, \"el\");\n        var c = typeof el === \"string\" ? document.querySelector(el) : el instanceof HTMLElement ? el : null;\n\n        if (c === null) {\n          throw new Error(\"Cannot find the container element.\");\n        } else {\n          this.container = c;\n        }\n\n        this.container.innerHTML = \"\";\n      }\n\n      this._data = opt.data || {};\n\n      this._createDataProxy();\n\n      this.components = opt.components || {};\n      this.rendererType = opt.renderer || \"svg\";\n      this.rendererOpt = opt.rendererOption || {};\n      this.theme = opt.theme || \"light\";\n      var size;\n\n      if (opt.template) {\n        if (typeof opt.template !== \"string\") {\n          throw Error(\"Option \\\"template\\\" should be a string.\");\n        }\n\n        var _compile = compile(getOpt(opt, \"template\"), getOpt(opt, \"singleTemplate\", false)),\n            _renderer = _compile.renderer,\n            metadata = _compile.metadata,\n            commands = _compile.commands;\n\n        this.extCommands = commands;\n\n        if (!metadata) {\n          throw new Error(\"The template must be wrapped with an svg or canvas block.\");\n        }\n\n        if (!this.rendererType) {\n          this.rendererType = metadata.renderer;\n        }\n\n        size = {\n          width: this._parseSize(metadata.width || \"auto\", true),\n          height: this._parseSize(metadata.height || \"auto\", false)\n        };\n        var root = new RootComponent(0, _renderer);\n        root.setProp(Object.assign(Object.assign({}, getOpt(opt, \"props\", {})), {\n          width: GeometryValue.fullSize,\n          height: GeometryValue.fullSize\n        }));\n        if (this._data) Object.keys(this._data).forEach(function (k) {\n          return root[k] = _this._data[k];\n        });\n        this.setRootElement(root);\n      } else if (opt.root) {\n        opt.root.setProp(getOpt(opt, \"props\", {}));\n        this.setRootElement(opt.root);\n        size = {\n          width: this._parseSize(getOpt(opt, \"width\", \"auto\").toString(), true),\n          height: this._parseSize(getOpt(opt, \"height\", \"auto\").toString(), false)\n        };\n      } else {\n        throw new Error(\"Visualizer: Either \\\"template\\\" or \\\"root\\\" must be supplied.\");\n      }\n\n      this.size = new Proxy(size, {\n        set: function set(obj, prop, value) {\n          if (typeof value === \"string\") {\n            value = _this._parseSize(value, prop === \"width\");\n          }\n\n          obj[prop] = value;\n\n          _this._updateSize();\n\n          return true;\n        }\n      });\n      var renderer = renderers[this.rendererType];\n\n      if (!renderer) {\n        throw new Error(\"Unknown renderer \\\"\".concat(this.rendererType, \"\\\"!\"));\n      }\n\n      this.renderer = renderer;\n      this.rendererCtx = {};\n      this.renderer.init(this, this.rendererCtx);\n    }\n\n    _createClass(Visualizer, [{\n      key: \"_createDataProxy\",\n      value: function _createDataProxy() {\n        var _this2 = this;\n\n        this._dataProxy = new Proxy(this._data, {\n          get: function get(target, p) {\n            return target[p];\n          },\n          set: function set(target, p, val) {\n            target[p] = val;\n            _this2.root[p] = val;\n            return true;\n          }\n        });\n      }\n    }, {\n      key: \"setRootElement\",\n      value: function setRootElement(el) {\n        this.root = el;\n        this.root.isRoot = true;\n        this.root.$v = this;\n        this.root.$callHook(\"didCreate\");\n      }\n    }, {\n      key: \"run\",\n      value: function run() {\n        this.root.draw();\n        this.firstRun = false;\n        this.forceRedraw = false;\n      }\n    }, {\n      key: \"transaction\",\n      value: function transaction(callback) {\n        if (this._isInTransaction) {\n          this._queuedTransactions.push(callback);\n\n          return;\n        }\n\n        this._isInTransaction = true;\n\n        this._queuedTransactions.push(callback);\n\n        var task;\n\n        while (task = this._queuedTransactions.shift()) {\n          task.call(null);\n        }\n\n        this._isInTransaction = false;\n        /*\n        // check changed elements\n        const toRemove: BaseElement[] = [];\n        let p: BaseElement;\n        for (const el of this._changedElements.values()) {\n            p = el;\n            while (p) {\n                if (p !== el && this._changedElements.has(p)) {\n                    toRemove.push(el);\n                    break;\n                }\n                p = p.parent;\n            }\n        }\n        toRemove.forEach(e => this._changedElements.delete(e));\n        */\n        // redraw\n\n        if (this.isCanavs) {\n          if (this._changedElements.size > 0) {\n            var _iterator = _createForOfIteratorHelper(this._changedElements.values()),\n                _step;\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var el = _step.value;\n                el.renderTree();\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n\n            this.root.redraw();\n          }\n        } else {\n          var _iterator2 = _createForOfIteratorHelper(this._changedElements.values()),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _el = _step2.value;\n\n              _el.redraw();\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n\n        this._changedElements.clear();\n      }\n    }, {\n      key: \"defineGradient\",\n      value: function defineGradient(id) {\n        var def;\n\n        if (arguments.length === 2) {\n          def = arguments[1];\n        } else {\n          def = {\n            x1: 0,\n            x2: 0,\n            y1: 0,\n            y2: 0,\n            stops: []\n          };\n          var direction = arguments[1];\n          var stops = arguments[2];\n\n          if (direction === \"horizontal\") {\n            def.x2 = 100;\n          } else if (direction === \"vertical\") {\n            def.y2 = 100;\n          } else if (typeof direction === \"number\") {\n            var deg = direction;\n            if (deg < 0) deg += 360;\n            var values = {\n              \"0\": [0, 0, 100, 0],\n              \"45\": [0, 0, 100, 100],\n              \"90\": [0, 0, 0, 100],\n              \"135\": [100, 0, 0, 100]\n            }[deg >= 180 ? deg - 180 : deg];\n            if (!values) throw new Error(\"defineGradient: direction should be a multiple of 45deg\");\n\n            if (deg < 180) {\n              var _values = _slicedToArray(values, 4);\n\n              def.x1 = _values[0];\n              def.y1 = _values[1];\n              def.x2 = _values[2];\n              def.y2 = _values[3];\n            } else {\n              var _values2 = _slicedToArray(values, 4);\n\n              def.x2 = _values2[0];\n              def.y2 = _values2[1];\n              def.x1 = _values2[2];\n              def.y1 = _values2[3];\n            }\n          } else {\n            throw new Error(\"defineGradient: direction should be a number or \\\"horizontal\\\" or \\\"vertical\\\"\");\n          }\n\n          def.stops = stops.map(function (s, i) {\n            return {\n              offset: i * 100,\n              color: s,\n              opacity: 1\n            };\n          });\n        }\n\n        this.renderer.defineGradient(id, def, this, this.rendererCtx);\n      }\n    }, {\n      key: \"_parseSize\",\n      value: function _parseSize(size, isWidth) {\n        if (size === \"auto\") {\n          if (IS_NODE) {\n            return 800;\n          }\n\n          var computedStyle = getComputedStyle(this.container);\n          return isWidth ? this.container.clientWidth - parseFloat(computedStyle.paddingTop) - parseFloat(computedStyle.paddingBottom) : this.container.clientHeight - parseFloat(computedStyle.paddingLeft) - parseFloat(computedStyle.paddingRight);\n        } else {\n          return parseFloat(size);\n        }\n      }\n    }, {\n      key: \"_updateSize\",\n      value: function _updateSize() {\n        this.renderer.setSize(this, this.rendererCtx);\n      }\n    }, {\n      key: \"data\",\n      get: function get() {\n        return this._dataProxy;\n      },\n      set: function set(d) {\n        var _this3 = this;\n\n        this._data = d;\n        Object.keys(this._data).forEach(function (k) {\n          return _this3.root[k] = _this3._data[k];\n        });\n\n        this._createDataProxy();\n\n        if (!this.firstRun) this.run();\n      }\n    }, {\n      key: \"isCanavs\",\n      get: function get() {\n        return this.rendererType === \"canvas\";\n      }\n    }, {\n      key: \"isSVG\",\n      get: function get() {\n        return this.rendererType === \"svg\";\n      }\n    }]);\n\n    return Visualizer;\n  }();\n\n  Visualizer.uidCounter = 0;\n  return Visualizer;\n}();\n\nexport { Visualizer };\n\nfunction getOpt(opt, key, defaultValue) {\n  if (key in opt) {\n    return opt[key];\n  } else {\n    if (typeof defaultValue !== \"undefined\") {\n      return defaultValue;\n    }\n\n    throw new Error(\"Key \\\"\".concat(key, \"\\\" must present in visualizer options.\"));\n  }\n}\n\nregisterDefaultGlobalComponents();","map":null,"metadata":{},"sourceType":"module"}