{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"Component {\\n            x = prop.x\\n            y = prop.y\\n            width = prop.width\\n            height = calculatedHeight\\n            xScale = geneScale\\n            clip = @clip(\\\"bound\\\")\\n\\n            @for (genes, layer) in layers {\\n                @for (gene, index) in genes {\\n                    @let geneName = prop.labelText(gene)\\n                    Component {\\n                        context = gene\\n                        ref    = \\\"genes[]\\\"\\n                        key    = gene.trans_name_orig\\n                        x      = gene._x0\\n                        y      = layer * (prop.exonHeight + prop.rowGap) + prop.rowGap * 0.5\\n                        width  = Math.max(gene._x1 - gene._x0, 1)\\n                        height = prop.rowHeight\\n                        stage  = isGeneActive(gene) ? \\\"active\\\": null\\n                        on:mouseenter = (_, el) => setFocusedGene(el.prop.context.trans_name)\\n                        on:mouseleave = setFocusedGene(null)\\n                        @props prop.opt.gene\\n\\n                        @if prop.displayPromoters {\\n                            Rect {\\n                            }\\n                        }\\n                        Rect {\\n                            width  = 100%\\n                            height = 100%\\n                            fill   = \\\"none\\\"\\n                            @props prop.opt.bg\\n                        }\\n                        Rect {\\n                            anchor = @anchor(\\\"left\\\", \\\"middle\\\")\\n                            y      = 50%\\n                            width  = 100%\\n                            height = prop.intronHeight\\n                            fill   = prop.geneColor(gene)\\n                            @props prop.opt.intron\\n                            behavior:tooltip {\\n                                content = gene.trans_name_orig + \\\"<br>\\\" + gene.most_left_pos + \\\"-\\\" + gene.most_right_pos\\n                            }\\n                        }\\n                        @if prop.displayExon {\\n                            @for (exon, index) in gene.exons {\\n                                @let el = exon.most_left_pos\\n                                @let er = exon.most_left_pos + exon.length\\n                                Rect {\\n                                    key      = \\\"ex\\\" + index\\n                                    x        = @scaledX(el) - gene._x0\\n                                    width    = Math.max(@scaledX(er) - @scaledX(el), 1)\\n                                    height   = 100%\\n                                    minWidth = 1\\n                                    fill     = prop.geneColor(gene)\\n                                    @props prop.opt.exon\\n                                    behavior:tooltip {\\n                                        content = \\\"Exon \\\" + getExonIndex(gene, index) + \\\": \\\" + el + \\\"-\\\" + er\\n                                    }\\n                                }\\n                            }\\n                        }\\n                        @if prop.displayDirection {\\n                            Path {\\n                                y = 50%\\n                                d = genMarker(gene)\\n                                markerMid = \\\"url(#genearea-marker)\\\"\\n                                fill = \\\"none\\\"\\n                                stroke = \\\"none\\\"\\n                                events = \\\"none\\\"\\n                            }\\n                        }\\n                        Text {\\n                            text = geneName\\n                            visible = gene._x0 < $geometry.width\\n                            y = 50%\\n                            anchor = @anchor(\\\"left\\\", \\\"middle\\\")\\n                            fontSize = prop.labelSize\\n                            @props getGeneLabelProps(gene)\\n                            @props prop.opt.label\\n                        }\\n                    }\\n                }\\n            }\\n        }\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport { stackedLayout } from \"../../algo\";\nimport { getThemeColor } from \"../../color\";\nimport { GeometryUnit, GeometryValue } from \"../../defs/geometry\";\nimport { max, min } from \"../../utils/math\";\nimport { measuredTextSize } from \"../../utils/text-size\";\nimport { Component } from \"../component\";\nexport var GeneArea = /*#__PURE__*/function (_Component) {\n  _inherits(GeneArea, _Component);\n\n  var _super = _createSuper(GeneArea);\n\n  function GeneArea() {\n    var _this;\n\n    _classCallCheck(this, GeneArea);\n\n    _this = _super.apply(this, arguments);\n    _this.state = {\n      stage: null,\n      focusedGene: null\n    };\n    return _this;\n  }\n\n  _createClass(GeneArea, [{\n    key: \"render\",\n    value: function render() {\n      return this.t(_templateObject());\n    }\n  }, {\n    key: \"defaultProp\",\n    value: function defaultProp() {\n      return Object.assign(Object.assign({}, _get(_getPrototypeOf(GeneArea.prototype), \"defaultProp\", this).call(this)), {\n        rowHeight: 20,\n        exonHeight: 20,\n        intronHeight: 4,\n        rowGap: 4,\n        activeGenes: [],\n        geneColor: function geneColor(gene) {\n          return gene.color || \"#66f\";\n        },\n        layout: \"packed\",\n        labelPos: \"innerLeft\",\n        labelText: function labelText(gene) {\n          return gene.trans_name_orig;\n        },\n        labelSize: 12\n      });\n    }\n  }, {\n    key: \"willRender\",\n    value: function willRender() {\n      var parentScale = this.getScale(true);\n      this.geneScale = parentScale ? undefined : this._createScale(\"linear\", true, [this.geneMinPos, this.geneMaxPos]);\n      var scale = parentScale || this.geneScale;\n      this.prop.genes.forEach(function (g) {\n        g._x0 = scale(g.most_left_pos);\n        g._x1 = scale(g.most_right_pos);\n      });\n      this.layers = this.layout();\n\n      if (this.prop.displayDirection) {\n        var markerColor = this.prop.markerColor || getThemeColor(this.$v.theme, \"line\");\n        this.$v.rendererCtx.appendDef(\"genearea-marker\", \"marker\", {\n          orient: \"auto\",\n          markerWidth: \"4\",\n          markerHeight: \"6\",\n          refX: \"1.5\",\n          refY: \"2.5\"\n        }, \"<path d=\\\"M0,0 L3,2.5 L0,5\\\" fill=\\\"none\\\" stroke-opacity=\\\"1\\\" stroke=\\\"\".concat(markerColor, \"\\\"></path>\"));\n      }\n    }\n  }, {\n    key: \"didLayoutSubTree\",\n    value: function didLayoutSubTree() {\n      this._updateGeometry(\"height\", this.calculatedHeight);\n    }\n  }, {\n    key: \"layout\",\n    value: function layout() {\n      var _this2 = this;\n\n      this.prop.genes.forEach(function (g) {\n        g._labelWidth = measuredTextSize(_this2.prop.labelText(g), _this2.prop.labelSize).width + 2;\n      });\n\n      if (this.prop.layout === \"packed\") {\n        return stackedLayout(this.prop.genes).value(function (x) {\n          return x._x0;\n        }).extent(function (x) {\n          return [x._x0, _this2.prop.labelPos === \"right\" ? x._x1 + x._labelWidth : x._x1];\n        }).run();\n      } else if (this.prop.layout === \"merged\") {\n        return [this.prop.genes];\n      }\n\n      return [];\n    }\n  }, {\n    key: \"getExonIndex\",\n    // @ts-ignore\n    value: function getExonIndex(gene, index) {\n      return gene.strand === \"-\" ? gene.exon_number - index : index + 1;\n    } // @ts-ignore\n\n  }, {\n    key: \"getGeneLabelProps\",\n    value: function getGeneLabelProps(gene) {\n      switch (this.prop.labelPos) {\n        case \"innerLeft\":\n          return {\n            x: gene._x0 < 0 ? -gene._x0 : 0\n          };\n\n        case \"right\":\n          var width = this.$geometry.width;\n\n          if (gene._x1 + gene._labelWidth > width) {\n            return {\n              x: width - gene._x0 - 1,\n              y: GeometryValue.create(50, GeometryUnit.Percent, 2),\n              anchor: 64\n              /* Right */\n              | 2\n              /* Top */\n\n            };\n          }\n\n          return {\n            x: gene._x1 - gene._x0 + 2\n          };\n      }\n    } // @ts-ignore\n\n  }, {\n    key: \"isGeneActive\",\n    value: function isGeneActive(gene) {\n      return this.state.focusedGene === gene.trans_name || this.prop.activeGenes.indexOf(gene.trans_name) >= 0;\n    } // @ts-ignore\n\n  }, {\n    key: \"setFocusedGene\",\n    value: function setFocusedGene(gene) {\n      this.setState({\n        focusedGene: gene\n      });\n    }\n  }, {\n    key: \"getGenes\",\n    value: function getGenes(position) {\n      return this.$ref.genes.filter(function (g) {\n        return g.prop.context.most_left_pos <= position && g.prop.context.most_right_pos >= position;\n      });\n    } // @ts-ignore\n\n  }, {\n    key: \"genMarker\",\n    value: function genMarker(gene) {\n      var width = gene._x1 - gene._x0;\n      var num = Math.floor(width / 16);\n\n      if (num < 2) {\n        var mid = width / 2;\n        if (gene.strand === \"-\") return \"M\".concat(width, \",0 L\").concat(mid, \",0 L0,0\");else return \"M0,0 L\".concat(mid, \",0 L\").concat(width, \",0\");\n      }\n\n      var str;\n\n      if (gene.strand === \"-\") {\n        str = \"M\".concat(width, \",0\");\n\n        for (var i = num - 1; i > 0; i--) {\n          str += \" L\".concat(i * 16, \",0\");\n        }\n\n        str += \"L0,0\";\n      } else {\n        str = \"M0,0\";\n\n        for (var _i = 1; _i < num; _i++) {\n          str += \" L\".concat(_i * 16, \",0\");\n        }\n\n        str += \"L\".concat(width, \",0\");\n      }\n\n      return str;\n    }\n  }, {\n    key: \"geneMinPos\",\n    get: function get() {\n      if (this.prop.genes.length === 0) return 0;\n      return min(this.prop.genes, function (g) {\n        return g.most_left_pos;\n      });\n    }\n  }, {\n    key: \"geneMaxPos\",\n    get: function get() {\n      if (this.prop.genes.length === 0) return 0;\n      return max(this.prop.genes, function (g) {\n        return g.most_right_pos;\n      });\n    }\n  }, {\n    key: \"calculatedHeight\",\n    get: function get() {\n      return this.layers.length * (this.prop.exonHeight + this.prop.rowGap) + this.prop.rowGap;\n    }\n  }]);\n\n  return GeneArea;\n}(Component);","map":null,"metadata":{},"sourceType":"module"}