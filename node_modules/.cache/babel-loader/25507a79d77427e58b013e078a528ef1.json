{"ast":null,"code":"function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport Oviz from \"crux\";\nimport template from \"./template.bvt\";\nimport { register } from \"page/visualizers\";\nimport { findBoundsForValues, computeLog } from \"utils/maths\";\nimport { registerEditorConfig } from \"utils/editor\";\nimport { editorConfig } from \"./editor\";\nimport { groupedChartColors } from \"oviz-common/palette\";\nimport { rankDict } from \"utils/bio-info\";\nvar plotWidth = 500;\nvar ylabel = \"Relative abundance -log10\";\nvar classifiedIndex = 1;\nvar valueRange = [-8, 2];\nvar title = \"grouped box plot\"; // please change the displayed value range in the template by the prop: valueRange.\n\nvar MODULE_NAME = \"grouped-boxplot-p\";\n\nfunction init() {\n  if (!window.gon || window.gon.module_name !== MODULE_NAME) return;\n\n  var _Oviz$visualize = Oviz.visualize({\n    el: \"#canvas\",\n    template: template,\n    data: {\n      ylabel: ylabel,\n      title: title,\n      config: {\n        plotWidth: 500,\n        showOutliers: true,\n        xLabelRotation: 45,\n        rankIndex: 0\n      },\n      pValueRange: [0, 0.1],\n      colors: groupedChartColors\n    },\n    loadData: {\n      boxplotDataGroupedP: {\n        fileKey: \"boxplotDataGroupedP\",\n        type: \"tsv\",\n        dsvHasHeader: true,\n        multiple: true,\n        loaded: function loaded(d) {\n          var _this = this;\n\n          // rank sorting\n          var rankKeys = Object.keys(rankDict);\n          this.data.ranks = d.map(function (x) {\n            return x.columns[1];\n          }).sort(function (a, b) {\n            return rankKeys.indexOf(a) - rankKeys.indexOf(b);\n          }).map(function (x, i) {\n            return {\n              value: i,\n              text: rankDict[x]\n            };\n          });\n          this.data.boxDict = {};\n          this.data.pDict = {};\n          var chosenRank = this.data.ranks[0].text;\n          this.data.speciesDict = {};\n          d.forEach(function (data) {\n            var rankLabel = rankDict[data.columns[1]]; // only shows the species level\n\n            var shortSpecies = [];\n            _this.data.speciesDict[rankLabel] = {};\n\n            for (var i = 2; i < data.columns.length; i++) {\n              var splittedSpecies = data.columns[i].split(\"|\");\n              shortSpecies.push([splittedSpecies[splittedSpecies.length - 1], data.columns[i]]);\n              _this.data.speciesDict[rankLabel][splittedSpecies[splittedSpecies.length - 1]] = data.columns[i];\n            }\n\n            var columns = [data.columns[0], data.columns[1]].concat(_toConsumableArray(shortSpecies.map(function (s) {\n              return s[0];\n            })));\n            data = data.map(function (x) {\n              var parsedX = {};\n              parsedX[columns[0]] = x[columns[0]];\n              parsedX[columns[1]] = x[columns[1]];\n              shortSpecies.forEach(function (s) {\n                parsedX[s[0]] = x[s[1]];\n              });\n              return parsedX;\n            });\n            var pData = data.filter(function (x) {\n              return x[columns[0]] === \"p-value\";\n            })[0];\n            data = data.filter(function (x) {\n              return x[columns[0]] !== \"p-value\";\n            });\n            var categories = columns.slice(2);\n            if (categories.length > 50) categories.splice(50, categories.length - 50);\n            var classifiedKey = columns[classifiedIndex];\n            var classifications = data.map(function (d) {\n              return d[classifiedKey];\n            }).filter(function (item, index, self) {\n              return self.indexOf(item) === index;\n            });\n            var boxData = [{\n              values: [],\n              outliers: [],\n              means: [],\n              categories: categories\n            }, {\n              values: [],\n              outliers: [],\n              means: [],\n              categories: categories\n            }];\n            var allValues = [];\n            categories.forEach(function (arr, i) {\n              var initialData = [[], []];\n              data.forEach(function (d) {\n                var x = parseFloat(d[arr]);\n                if (x === 0) x = -5;else x = computeLog(x, 10);\n                allValues.push(x);\n\n                if (d[classifiedKey] === classifications[0]) {\n                  initialData[0].push(x);\n                } else {\n                  initialData[1].push(x);\n                }\n              });\n              classifications.forEach(function (_, j) {\n                var result = [];\n                var stat1 = new Oviz.algo.Statistics(initialData[j]);\n                var interQuartileRange = stat1.Q3() - stat1.Q1();\n                initialData[j].forEach(function (d) {\n                  if (d < stat1.Q3() - 1.5 * interQuartileRange || d > stat1.Q3() + 1.5 * interQuartileRange) {\n                    boxData[j].outliers.push([i, d]);\n                  } else {\n                    result.push(d);\n                  }\n                });\n                var stat2 = new Oviz.algo.Statistics(result);\n                boxData[j].values.push([stat2.min(), stat2.Q1(), stat2.median(), stat2.Q3(), stat2.max()]);\n                boxData[j].means.push(stat2.mean());\n              });\n            });\n            var valueRange = findBoundsForValues(allValues, 2, false, 0.1);\n            _this.data.pDict[rankLabel] = {\n              pData: categories.map(function (c) {\n                return parseFloat(pData[c]);\n              }),\n              categories: categories\n            };\n            _this.data.boxDict[rankLabel] = {\n              boxData: boxData,\n              valueRange: valueRange,\n              categories: categories,\n              classifications: classifications\n            };\n\n            if (chosenRank === rankLabel) {\n              _this.data.boxData = {\n                boxData: boxData,\n                valueRange: valueRange,\n                categories: categories,\n                classifications: classifications\n              };\n              _this.data.pData = _this.data.pDict[rankLabel];\n            }\n          });\n          return null;\n        }\n      }\n    },\n    setup: function setup() {\n      console.log(this[\"_data\"]);\n\n      if (this.data.boxData.categories.length * 20 > 500) {\n        this.data.config.plotWidth = this.data.boxData.categories.length * 20;\n        this.data.gridW = 20;\n      } else {\n        this.data.gridW = 500 / this.data.boxData.categories.length;\n      } // const minBoxW = 12;\n      // const mulNum = this.data.boxData.classifications.length;\n      // const gridW = ((minBoxW + 2) * mulNum - 2) / 0.7;\n      // if (this.data.boxData.categories.length * gridW > plotWidth) {\n      //     this.data.config.plotWidth = this.data.boxData.categories.length * gridW;\n      //     this.data.gridW = gridW;\n      //     this.data.boxW = minBoxW;\n      // } else {\n      //     const boxGap = this.data.boxGap = 4;\n      //     this.data.gridW = plotWidth / this.data.boxData.categories.length;\n      //     this.data.boxW = (this.data.gridW * 0.7 - boxGap * (mulNum - 1)) / mulNum;\n      // }\n\n\n      registerEditorConfig(editorConfig(this));\n    }\n  }),\n      visualizer = _Oviz$visualize.visualizer;\n\n  return visualizer;\n}\n\nregister(MODULE_NAME, init);\nexport function registerGroupedBoxP() {\n  register(MODULE_NAME, init);\n}","map":{"version":3,"sources":["/Users/wangzhenyu/Desktop/fyp_workspace/meta_platform/app/javascript/viz/grouped-boxplot-p/index.ts"],"names":["Oviz","template","register","findBoundsForValues","computeLog","registerEditorConfig","editorConfig","groupedChartColors","rankDict","plotWidth","ylabel","classifiedIndex","valueRange","title","MODULE_NAME","init","window","gon","module_name","visualize","el","data","config","showOutliers","xLabelRotation","rankIndex","pValueRange","colors","loadData","boxplotDataGroupedP","fileKey","type","dsvHasHeader","multiple","loaded","d","rankKeys","Object","keys","ranks","map","x","columns","sort","a","b","indexOf","i","value","text","boxDict","pDict","chosenRank","speciesDict","forEach","rankLabel","shortSpecies","length","splittedSpecies","split","push","s","parsedX","pData","filter","categories","slice","splice","classifiedKey","classifications","item","index","self","boxData","values","outliers","means","allValues","arr","initialData","parseFloat","_","j","result","stat1","algo","Statistics","interQuartileRange","Q3","Q1","stat2","min","median","max","mean","c","setup","console","log","gridW","visualizer","registerGroupedBoxP"],"mappings":";;;;;;;;;;;;AAAA,OAAOA,IAAP,MAAiB,MAAjB;AACA,OAAOC,QAAP,MAAqB,gBAArB;AACA,SAAQC,QAAR,QAAuB,kBAAvB;AAEA,SAASC,mBAAT,EAA8BC,UAA9B,QAAgD,aAAhD;AACA,SAASC,oBAAT,QAAqC,cAArC;AACA,SAASC,YAAT,QAA6B,UAA7B;AACA,SAASC,kBAAT,QAAkC,qBAAlC;AACA,SAAQC,QAAR,QAAuB,gBAAvB;AAEA,IAAMC,SAAS,GAAG,GAAlB;AACA,IAAMC,MAAM,GAAG,2BAAf;AACA,IAAMC,eAAe,GAAG,CAAxB;AACA,IAAMC,UAAU,GAAG,CAAC,CAAC,CAAF,EAAK,CAAL,CAAnB;AACA,IAAMC,KAAK,GAAG,kBAAd,C,CACA;;AACA,IAAMC,WAAW,GAAG,mBAApB;;AAEA,SAASC,IAAT,GAAgB;AACZ,MAAI,CAACC,MAAM,CAACC,GAAR,IAAeD,MAAM,CAACC,GAAP,CAAWC,WAAX,KAA2BJ,WAA9C,EAA2D;;AAD/C,wBAGSd,IAAI,CAACmB,SAAL,CAAe;AAChCC,IAAAA,EAAE,EAAE,SAD4B;AAEhCnB,IAAAA,QAAQ,EAARA,QAFgC;AAGhCoB,IAAAA,IAAI,EAAE;AAACX,MAAAA,MAAM,EAANA,MAAD;AAASG,MAAAA,KAAK,EAALA,KAAT;AACFS,MAAAA,MAAM,EAAE;AACJb,QAAAA,SAAS,EAAE,GADP;AAEJc,QAAAA,YAAY,EAAE,IAFV;AAGJC,QAAAA,cAAc,EAAE,EAHZ;AAIJC,QAAAA,SAAS,EAAE;AAJP,OADN;AAOFC,MAAAA,WAAW,EAAE,CAAC,CAAD,EAAI,GAAJ,CAPX;AAQFC,MAAAA,MAAM,EAAEpB;AARN,KAH0B;AAahCqB,IAAAA,QAAQ,EAAE;AACNC,MAAAA,mBAAmB,EAAE;AACjBC,QAAAA,OAAO,EAAE,qBADQ;AAEjBC,QAAAA,IAAI,EAAE,KAFW;AAGjBC,QAAAA,YAAY,EAAE,IAHG;AAIjBC,QAAAA,QAAQ,EAAE,IAJO;AAKjBC,QAAAA,MALiB,kBAKVC,CALU,EAKP;AAAA;;AACN;AACA,cAAMC,QAAQ,GAAGC,MAAM,CAACC,IAAP,CAAY9B,QAAZ,CAAjB;AACA,eAAKa,IAAL,CAAUkB,KAAV,GAAkBJ,CAAC,CAACK,GAAF,CAAM,UAAAC,CAAC;AAAA,mBAAIA,CAAC,CAACC,OAAF,CAAU,CAAV,CAAJ;AAAA,WAAP,EACDC,IADC,CACI,UAACC,CAAD,EAAIC,CAAJ;AAAA,mBAAUT,QAAQ,CAACU,OAAT,CAAiBF,CAAjB,IAAsBR,QAAQ,CAACU,OAAT,CAAiBD,CAAjB,CAAhC;AAAA,WADJ,EAEDL,GAFC,CAEG,UAACC,CAAD,EAAIM,CAAJ;AAAA,mBAAY;AAACC,cAAAA,KAAK,EAAED,CAAR;AAAWE,cAAAA,IAAI,EAAEzC,QAAQ,CAACiC,CAAD;AAAzB,aAAZ;AAAA,WAFH,CAAlB;AAGA,eAAKpB,IAAL,CAAU6B,OAAV,GAAoB,EAApB;AACA,eAAK7B,IAAL,CAAU8B,KAAV,GAAkB,EAAlB;AACA,cAAMC,UAAU,GAAG,KAAK/B,IAAL,CAAUkB,KAAV,CAAgB,CAAhB,EAAmBU,IAAtC;AACA,eAAK5B,IAAL,CAAUgC,WAAV,GAAwB,EAAxB;AACAlB,UAAAA,CAAC,CAACmB,OAAF,CAAU,UAAAjC,IAAI,EAAI;AACd,gBAAMkC,SAAS,GAAG/C,QAAQ,CAACa,IAAI,CAACqB,OAAL,CAAa,CAAb,CAAD,CAA1B,CADc,CAEd;;AACA,gBAAMc,YAAY,GAAG,EAArB;AACA,YAAA,KAAI,CAACnC,IAAL,CAAUgC,WAAV,CAAsBE,SAAtB,IAAmC,EAAnC;;AACA,iBAAK,IAAIR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG1B,IAAI,CAACqB,OAAL,CAAae,MAAjC,EAAyCV,CAAC,EAA1C,EAA+C;AAC3C,kBAAMW,eAAe,GAAGrC,IAAI,CAACqB,OAAL,CAAaK,CAAb,EAAgBY,KAAhB,CAAsB,GAAtB,CAAxB;AACAH,cAAAA,YAAY,CAACI,IAAb,CAAkB,CAACF,eAAe,CAACA,eAAe,CAACD,MAAhB,GAAyB,CAA1B,CAAhB,EAA8CpC,IAAI,CAACqB,OAAL,CAAaK,CAAb,CAA9C,CAAlB;AACA,cAAA,KAAI,CAAC1B,IAAL,CAAUgC,WAAV,CAAsBE,SAAtB,EAAiCG,eAAe,CAACA,eAAe,CAACD,MAAhB,GAAyB,CAA1B,CAAhD,IAAgFpC,IAAI,CAACqB,OAAL,CAAaK,CAAb,CAAhF;AACH;;AACD,gBAAML,OAAO,IAAIrB,IAAI,CAACqB,OAAL,CAAa,CAAb,CAAJ,EAAqBrB,IAAI,CAACqB,OAAL,CAAa,CAAb,CAArB,4BAAyCc,YAAY,CAAChB,GAAb,CAAiB,UAAAqB,CAAC;AAAA,qBAAIA,CAAC,CAAC,CAAD,CAAL;AAAA,aAAlB,CAAzC,EAAb;AACAxC,YAAAA,IAAI,GAAGA,IAAI,CAACmB,GAAL,CAAS,UAAAC,CAAC,EAAI;AACjB,kBAAMqB,OAAO,GAAG,EAAhB;AACAA,cAAAA,OAAO,CAACpB,OAAO,CAAC,CAAD,CAAR,CAAP,GAAsBD,CAAC,CAACC,OAAO,CAAC,CAAD,CAAR,CAAvB;AACAoB,cAAAA,OAAO,CAACpB,OAAO,CAAC,CAAD,CAAR,CAAP,GAAsBD,CAAC,CAACC,OAAO,CAAC,CAAD,CAAR,CAAvB;AACAc,cAAAA,YAAY,CAACF,OAAb,CAAqB,UAAAO,CAAC,EAAI;AACtBC,gBAAAA,OAAO,CAACD,CAAC,CAAC,CAAD,CAAF,CAAP,GAAgBpB,CAAC,CAACoB,CAAC,CAAC,CAAD,CAAF,CAAjB;AACH,eAFD;AAGA,qBAAOC,OAAP;AACH,aARM,CAAP;AAUA,gBAAMC,KAAK,GAAG1C,IAAI,CAAC2C,MAAL,CAAY,UAAAvB,CAAC;AAAA,qBAAIA,CAAC,CAACC,OAAO,CAAC,CAAD,CAAR,CAAD,KAAkB,SAAtB;AAAA,aAAb,EAA8C,CAA9C,CAAd;AACArB,YAAAA,IAAI,GAAGA,IAAI,CAAC2C,MAAL,CAAY,UAAAvB,CAAC;AAAA,qBAAIA,CAAC,CAACC,OAAO,CAAC,CAAD,CAAR,CAAD,KAAkB,SAAtB;AAAA,aAAb,CAAP;AAEA,gBAAMuB,UAAU,GAAGvB,OAAO,CAACwB,KAAR,CAAc,CAAd,CAAnB;AACA,gBAAID,UAAU,CAACR,MAAX,GAAoB,EAAxB,EAA4BQ,UAAU,CAACE,MAAX,CAAkB,EAAlB,EAAsBF,UAAU,CAACR,MAAX,GAAoB,EAA1C;AAC5B,gBAAMW,aAAa,GAAG1B,OAAO,CAAC/B,eAAD,CAA7B;AACA,gBAAM0D,eAAe,GAAGhD,IAAI,CAACmB,GAAL,CAAS,UAAAL,CAAC;AAAA,qBAAKA,CAAC,CAACiC,aAAD,CAAN;AAAA,aAAV,EAAkCJ,MAAlC,CAAyC,UAACM,IAAD,EAAOC,KAAP,EAAcC,IAAd,EAAuB;AACpF,qBAAOA,IAAI,CAAC1B,OAAL,CAAawB,IAAb,MAAuBC,KAA9B;AAAsC,aADlB,CAAxB;AAEA,gBAAME,OAAO,GAAG,CAAC;AAACC,cAAAA,MAAM,EAAE,EAAT;AAAaC,cAAAA,QAAQ,EAAE,EAAvB;AAA2BC,cAAAA,KAAK,EAAE,EAAlC;AAAsCX,cAAAA,UAAU,EAAVA;AAAtC,aAAD,EAAoD;AAACS,cAAAA,MAAM,EAAE,EAAT;AAAaC,cAAAA,QAAQ,EAAE,EAAvB;AAA2BC,cAAAA,KAAK,EAAE,EAAlC;AAAsCX,cAAAA,UAAU,EAAVA;AAAtC,aAApD,CAAhB;AACA,gBAAMY,SAAS,GAAG,EAAlB;AACAZ,YAAAA,UAAU,CAACX,OAAX,CAAmB,UAACwB,GAAD,EAAM/B,CAAN,EAAY;AAC3B,kBAAMgC,WAAW,GAAG,CAAC,EAAD,EAAK,EAAL,CAApB;AACA1D,cAAAA,IAAI,CAACiC,OAAL,CAAa,UAAAnB,CAAC,EAAI;AACd,oBAAIM,CAAC,GAAGuC,UAAU,CAAC7C,CAAC,CAAC2C,GAAD,CAAF,CAAlB;AACA,oBAAIrC,CAAC,KAAK,CAAV,EAAaA,CAAC,GAAG,CAAC,CAAL,CAAb,KACKA,CAAC,GAAGrC,UAAU,CAACqC,CAAD,EAAI,EAAJ,CAAd;AACLoC,gBAAAA,SAAS,CAACjB,IAAV,CAAenB,CAAf;;AACA,oBAAIN,CAAC,CAACiC,aAAD,CAAD,KAAqBC,eAAe,CAAC,CAAD,CAAxC,EAA6C;AACzCU,kBAAAA,WAAW,CAAC,CAAD,CAAX,CAAenB,IAAf,CAAoBnB,CAApB;AACH,iBAFD,MAEO;AACHsC,kBAAAA,WAAW,CAAC,CAAD,CAAX,CAAenB,IAAf,CAAoBnB,CAApB;AACH;AACJ,eAVD;AAWA4B,cAAAA,eAAe,CAACf,OAAhB,CAAwB,UAAC2B,CAAD,EAAIC,CAAJ,EAAU;AAC9B,oBAAMC,MAAM,GAAG,EAAf;AACA,oBAAMC,KAAK,GAAG,IAAIpF,IAAI,CAACqF,IAAL,CAAUC,UAAd,CAAyBP,WAAW,CAACG,CAAD,CAApC,CAAd;AACA,oBAAMK,kBAAkB,GAAGH,KAAK,CAACI,EAAN,KAAaJ,KAAK,CAACK,EAAN,EAAxC;AACAV,gBAAAA,WAAW,CAACG,CAAD,CAAX,CAAe5B,OAAf,CAAuB,UAAAnB,CAAC,EAAI;AACxB,sBAAKA,CAAC,GAAGiD,KAAK,CAACI,EAAN,KAAa,MAAMD,kBAAxB,IAAgDpD,CAAC,GAAGiD,KAAK,CAACI,EAAN,KAAa,MAAMD,kBAA3E,EAAiG;AAC7Fd,oBAAAA,OAAO,CAACS,CAAD,CAAP,CAAWP,QAAX,CAAoBf,IAApB,CAAyB,CAACb,CAAD,EAAIZ,CAAJ,CAAzB;AACH,mBAFD,MAEO;AACHgD,oBAAAA,MAAM,CAACvB,IAAP,CAAYzB,CAAZ;AACH;AACJ,iBAND;AAOA,oBAAMuD,KAAK,GAAG,IAAI1F,IAAI,CAACqF,IAAL,CAAUC,UAAd,CAAyBH,MAAzB,CAAd;AACAV,gBAAAA,OAAO,CAACS,CAAD,CAAP,CAAWR,MAAX,CAAkBd,IAAlB,CAAuB,CAAC8B,KAAK,CAACC,GAAN,EAAD,EAAcD,KAAK,CAACD,EAAN,EAAd,EAA0BC,KAAK,CAACE,MAAN,EAA1B,EAA0CF,KAAK,CAACF,EAAN,EAA1C,EAAsDE,KAAK,CAACG,GAAN,EAAtD,CAAvB;AACApB,gBAAAA,OAAO,CAACS,CAAD,CAAP,CAAWN,KAAX,CAAiBhB,IAAjB,CAAsB8B,KAAK,CAACI,IAAN,EAAtB;AACH,eAdD;AAeH,aA5BD;AA6BA,gBAAMlF,UAAU,GAAGT,mBAAmB,CAAC0E,SAAD,EAAY,CAAZ,EAAe,KAAf,EAAsB,GAAtB,CAAtC;AAEA,YAAA,KAAI,CAACxD,IAAL,CAAU8B,KAAV,CAAgBI,SAAhB,IAA6B;AAACQ,cAAAA,KAAK,EAAEE,UAAU,CAACzB,GAAX,CAAe,UAAAuD,CAAC;AAAA,uBAAIf,UAAU,CAACjB,KAAK,CAACgC,CAAD,CAAN,CAAd;AAAA,eAAhB,CAAR;AAC5B9B,cAAAA,UAAU,EAAVA;AAD4B,aAA7B;AAEA,YAAA,KAAI,CAAC5C,IAAL,CAAU6B,OAAV,CAAkBK,SAAlB,IAA+B;AAACkB,cAAAA,OAAO,EAAPA,OAAD;AAAU7D,cAAAA,UAAU,EAAVA,UAAV;AAAsBqD,cAAAA,UAAU,EAAVA,UAAtB;AAAkCI,cAAAA,eAAe,EAAfA;AAAlC,aAA/B;;AACA,gBAAIjB,UAAU,KAAKG,SAAnB,EAA8B;AAC1B,cAAA,KAAI,CAAClC,IAAL,CAAUoD,OAAV,GAAoB;AAACA,gBAAAA,OAAO,EAAPA,OAAD;AAAU7D,gBAAAA,UAAU,EAAVA,UAAV;AAAsBqD,gBAAAA,UAAU,EAAVA,UAAtB;AAAkCI,gBAAAA,eAAe,EAAfA;AAAlC,eAApB;AACA,cAAA,KAAI,CAAChD,IAAL,CAAU0C,KAAV,GAAkB,KAAI,CAAC1C,IAAL,CAAU8B,KAAV,CAAgBI,SAAhB,CAAlB;AACH;AACJ,WArED;AAsEA,iBAAO,IAAP;AACH;AAtFgB;AADf,KAbsB;AAuGhCyC,IAAAA,KAvGgC,mBAuGxB;AACJC,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAK,OAAL,CAAZ;;AACA,UAAI,KAAK7E,IAAL,CAAUoD,OAAV,CAAkBR,UAAlB,CAA6BR,MAA7B,GAAsC,EAAtC,GAA2C,GAA/C,EAAoD;AAChD,aAAKpC,IAAL,CAAUC,MAAV,CAAiBb,SAAjB,GAA6B,KAAKY,IAAL,CAAUoD,OAAV,CAAkBR,UAAlB,CAA6BR,MAA7B,GAAsC,EAAnE;AACA,aAAKpC,IAAL,CAAU8E,KAAV,GAAkB,EAAlB;AACH,OAHD,MAGO;AACH,aAAK9E,IAAL,CAAU8E,KAAV,GAAkB,MAAM,KAAK9E,IAAL,CAAUoD,OAAV,CAAkBR,UAAlB,CAA6BR,MAArD;AACH,OAPG,CAQJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACApD,MAAAA,oBAAoB,CAACC,YAAY,CAAC,IAAD,CAAb,CAApB;AACH;AA5H+B,GAAf,CAHT;AAAA,MAGL8F,UAHK,mBAGLA,UAHK;;AAkIZ,SAAOA,UAAP;AACH;;AAEDlG,QAAQ,CAACY,WAAD,EAAcC,IAAd,CAAR;AAEA,OAAO,SAASsF,mBAAT,GAA+B;AAClCnG,EAAAA,QAAQ,CAACY,WAAD,EAAcC,IAAd,CAAR;AACH","sourcesContent":["import Oviz from \"crux\"\nimport template from \"./template.bvt\"\nimport {register} from \"page/visualizers\";\n\nimport { findBoundsForValues, computeLog } from \"utils/maths\";\nimport { registerEditorConfig } from \"utils/editor\";\nimport { editorConfig } from \"./editor\";\nimport { groupedChartColors} from \"oviz-common/palette\"\nimport {rankDict} from \"utils/bio-info\";\n\nconst plotWidth = 500;\nconst ylabel = \"Relative abundance -log10\";\nconst classifiedIndex = 1;\nconst valueRange = [-8, 2];\nconst title = \"grouped box plot\";\n// please change the displayed value range in the template by the prop: valueRange.\nconst MODULE_NAME = \"grouped-boxplot-p\";\n\nfunction init() {\n    if (!window.gon || window.gon.module_name !== MODULE_NAME) return;\n\n    const {visualizer} = Oviz.visualize({\n        el: \"#canvas\",\n        template,\n        data: {ylabel, title,\n            config: {\n                plotWidth: 500,\n                showOutliers: true,\n                xLabelRotation: 45,\n                rankIndex: 0,\n            },\n            pValueRange: [0, 0.1],\n            colors: groupedChartColors,\n        },\n        loadData: {\n            boxplotDataGroupedP: {\n                fileKey: \"boxplotDataGroupedP\",\n                type: \"tsv\",\n                dsvHasHeader: true,\n                multiple: true,\n                loaded(d) {\n                    // rank sorting\n                    const rankKeys = Object.keys(rankDict);\n                    this.data.ranks = d.map(x => x.columns[1])\n                                    .sort((a, b) => rankKeys.indexOf(a) - rankKeys.indexOf(b))\n                                    .map((x, i) =>  ({value: i, text: rankDict[x]}));\n                    this.data.boxDict = {};\n                    this.data.pDict = {};\n                    const chosenRank = this.data.ranks[0].text;\n                    this.data.speciesDict = {};\n                    d.forEach(data => {\n                        const rankLabel = rankDict[data.columns[1]];\n                        // only shows the species level\n                        const shortSpecies = [];\n                        this.data.speciesDict[rankLabel] = {};\n                        for (let i = 2; i < data.columns.length; i ++) {\n                            const splittedSpecies = data.columns[i].split(\"|\");\n                            shortSpecies.push([splittedSpecies[splittedSpecies.length - 1], data.columns[i]]);\n                            this.data.speciesDict[rankLabel][splittedSpecies[splittedSpecies.length - 1]] = data.columns[i];\n                        }\n                        const columns = [data.columns[0], data.columns[1], ...shortSpecies.map(s => s[0])];\n                        data = data.map(x => {\n                            const parsedX = {};\n                            parsedX[columns[0]] = x[columns[0]];\n                            parsedX[columns[1]] = x[columns[1]];\n                            shortSpecies.forEach(s => {\n                                parsedX[s[0]] = x[s[1]];\n                            });\n                            return parsedX;\n                        });\n\n                        const pData = data.filter(x => x[columns[0]] === \"p-value\")[0];\n                        data = data.filter(x => x[columns[0]] !== \"p-value\");\n\n                        const categories = columns.slice(2);\n                        if (categories.length > 50) categories.splice(50, categories.length - 50);\n                        const classifiedKey = columns[classifiedIndex];\n                        const classifications = data.map(d => (d[classifiedKey])).filter((item, index, self) => {\n                            return self.indexOf(item) === index; });\n                        const boxData = [{values: [], outliers: [], means: [], categories}, {values: [], outliers: [], means: [], categories}];\n                        const allValues = [];\n                        categories.forEach((arr, i) => {\n                            const initialData = [[], []];\n                            data.forEach(d => {\n                                let x = parseFloat(d[arr]);\n                                if (x === 0) x = -5;\n                                else x = computeLog(x, 10);\n                                allValues.push(x);\n                                if (d[classifiedKey] === classifications[0]) {\n                                    initialData[0].push(x);\n                                } else {\n                                    initialData[1].push(x);\n                                }\n                            });\n                            classifications.forEach((_, j) => {\n                                const result = [];\n                                const stat1 = new Oviz.algo.Statistics(initialData[j]);\n                                const interQuartileRange = stat1.Q3() - stat1.Q1();\n                                initialData[j].forEach(d => {\n                                    if ((d < stat1.Q3() - 1.5 * interQuartileRange) || (d > stat1.Q3() + 1.5 * interQuartileRange))  {\n                                        boxData[j].outliers.push([i, d]);\n                                    } else {\n                                        result.push(d);\n                                    }\n                                });\n                                const stat2 = new Oviz.algo.Statistics(result);\n                                boxData[j].values.push([stat2.min(), stat2.Q1(), stat2.median(), stat2.Q3(), stat2.max()]);\n                                boxData[j].means.push(stat2.mean());\n                            });\n                        });\n                        const valueRange = findBoundsForValues(allValues, 2, false, 0.1);\n\n                        this.data.pDict[rankLabel] = {pData: categories.map(c => parseFloat(pData[c])),\n                         categories};\n                        this.data.boxDict[rankLabel] = {boxData, valueRange, categories, classifications};\n                        if (chosenRank === rankLabel) {\n                            this.data.boxData = {boxData, valueRange, categories, classifications};\n                            this.data.pData = this.data.pDict[rankLabel];\n                        }\n                    });\n                    return null;\n                },\n            },\n        },\n        setup() {\n            console.log(this[\"_data\"]);\n            if (this.data.boxData.categories.length * 20 > 500) {\n                this.data.config.plotWidth = this.data.boxData.categories.length * 20;\n                this.data.gridW = 20;\n            } else {\n                this.data.gridW = 500 / this.data.boxData.categories.length;\n            }\n            // const minBoxW = 12;\n            // const mulNum = this.data.boxData.classifications.length;\n            // const gridW = ((minBoxW + 2) * mulNum - 2) / 0.7;\n            // if (this.data.boxData.categories.length * gridW > plotWidth) {\n            //     this.data.config.plotWidth = this.data.boxData.categories.length * gridW;\n            //     this.data.gridW = gridW;\n            //     this.data.boxW = minBoxW;\n            // } else {\n            //     const boxGap = this.data.boxGap = 4;\n            //     this.data.gridW = plotWidth / this.data.boxData.categories.length;\n            //     this.data.boxW = (this.data.gridW * 0.7 - boxGap * (mulNum - 1)) / mulNum;\n            // }\n            registerEditorConfig(editorConfig(this));\n        },\n    });\n\n    return visualizer;\n}\n\nregister(MODULE_NAME, init);\n\nexport function registerGroupedBoxP() {\n    register(MODULE_NAME, init);\n}"]},"metadata":{},"sourceType":"module"}