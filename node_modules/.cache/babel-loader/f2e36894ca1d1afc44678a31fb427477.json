{"ast":null,"code":"import { isCompNode } from \"../ast-node\";\nimport { BEHAVIOR_BLOCK_NAME, BLOCK_NAME, NAME, STAGE_BLOCK_NAME } from \"../tokens\";\nimport { parseBlock } from \"./block\";\nimport { parseChildren } from \"./children\";\nimport { parseExpr } from \"./expr\";\nimport { parseFor } from \"./for\";\nimport { parseElse, parseElsif, parseIf } from \"./if\";\nimport { parseBehaviorBlock, parseStageBlock } from \"./internal-block\";\nimport { parseLet } from \"./let\";\nimport { parseProp } from \"./prop\";\nimport { parsePropsCommand } from \"./props-command\";\nimport { parseYield } from \"./yield\";\n\nfunction last(array) {\n  return array[array.length - 1];\n}\n\nfunction checkElse(p, node, op) {\n  var lastType = node.children.length && last(node.children).type;\n\n  if (lastType !== \"op-if\" && lastType !== \"op-elsif\") {\n    p._error(\"@\".concat(op, \" should be preceded by @if or @elsif\"));\n  }\n}\n\nexport function parseBlockBody(p, node) {\n  p.expect(\"{\");\n  var stop = false;\n\n  while (!stop) {\n    p.skipSpaces(true);\n    if (p.peek() === \"}\") stop = true;\n    var noMatch = false;\n    var testResult = void 0;\n\n    if (testResult = p.test(\"@([a-z][a-z_\\\\-]*)\")) {\n      var op = testResult[1];\n\n      switch (op) {\n        case \"if\":\n          node.children.push(parseIf(p));\n          break;\n\n        case \"elsif\":\n          checkElse(p, node, op);\n          node.children.push(parseElsif(p));\n          break;\n\n        case \"else\":\n          checkElse(p, node, op);\n          node.children.push(parseElse(p));\n          break;\n\n        case \"for\":\n          node.children.push(parseFor(p));\n          break;\n\n        case \"let\":\n          node.localData.push(parseLet(p, node));\n          break;\n\n        case \"expr\":\n          node.localData.push(parseExpr(p));\n          break;\n\n        case \"props\":\n          if (isCompNode(node)) {\n            node.props.push(parsePropsCommand(p));\n          } else {\n            p._error(\"@options can only appear in component blocks.\");\n          }\n\n          break;\n\n        case \"yield\":\n          node.children.push(parseYield(p));\n          break;\n\n        default:\n          throw new Error(\"Unknown command: @\".concat(op));\n      }\n    } else if (p.peek() === \":\") {\n      var children = parseChildren(p);\n      node.namedChildren[children.name] = children;\n    } else if (testResult = p.test(BLOCK_NAME)) {\n      node.children.push(parseBlock(p));\n    } else if (testResult = p.test(STAGE_BLOCK_NAME)) {\n      if (isCompNode(node)) {\n        node.stage.push(parseStageBlock(p));\n      } else {\n        p._error(\"Stage blocks can only appear in component blocks.\");\n      }\n    } else if (testResult = p.test(BEHAVIOR_BLOCK_NAME)) {\n      if (isCompNode(node)) {\n        node.behavior.push(parseBehaviorBlock(p));\n      } else {\n        p._error(\"Behavior blocks can only appear in component blocks.\");\n      }\n    } else if (testResult = p.test(NAME)) {\n      if (isCompNode(node)) {\n        parseProp(p, node);\n      } else {\n        p._error(\"Property definitions can only appear in component blocks.\");\n      }\n    } else {\n      noMatch = true;\n    }\n\n    p.skipSpaces(true);\n\n    if (p.peek() === \"}\") {\n      stop = true;\n    } else if (noMatch) {\n      p._error(\"Unexpected expression in block body.\");\n    }\n  }\n\n  p.expect(\"}\");\n}","map":null,"metadata":{},"sourceType":"module"}