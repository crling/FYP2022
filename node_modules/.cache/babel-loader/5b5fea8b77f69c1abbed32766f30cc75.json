{"ast":null,"code":"function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport { minmax } from \"crux/dist/utils/math\"; // find the valid bound\n\nexport function findUpperBoundDec(x, sigDigit) {\n  var power = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  if (x < 0) {\n    console.error(\"Bound must be positive value\");\n    return;\n  }\n\n  if (x === 0) return 0;\n  if (x < Math.pow(10, sigDigit - 1)) return findUpperBoundDec(10 * x, sigDigit, power + 1);else {\n    var numTen = 10 * Math.floor(x / 10);\n    var dig = x - numTen;\n    return (numTen + (dig > 5 ? 10 : dig === 0 ? 0 : 5)) / Math.pow(10, power);\n  }\n}\nexport function findLowerBoundDec(x, sigDigit) {\n  var power = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  if (x < 0) {\n    console.error(\"Bound must be positive value\");\n    return;\n  }\n\n  if (x === 0) return 0;\n  if (x < Math.pow(10, sigDigit - 1)) return findLowerBoundDec(10 * x, sigDigit, power + 1);else return Math.floor(x) / Math.pow(10, power);\n}\nexport function findUpperBound(x) {\n  var sigDigit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  if (x < 1) return findUpperBoundDec(x, sigDigit);\n  return parseFloat(Math.ceil(x).toPrecision(sigDigit));\n}\nexport function findLowerBound(x) {\n  var sigDigit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  if (x < 1) return findLowerBoundDec(x, sigDigit);\n  return parseFloat(Math.floor(x).toPrecision(sigDigit));\n}\nexport function computeLog(number) {\n  var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  return Math.log(number) / Math.log(base);\n}\nexport function findBoundsForValues(values, sigDigit) {\n  var isSym = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var padding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n  var _minmax = minmax(values),\n      _minmax2 = _slicedToArray(_minmax, 2),\n      min = _minmax2[0],\n      max = _minmax2[1];\n\n  if (padding !== 0) {\n    var range = max - min;\n    min = min - range * padding;\n    max = max + range * padding;\n  }\n\n  var lowerBound, upperBound;\n\n  if (min < 0 && max > 0) {\n    if (isSym) {\n      var bound = findUpperBound(max > -min ? max : -min, sigDigit);\n      return [-bound, bound];\n    } else {\n      upperBound = findUpperBound(max, sigDigit);\n      lowerBound = Math.sign(min) * findUpperBound(Math.abs(min), sigDigit);\n    }\n  } else if (max > 0) {\n    upperBound = findUpperBound(max, sigDigit);\n    lowerBound = findLowerBound(min, sigDigit);\n  } else if (max < 0) {\n    upperBound = -findLowerBound(-max, sigDigit);\n    lowerBound = findLowerBound(min, sigDigit);\n  }\n\n  return [lowerBound, upperBound];\n}","map":{"version":3,"sources":["/Users/wangzhenyu/Desktop/fyp_workspace/meta_platform/app/javascript/utils/maths.ts"],"names":["minmax","findUpperBoundDec","x","sigDigit","power","console","error","Math","pow","numTen","floor","dig","findLowerBoundDec","findUpperBound","parseFloat","ceil","toPrecision","findLowerBound","computeLog","number","base","log","findBoundsForValues","values","isSym","padding","min","max","range","lowerBound","upperBound","bound","sign","abs"],"mappings":";;;;;;;;;;;;AAAA,SAAQA,MAAR,QAAqB,sBAArB,C,CACA;;AACA,OAAO,SAASC,iBAAT,CAA2BC,CAA3B,EAA8BC,QAA9B,EAAmD;AAAA,MAAXC,KAAW,uEAAH,CAAG;;AACtD,MAAIF,CAAC,GAAG,CAAR,EAAW;AACPG,IAAAA,OAAO,CAACC,KAAR,CAAc,8BAAd;AACA;AACH;;AACD,MAAIJ,CAAC,KAAK,CAAV,EAAa,OAAO,CAAP;AACb,MAAIA,CAAC,GAAGK,IAAI,CAACC,GAAL,CAAS,EAAT,EAAaL,QAAQ,GAAG,CAAxB,CAAR,EACI,OAAOF,iBAAiB,CAAC,KAAKC,CAAN,EAASC,QAAT,EAAmBC,KAAK,GAAG,CAA3B,CAAxB,CADJ,KAEK;AACD,QAAMK,MAAM,GAAG,KAAKF,IAAI,CAACG,KAAL,CAAWR,CAAC,GAAG,EAAf,CAApB;AACA,QAAMS,GAAG,GAAGT,CAAC,GAAGO,MAAhB;AACA,WAAO,CAACA,MAAM,IAAIE,GAAG,GAAG,CAAN,GAAU,EAAV,GAAeA,GAAG,KAAK,CAAR,GAAY,CAAZ,GAAgB,CAAnC,CAAP,IAAgDJ,IAAI,CAACC,GAAL,CAAS,EAAT,EAAaJ,KAAb,CAAvD;AACH;AACJ;AAED,OAAO,SAASQ,iBAAT,CAA2BV,CAA3B,EAA8BC,QAA9B,EAAmD;AAAA,MAAXC,KAAW,uEAAH,CAAG;;AACtD,MAAIF,CAAC,GAAG,CAAR,EAAW;AACPG,IAAAA,OAAO,CAACC,KAAR,CAAc,8BAAd;AACA;AACH;;AACD,MAAIJ,CAAC,KAAK,CAAV,EAAa,OAAO,CAAP;AACb,MAAIA,CAAC,GAAGK,IAAI,CAACC,GAAL,CAAS,EAAT,EAAaL,QAAQ,GAAG,CAAxB,CAAR,EACI,OAAOS,iBAAiB,CAAC,KAAKV,CAAN,EAASC,QAAT,EAAmBC,KAAK,GAAG,CAA3B,CAAxB,CADJ,KAGI,OAAOG,IAAI,CAACG,KAAL,CAAWR,CAAX,IAAgBK,IAAI,CAACC,GAAL,CAAS,EAAT,EAAaJ,KAAb,CAAvB;AACP;AAED,OAAO,SAASS,cAAT,CAAwBX,CAAxB,EAAiE;AAAA,MAA9BC,QAA8B,uEAAX,CAAW;AACpE,MAAID,CAAC,GAAG,CAAR,EACI,OAAOD,iBAAiB,CAACC,CAAD,EAAIC,QAAJ,CAAxB;AACJ,SAAOW,UAAU,CAACP,IAAI,CAACQ,IAAL,CAAUb,CAAV,EAAac,WAAb,CAAyBb,QAAzB,CAAD,CAAjB;AACH;AAED,OAAO,SAASc,cAAT,CAAwBf,CAAxB,EAAiE;AAAA,MAA9BC,QAA8B,uEAAX,CAAW;AACpE,MAAID,CAAC,GAAG,CAAR,EACI,OAAOU,iBAAiB,CAACV,CAAD,EAAIC,QAAJ,CAAxB;AACJ,SAAOW,UAAU,CAACP,IAAI,CAACG,KAAL,CAAWR,CAAX,EAAcc,WAAd,CAA0Bb,QAA1B,CAAD,CAAjB;AACH;AAED,OAAO,SAASe,UAAT,CAAoBC,MAApB,EAA+C;AAAA,MAAnBC,IAAmB,uEAAZ,EAAY;AAClD,SAAOb,IAAI,CAACc,GAAL,CAASF,MAAT,IAAmBZ,IAAI,CAACc,GAAL,CAASD,IAAT,CAA1B;AACH;AAED,OAAO,SAASE,mBAAT,CAA6BC,MAA7B,EAA+CpB,QAA/C,EACyE;AAAA,MAA5CqB,KAA4C,uEAA5B,KAA4B;AAAA,MAArBC,OAAqB,uEAAH,CAAG;;AAAA,gBAC3DzB,MAAM,CAACuB,MAAD,CADqD;AAAA;AAAA,MACvEG,GADuE;AAAA,MAClEC,GADkE;;AAE5E,MAAIF,OAAO,KAAK,CAAhB,EAAmB;AACf,QAAMG,KAAK,GAAGD,GAAG,GAAGD,GAApB;AACAA,IAAAA,GAAG,GAAGA,GAAG,GAAGE,KAAK,GAAGH,OAApB;AACAE,IAAAA,GAAG,GAAGA,GAAG,GAAGC,KAAK,GAAGH,OAApB;AACH;;AACD,MAAII,UAAJ,EAAgBC,UAAhB;;AACA,MAAIJ,GAAG,GAAG,CAAN,IAAWC,GAAG,GAAG,CAArB,EAAwB;AACpB,QAAIH,KAAJ,EAAW;AACP,UAAMO,KAAK,GAAGlB,cAAc,CAAEc,GAAG,GAAG,CAACD,GAAP,GAAaC,GAAb,GAAmB,CAACD,GAAtB,EAA4BvB,QAA5B,CAA5B;AACA,aAAO,CAAC,CAAC4B,KAAF,EAASA,KAAT,CAAP;AACH,KAHD,MAGO;AACHD,MAAAA,UAAU,GAAGjB,cAAc,CAACc,GAAD,EAAMxB,QAAN,CAA3B;AACA0B,MAAAA,UAAU,GAAGtB,IAAI,CAACyB,IAAL,CAAUN,GAAV,IAAiBb,cAAc,CAACN,IAAI,CAAC0B,GAAL,CAASP,GAAT,CAAD,EAAgBvB,QAAhB,CAA5C;AACH;AACJ,GARD,MAQO,IAAIwB,GAAG,GAAG,CAAV,EAAa;AAChBG,IAAAA,UAAU,GAAGjB,cAAc,CAACc,GAAD,EAAMxB,QAAN,CAA3B;AACA0B,IAAAA,UAAU,GAAGZ,cAAc,CAACS,GAAD,EAAMvB,QAAN,CAA3B;AACH,GAHM,MAGA,IAAIwB,GAAG,GAAG,CAAV,EAAa;AAChBG,IAAAA,UAAU,GAAG,CAACb,cAAc,CAAC,CAACU,GAAF,EAAOxB,QAAP,CAA5B;AACA0B,IAAAA,UAAU,GAAGZ,cAAc,CAACS,GAAD,EAAMvB,QAAN,CAA3B;AACH;;AACD,SAAO,CAAC0B,UAAD,EAAaC,UAAb,CAAP;AACH","sourcesContent":["import {minmax} from \"crux/dist/utils/math\";\n// find the valid bound\nexport function findUpperBoundDec(x, sigDigit, power = 0) {\n    if (x < 0) {\n        console.error(\"Bound must be positive value\");\n        return;\n    }\n    if (x === 0) return 0;\n    if (x < Math.pow(10, sigDigit - 1))\n        return findUpperBoundDec(10 * x, sigDigit, power + 1);\n    else {\n        const numTen = 10 * Math.floor(x / 10);\n        const dig = x - numTen;\n        return (numTen + (dig > 5 ? 10 : dig === 0 ? 0 : 5)) / Math.pow(10, power);\n    }\n}\n\nexport function findLowerBoundDec(x, sigDigit, power = 0) {\n    if (x < 0) {\n        console.error(\"Bound must be positive value\");\n        return;\n    }\n    if (x === 0) return 0;\n    if (x < Math.pow(10, sigDigit - 1))\n        return findLowerBoundDec(10 * x, sigDigit, power + 1);\n    else\n        return Math.floor(x) / Math.pow(10, power);\n}\n\nexport function findUpperBound(x: number, sigDigit: number = 2): number {\n    if (x < 1)\n        return findUpperBoundDec(x, sigDigit);\n    return parseFloat(Math.ceil(x).toPrecision(sigDigit));\n}\n\nexport function findLowerBound(x: number, sigDigit: number = 2): number {\n    if (x < 1)\n        return findLowerBoundDec(x, sigDigit);\n    return parseFloat(Math.floor(x).toPrecision(sigDigit));\n}\n\nexport function computeLog(number, base = 10): number {\n    return Math.log(number) / Math.log(base);\n}\n\nexport function findBoundsForValues(values: number[], sigDigit: number,\n                                    isSym: boolean= false, padding: number = 0) {\n    let [min, max] = minmax(values);\n    if (padding !== 0) {\n        const range = max - min;\n        min = min - range * padding;\n        max = max + range * padding;\n    }\n    let lowerBound, upperBound;\n    if (min < 0 && max > 0) {\n        if (isSym) {\n            const bound = findUpperBound( max > -min ? max : -min , sigDigit);\n            return [-bound, bound];\n        } else {\n            upperBound = findUpperBound(max, sigDigit);\n            lowerBound = Math.sign(min) * findUpperBound(Math.abs(min), sigDigit);\n        }\n    } else if (max > 0) {\n        upperBound = findUpperBound(max, sigDigit);\n        lowerBound = findLowerBound(min, sigDigit);\n    } else if (max < 0) {\n        upperBound = -findLowerBound(-max, sigDigit);\n        lowerBound = findLowerBound(min, sigDigit);\n    }\n    return [lowerBound, upperBound];\n}\n"]},"metadata":{},"sourceType":"module"}