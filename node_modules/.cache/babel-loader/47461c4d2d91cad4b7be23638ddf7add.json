{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport * as d3c from \"d3-color\";\nimport { GeometryValue } from \"../../defs/geometry\";\nimport { toRad } from \"../../utils/math\";\nexport function canvasClip(ctx, elm) {\n  var width = elm.$geometry.width;\n  var height = elm.$geometry.height;\n  var v;\n\n  if (v = elm.prop.clip) {\n    if (v.type === \"bound\") {\n      ctx.beginPath();\n      ctx.rect(0, 0, width, height);\n      ctx.clip();\n    } else if (v.type === \"polygon\") {\n      var points = v.points.map(function (p, i) {\n        return _typeof(p) === \"object\" ? GeometryValue.cal(p, i % 2 ? height : width) : p;\n      });\n      ctx.beginPath();\n      ctx.moveTo(points[0], points[1]);\n\n      for (var i = 2; i < points.length; i += 2) {\n        ctx.lineTo(points[i], points[i + 1]);\n      }\n\n      ctx.closePath();\n      ctx.clip();\n    } else {\n      throw new Error(\"Clip: unknown type \\\"\".concat(v.type, \"\\\"\"));\n    }\n  }\n}\nexport function canvasRotate(ctx, elm) {\n  var v;\n\n  if (v = elm.prop.rotation) {\n    var v1 = v[1] === \"_\" ? elm.$geometry.x : v[1];\n    var v2 = v[2] === \"_\" ? elm.$geometry.y : v[2];\n\n    if (v[0] !== 0) {\n      if (v1 === 0 && v2 === 0) {\n        ctx.rotate(toRad(v[0]));\n      } else {\n        ctx.translate(v1, v2);\n        ctx.rotate(toRad(v[0]));\n        ctx.translate(-v1, -v2);\n      }\n    }\n  }\n}\nexport function canvasFill(ctx, elm) {\n  var setOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var f, v;\n\n  if ((f = elm.prop.fill) && f !== \"none\") {\n    if ((v = elm.prop.fillOpacity) && v < 1) {\n      var color = d3c.color(f).rgb();\n      ctx.fillStyle = \"rgba(\".concat(color.r, \",\").concat(color.g, \",\").concat(color.b, \",\").concat(color.opacity * v, \")\");\n    } else {\n      ctx.fillStyle = f;\n    }\n\n    if (setOnly) return;\n\n    if (elm.path) {\n      ctx.fill(elm.path);\n    } else {\n      ctx.fill();\n    }\n  }\n}\nexport function canvasStroke(ctx, elm) {\n  var setOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var f, v;\n\n  if ((f = elm.prop.stroke) && f !== \"none\") {\n    if (v = elm.prop.strokeOpacity) {\n      var color = d3c.color(f).rgb();\n      ctx.strokeStyle = \"rgba(\".concat(color.r, \",\").concat(color.g, \",\").concat(color.b, \",\").concat(color.opacity * v, \")\");\n    } else {\n      ctx.strokeStyle = f;\n    }\n\n    if (v = elm.prop.strokeWidth) {\n      ctx.lineWidth = v;\n    } else {\n      ctx.lineWidth = 1;\n    }\n\n    if (v = elm.prop.dashArray) {\n      ctx.setLineDash(v.split(\",\").map(function (x) {\n        return parseInt(x);\n      }));\n    } else {\n      ctx.setLineDash([]);\n    }\n\n    if (setOnly) return;\n\n    if (elm.path) {\n      ctx.stroke(elm.path);\n    } else {\n      ctx.stroke();\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module"}