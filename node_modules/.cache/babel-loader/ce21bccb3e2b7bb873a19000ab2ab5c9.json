{"ast":null,"code":"function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport Oviz from \"crux\";\nimport { register } from \"page/visualizers\";\nimport { registerEditorConfig } from \"utils/editor\";\nimport { ComplexScatterplotBk } from \"./complex-scatterplot\";\nimport { editorConfig, editorRef } from \"./editor\";\nimport { groupedChartColors } from \"oviz-common/palette\";\nimport { getGroups } from \"utils/array\";\nimport { rankDict } from \"utils/bio-info\";\nimport * as _ from \"lodash\";\nvar MODULE_NAME = \"scatterplot\"; // tbd\n\nfunction init() {\n  if (!window.gon || window.gon.module_name !== MODULE_NAME) return;\n\n  var _Oviz$visualize = Oviz.visualize({\n    el: \"#canvas\",\n    renderer: \"svg\",\n    root: new ComplexScatterplotBk(),\n    height: 700,\n    data: {\n      colors: groupedChartColors.slice(0, 3),\n      config: {\n        plotHeight: 500,\n        plotWidth: 500,\n        rankIndex: 0,\n        xAxisIndex: 0,\n        yAxisIndex: 1,\n        computeOval: false,\n        categoryRange: [null, null],\n        valueRange: [null, null],\n        scatterSize: 8,\n        hollow: false,\n        showErrorEllipse: true\n      },\n      vectorLabel: null\n    },\n    loadData: {\n      scatterData: {\n        fileKey: \"scatterData\",\n        type: \"tsv\",\n        multiple: true,\n        dsvRowParser: function dsvRowParser(row, _, columns) {\n          row[\"sampleId\"] = row[columns[0]];\n          delete row[columns[0]];\n\n          for (var i = 1; i < columns.length; i++) {\n            row[columns[i]] = parseFloat(row[columns[i]]);\n          }\n\n          return row;\n        },\n        loaded: function loaded(d) {\n          var _this = this;\n\n          var rankKeys = Object.keys(rankDict); // hardcoded part\n\n          if (window.gon.analysis_name === \"K-means Cluster\" || d.length === 1 && d[0].columns[0] === \"\") {\n            d[0].columns[0] = \"s\";\n            this.data.speciesDict = {};\n            var shortSpecies = [];\n\n            for (var i = 1; i < d[0].columns.length; i++) {\n              var splittedSpecies = d[0].columns[i].split(\"|\");\n              shortSpecies.push([splittedSpecies[splittedSpecies.length - 1], d[0].columns[i]]);\n              this.data.speciesDict[splittedSpecies[splittedSpecies.length - 1]] = d[0].columns[i];\n            }\n\n            d[0] = d[0].map(function (x) {\n              var parsedX = {\n                sampleId: x.sampleId\n              };\n              shortSpecies.forEach(function (s) {\n                parsedX[s[0]] = x[s[1]];\n              });\n              return parsedX;\n            });\n            d[0].columns = [\"s\"].concat(_toConsumableArray(shortSpecies.map(function (s) {\n              return s[0];\n            })));\n          }\n\n          this.data.ranks = d.map(function (x) {\n            return x.columns[0];\n          }).sort(function (a, b) {\n            return rankKeys.indexOf(a) - rankKeys.indexOf(b);\n          }).map(function (x, i) {\n            return {\n              value: i,\n              text: rankDict[x]\n            };\n          }); // this.data.ranks = d.map((x, i) => ({value: i, text: x.columns[0]}));\n\n          this.data.samples = d[0].map(function (x) {\n            return x[\"sampleId\"];\n          });\n          var mainDict = {};\n          d.forEach(function (data) {\n            mainDict[rankDict[data.columns[0]]] = data;\n          });\n          var selectedDataCols = d[0].columns;\n          this.data.availableAxises = selectedDataCols.filter(function (_, i) {\n            return i > 0;\n          }).map(function (x, i) {\n            return {\n              value: i,\n              text: x\n            };\n          });\n          this.data.mainDict = mainDict;\n          this.data.rankLabel = this.data.ranks[0].text;\n          this.data.sampleInfoDict = {};\n          this.data.samples.forEach(function (k) {\n            return _this.data.sampleInfoDict[k] = {};\n          });\n          return mainDict[this.data.rankLabel];\n        }\n      },\n      scatterGroupData: {\n        fileKey: \"scatterGroupData\",\n        type: \"tsv\",\n        optional: true,\n        dependsOn: [\"scatterData\"],\n        loaded: function loaded(data) {\n          var _this2 = this;\n\n          if (!data) return; // this.data.groups = [...getGroups(data, data.columns[1]), \"unknown\"];\n\n          var groups = getGroups(data, data.columns[1]);\n          var groupDict = {};\n          data.forEach(function (x) {\n            groupDict[x[data.columns[0]]] = x[data.columns[1]];\n          });\n          var hasUnknownSample = false;\n          this.data.samples.forEach(function (s) {\n            _this2.data.sampleInfoDict[s].group = groupDict[s] || \"unknown\";\n\n            if (!groupDict[s] && !hasUnknownSample) {\n              hasUnknownSample = true;\n            } // data.forEach((group, i, arr) => {\n            //     if(group[data.columns[0]] === s){\n            //         this.data.sampleInfoDict[s].group = group[data.columns[1]];\n            //         arr.slice(i, 1);\n            //     }\n            // })\n\n          });\n          if (hasUnknownSample) groups.push(\"unknown\");\n          this.data.groups = groups;\n          return null;\n        }\n      },\n      scatterVectorData: {\n        fileKey: \"scatterVectorData\",\n        type: \"tsv\",\n        optional: true,\n        dependsOn: [\"scatterData\"],\n        dsvRowParser: function dsvRowParser(row, _, columns) {\n          for (var i = 1; i < columns.length; i++) {\n            row[columns[i]] = parseFloat(row[columns[i]]);\n          }\n\n          return row;\n        },\n        loaded: function loaded(data) {\n          if (!data) return;\n          this.data.vectorLabel = data.columns[0];\n        }\n      },\n      scatterClusterData: {\n        fileKey: \"scatterClusterData\",\n        type: \"tsv\",\n        optional: true,\n        multiple: true,\n        dependsOn: [\"scatterData\"],\n        loaded: function loaded(d) {\n          var _this3 = this;\n\n          if (!d) return;\n          this.data.clusterDict = {};\n          d.forEach(function (x) {\n            var rankK = rankDict[x.columns[0]];\n            var sampleK = x.columns[0];\n            var clusterK = x.columns[1];\n            x.forEach(function (r) {\n              if (!_this3.data.clusterDict[r[sampleK]]) _this3.data.clusterDict[r[sampleK]] = {};\n              _this3.data.clusterDict[r[sampleK]][rankK] = r[clusterK];\n            });\n          });\n          var chosenRank = this.data.ranks[0].text;\n          var data = Object.keys(this.data.clusterDict).map(function (k) {\n            return _this3.data.clusterDict[k];\n          });\n          this.data.clusters = Object.keys(_.groupBy(data, chosenRank));\n          return null;\n        }\n      }\n    },\n    setup: function setup() {\n      registerEditorConfig(editorConfig(this), editorRef);\n    }\n  }),\n      visualizer = _Oviz$visualize.visualizer;\n\n  return visualizer;\n}\n\nregister(MODULE_NAME, init);\nexport function registerScatterplot() {\n  register(MODULE_NAME, init);\n}","map":{"version":3,"sources":["/Users/wangzhenyu/Desktop/fyp_workspace/meta_platform/app/javascript/viz/scatterplot/index.ts"],"names":["Oviz","register","registerEditorConfig","ComplexScatterplotBk","editorConfig","editorRef","groupedChartColors","getGroups","rankDict","_","MODULE_NAME","init","window","gon","module_name","visualize","el","renderer","root","height","data","colors","slice","config","plotHeight","plotWidth","rankIndex","xAxisIndex","yAxisIndex","computeOval","categoryRange","valueRange","scatterSize","hollow","showErrorEllipse","vectorLabel","loadData","scatterData","fileKey","type","multiple","dsvRowParser","row","columns","i","length","parseFloat","loaded","d","rankKeys","Object","keys","analysis_name","speciesDict","shortSpecies","splittedSpecies","split","push","map","x","parsedX","sampleId","forEach","s","ranks","sort","a","b","indexOf","value","text","samples","mainDict","selectedDataCols","availableAxises","filter","rankLabel","sampleInfoDict","k","scatterGroupData","optional","dependsOn","groups","groupDict","hasUnknownSample","group","scatterVectorData","scatterClusterData","clusterDict","rankK","sampleK","clusterK","r","chosenRank","clusters","groupBy","setup","visualizer","registerScatterplot"],"mappings":"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","sourcesContent":["import Oviz from \"crux\";\n\nimport {register} from \"page/visualizers\";\nimport { registerEditorConfig } from \"utils/editor\";\n\nimport {ComplexScatterplotBk} from \"./complex-scatterplot\";\nimport { editorConfig, editorRef } from \"./editor\";\n\nimport { groupedChartColors } from \"oviz-common/palette\";\nimport { getGroups } from \"utils/array\";\nimport {rankDict} from \"utils/bio-info\";\n\nimport * as _ from \"lodash\";\n\nconst MODULE_NAME = \"scatterplot\";\n\n// tbd\nfunction init() {\n    if (!window.gon || window.gon.module_name !== MODULE_NAME) return;\n\n    const {visualizer} = Oviz.visualize({\n        el: \"#canvas\",\n        renderer: \"svg\",\n        root: new ComplexScatterplotBk(),\n        height: 700,\n        data: {\n            colors: groupedChartColors.slice(0, 3),\n            config: {\n                plotHeight: 500,\n                plotWidth: 500,\n                rankIndex: 0,\n                xAxisIndex: 0,\n                yAxisIndex: 1,\n                computeOval: false,\n                categoryRange: [null, null],\n                valueRange: [null, null],\n                scatterSize: 8,\n                hollow: false,\n                showErrorEllipse: true,\n            },\n            vectorLabel: null,\n        },\n        loadData: {\n            scatterData: {\n                fileKey: \"scatterData\",\n                type: \"tsv\",\n                multiple: true,\n                dsvRowParser (row, _, columns) {\n                    row[\"sampleId\"] = row[columns[0]];\n                    delete row[columns[0]];\n                    for (let i = 1; i < columns.length; i++)\n                        row[columns[i]] = parseFloat(row[columns[i]]);\n                    return row;\n                },\n                loaded(d) {\n                    const rankKeys = Object.keys(rankDict);\n                    // hardcoded part\n                    if (window.gon.analysis_name === \"K-means Cluster\" || (d.length === 1 && d[0].columns[0] === \"\")) {\n                        d[0].columns[0] = \"s\";\n                        this.data.speciesDict = {};\n                        const shortSpecies = [];\n                        for (let i = 1; i < d[0].columns.length; i ++) {\n                            const splittedSpecies = d[0].columns[i].split(\"|\");\n                            shortSpecies.push([splittedSpecies[splittedSpecies.length - 1], d[0].columns[i]]);\n                            this.data.speciesDict[splittedSpecies[splittedSpecies.length - 1]] = d[0].columns[i];\n                        }\n                        d[0] = d[0].map(x => {\n                            const parsedX = {sampleId: x.sampleId};\n                            shortSpecies.forEach(s => {\n                                parsedX[s[0]] = x[s[1]];\n                            });\n                            return parsedX;\n                        });\n                        d[0].columns = [\"s\", ...shortSpecies.map(s => s[0])];\n                    }\n                    this.data.ranks = d.map(x => x.columns[0])\n                                    .sort((a, b) => rankKeys.indexOf(a) - rankKeys.indexOf(b))\n                                    .map((x, i) =>  ({value: i, text: rankDict[x]}));\n                    // this.data.ranks = d.map((x, i) => ({value: i, text: x.columns[0]}));\n                    this.data.samples = d[0].map(x => x[\"sampleId\"]);\n                    const mainDict = {};\n                    d.forEach(data => {\n                        mainDict[rankDict[data.columns[0]]] = data;\n                    });\n                    const selectedDataCols = d[0].columns;\n                    this.data.availableAxises = selectedDataCols.filter((_, i) => i > 0)\n                                .map((x, i) => ({value: i, text: x}));\n                    this.data.mainDict = mainDict;\n                    this.data.rankLabel = this.data.ranks[0].text;\n                    this.data.sampleInfoDict = {};\n                    this.data.samples.forEach(k => this.data.sampleInfoDict[k] = {});\n                    return mainDict[this.data.rankLabel];\n                },\n            },\n            scatterGroupData: {\n                fileKey: \"scatterGroupData\",\n                type: \"tsv\",\n                optional: true,\n                dependsOn: [\"scatterData\"],\n                loaded(data) {\n                    if (!data) return;\n                    // this.data.groups = [...getGroups(data, data.columns[1]), \"unknown\"];\n                    const groups = getGroups(data, data.columns[1]);\n                    const groupDict = {};\n                    data.forEach(x => {\n                        groupDict[x[data.columns[0]]] = x[data.columns[1]];\n                    });\n                    let hasUnknownSample = false;\n                    this.data.samples.forEach(s => {\n                        this.data.sampleInfoDict[s].group = groupDict[s] || \"unknown\";\n                        if (!groupDict[s] && !hasUnknownSample) { \n                            hasUnknownSample = true;\n                        }\n                        // data.forEach((group, i, arr) => {\n                        //     if(group[data.columns[0]] === s){\n                        //         this.data.sampleInfoDict[s].group = group[data.columns[1]];\n                        //         arr.slice(i, 1);\n                        //     }\n                        // })\n                    });\n                    if (hasUnknownSample) groups.push(\"unknown\");\n                    this.data.groups = groups;\n                    return null;\n                },\n            },\n            scatterVectorData: {\n                fileKey: \"scatterVectorData\",\n                type: \"tsv\",\n                optional: true,\n                dependsOn: [\"scatterData\"],\n                dsvRowParser (row, _, columns) {\n                    for (let i = 1; i < columns.length; i++)\n                        row[columns[i]] = parseFloat(row[columns[i]]);\n                    return row;\n                },\n                loaded(data) {\n                    if (!data) return;\n                    this.data.vectorLabel = data.columns[0];\n                },\n            },\n            scatterClusterData: {\n                fileKey: \"scatterClusterData\",\n                type: \"tsv\",\n                optional: true,\n                multiple: true,\n                dependsOn: [\"scatterData\"],\n                loaded(d) {\n                    if (!d) return;\n                    this.data.clusterDict = {};\n                    d.forEach(x => {\n                        const rankK = rankDict[x.columns[0]];\n                        const sampleK = x.columns[0];\n                        const clusterK = x.columns[1];\n                        x.forEach(r => {\n                            if (!this.data.clusterDict[r[sampleK]])\n                                this.data.clusterDict[r[sampleK]] = {};\n                            this.data.clusterDict[r[sampleK]][rankK] = r[clusterK];\n                        });\n                    });\n                    const chosenRank = this.data.ranks[0].text;\n                    const data = Object.keys(this.data.clusterDict).map(k => this.data.clusterDict[k]);\n                    this.data.clusters = Object.keys(_.groupBy(data, chosenRank));\n                    return null;\n                },\n            },\n        },\n        setup() {\n            registerEditorConfig(editorConfig(this), editorRef);\n        },\n    });\n\n    return visualizer;\n}\n\nregister(MODULE_NAME, init);\n\nexport function registerScatterplot() {\n    register(MODULE_NAME, init);\n}\n"]},"metadata":{},"sourceType":"module"}