{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport { currentEventContext } from \"../../../event\";\n\nfunction invokeHandler(handler, vnode, event) {\n  if (typeof handler === \"function\") {\n    // call function handler\n    currentEventContext.event = event;\n    currentEventContext.elm = vnode.data._elm;\n    currentEventContext.vnode = vnode;\n    handler.call(null, event, vnode.data._elm, vnode);\n    currentEventContext.event = undefined;\n    currentEventContext.elm = undefined;\n    currentEventContext.vnode = undefined;\n  } else if (_typeof(handler) === \"object\") {\n    // call handler with arguments\n    if (typeof handler[0] === \"function\") {\n      // special case for single argument for performance\n      currentEventContext.event = event;\n      currentEventContext.elm = vnode.data._elm;\n      currentEventContext.vnode = vnode;\n\n      if (handler.length === 2) {\n        handler[0].call(null, handler[1]);\n      } else {\n        var args = handler.slice(1);\n        handler[0].apply(null, args);\n      }\n\n      currentEventContext.event = undefined;\n      currentEventContext.elm = undefined;\n      currentEventContext.vnode = undefined;\n    } else {\n      // call multiple handlers\n      for (var i = 1; i < handler.length; i++) {\n        invokeHandler(handler[i], vnode, event);\n      }\n    }\n  }\n}\n\nfunction handleEvent(event, vnode) {\n  var name = event.type,\n      on = vnode.data.on; // call event handler(s) if exists\n\n  if (on && on[name]) {\n    invokeHandler(on[name], vnode, event);\n  }\n}\n\nfunction createListener() {\n  return function handler(event) {\n    handleEvent(event, handler.vnode);\n  };\n}\n\nfunction updateEventListeners(oldVnode, vnode) {\n  var oldOn = oldVnode.data.on,\n      oldListener = oldVnode.listener,\n      oldElm = oldVnode.elm,\n      on = vnode && vnode.data.on,\n      elm = vnode && vnode.elm;\n  var name; // optimization for reused immutable handlers\n\n  if (oldOn === on) {\n    return;\n  } // remove existing listeners which no longer used\n\n\n  if (oldOn && oldListener) {\n    // if element changed or deleted we remove all existing listeners unconditionally\n    if (!on) {\n      // tslint:disable-next-line: forin\n      for (name in oldOn) {\n        // remove listener if element was changed or existing listeners removed\n        oldElm.removeEventListener(name, oldListener, false);\n      }\n    } else {\n      for (name in oldOn) {\n        // remove listener if existing listener removed\n        if (!on[name]) {\n          oldElm.removeEventListener(name, oldListener, false);\n        }\n      }\n    }\n  } // add new listeners which has not already attached\n\n\n  if (on) {\n    // reuse existing listener or create new\n    var listener = vnode.listener = oldVnode.listener || createListener(); // update vnode for listener\n\n    listener.vnode = vnode; // if element changed or added we add all needed listeners unconditionally\n\n    if (!oldOn) {\n      // tslint:disable-next-line: forin\n      for (name in on) {\n        // add listener if element was changed or new listeners added\n        elm.addEventListener(name, listener, false);\n      }\n    } else {\n      for (name in on) {\n        // add listener if new listener added\n        if (!oldOn[name]) {\n          elm.addEventListener(name, listener, false);\n        }\n      }\n    }\n  }\n}\n\nexport var eventListenersModule = {\n  create: updateEventListeners,\n  update: updateEventListeners,\n  destroy: updateEventListeners\n};\nexport default eventListenersModule;","map":null,"metadata":{},"sourceType":"module"}