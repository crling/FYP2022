{"ast":null,"code":"function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n        Component{\\n            Rows {\\n                @for (row, i) in prop.rows {\\n                    Columns {\\n                        @for (col, j) in prop.columns {\\n                            Component {\\n                                width = prop.gridW\\n                                height = prop.gridH\\n                                behavior:tooltip {\\n                                    content = (\\\"correlation: \\\" + parseFloat(prop.data[row][col][\\\"r\\\"]).toFixed(3)\\n                                            + \\\" </br> p-value: \\\" + parseFloat(prop.data[row][col][\\\"p\\\"]).toFixed(3)) }\\n                                Rect {\\n                                    // key = n\\n                                    height = 100%; width = 100%;\\n                                    fill = getColor(prop.data[row][col][\\\"r\\\"]);\\n                                }\\n                                @if prop.showPAnno {\\n                                    @if (prop.data[row][col][\\\"p\\\"] > 0.7) {\\n                                        Text.centered {\\n                                            text = \\\"*\\\"\\n                                            fontSize = prop.gridH\\n                                            fill = \\\"black\\\"\\n                                            x = prop.gridW/2; y = prop.gridH/2\\n                                        }\\n                                    }\\n                                }\\n                            }\\n                        }\\n                        Component {\\n                            Text {\\n                                text = row\\n                                fontSize = rowLabelSize\\n                            }\\n                        }\\n                    }\\n                }\\n                Columns {\\n                    @for c in prop.columns {\\n                        Component {\\n                            width = prop.gridW\\n                            Text {\\n                                text = c\\n                                x = prop.gridW/2\\n                                y = 2\\n                                anchor = @anchor(\\\"r\\\",\\\"m\\\")\\n                                rotation = @rotate(-90)\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n\\n            Rows { // legend area\\n                x = prop.gridW * prop.columns.length + maxRowLabelWidth + 20; y = 20;\\n                Component {\\n                    height = 60\\n                    Columns {\\n                        @for i in 10 {\\n                            Component{\\n                                height = 20; width = 5\\n                                Rect.full {\\n                                    fill = _negativeColorScheme.get(-(i-10)/10)\\n                                }\\n                                // Text {\\n                                //     text = scale\\n                                //     x = 22; y = 10\\n                                //     anchor = @anchor(\\\"l\\\",\\\"m\\\")\\n                                // }\\n                            }\\n                        }\\n                        @for i in 10 {\\n                            Component{\\n                                height = 20; width = 5\\n                                Rect.full {\\n                                    fill = _positiveColorScheme.get(i/10)\\n                                }\\n                                // Text {\\n                                //     text = scale\\n                                //     x = 22; y = 10\\n                                //     anchor = @anchor(\\\"l\\\",\\\"m\\\")\\n                                // }\\n                            }\\n                        }\\n                    }\\n                    Text.centered {\\n                        text = range.min\\n                        x = 0; y = 25\\n                    }\\n                    Text.centered {\\n                        text = range.max\\n                        x = 100; y = 25\\n                    }\\n                    Line {\\n                        x1 = 0; x2 = 100; y1 = 20; y2 = 20\\n                        stroke = @color(\\\"line\\\")\\n                    }\\n                }\\n                Component {\\n                    @yield groupLegend\\n                }\\n            }\\n        }\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (typeof call === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport { schemeGradient } from \"crux/dist/color\";\nimport { Component } from \"crux/dist/element\";\nimport * as d3 from \"d3\";\nimport * as text_size from \"crux/dist/utils/text-size\";\nimport { findUpperBound } from \"utils/maths\";\nexport var SignedHeatMap = /*#__PURE__*/function (_Component) {\n  _inherits(SignedHeatMap, _Component);\n\n  var _super = _createSuper(SignedHeatMap);\n\n  function SignedHeatMap() {\n    var _this;\n\n    _classCallCheck(this, SignedHeatMap);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this._negScale = void 0;\n    _this._posScale = void 0;\n    _this._negativeColorScheme = void 0;\n    _this._positiveColorScheme = void 0;\n    _this.range = void 0;\n    _this.maxRowLabelWidth = void 0;\n    _this.rowLabelSize = void 0;\n    return _this;\n  }\n\n  _createClass(SignedHeatMap, [{\n    key: \"render\",\n    value: function render() {\n      return this.t(_templateObject());\n    }\n  }, {\n    key: \"didCreate\",\n    value: function didCreate() {\n      if (this.prop.rows.length * this.prop.gridH > 950) this.$v.size.height = this.prop.rows.length * this.prop.gridH + 150;\n    }\n  }, {\n    key: \"willRender\",\n    value: function willRender() {\n      var _this2 = this;\n\n      this.rowLabelSize = this.prop.gridH > 12 ? this.prop.gridH - 2 : this.prop.gridH;\n      this.maxRowLabelWidth = Math.max.apply(Math, _toConsumableArray(this.prop.rows.map(function (t) {\n        return text_size.measuredTextSize(t, _this2.rowLabelSize).width;\n      })));\n      this.range = this.computeRange(this.prop.dataRange[0], this.prop.dataRange[1], this.prop.symRange);\n      this._negScale = d3.scaleLinear().domain([this.range.min, 0]).range([-1, 0]);\n      this._posScale = d3.scaleLinear().domain([0, this.range.max]).range([0, 1]);\n      this._negativeColorScheme = schemeGradient(this.prop.startColor, this.prop.negativeEndColor);\n      this._positiveColorScheme = schemeGradient(this.prop.startColor, this.prop.positiveEndColor);\n    }\n  }, {\n    key: \"computeRange\",\n    value: function computeRange(min, max, isSym) {\n      if (isSym) {\n        var bound = max > -min ? max : -min;\n        bound = findUpperBound(bound);\n        return {\n          min: -bound,\n          max: bound\n        };\n      } else {\n        var upperBound = findUpperBound(max);\n        var lowerBound = findUpperBound(-min);\n        return {\n          min: -lowerBound,\n          max: upperBound\n        };\n      }\n    }\n  }, {\n    key: \"getColor\",\n    value: function getColor(data) {\n      if (data > 0) return this._positiveColorScheme.get(this._posScale(data));else {\n        return this._negativeColorScheme.get(-this._negScale(data));\n      }\n    }\n  }]);\n\n  return SignedHeatMap;\n}(Component);","map":{"version":3,"sources":["/Users/wangzhenyu/Desktop/fyp_workspace/meta_platform/app/javascript/viz/signed-heatmap/signed-heatmap.ts"],"names":["schemeGradient","Component","d3","text_size","findUpperBound","SignedHeatMap","_negScale","_posScale","_negativeColorScheme","_positiveColorScheme","range","maxRowLabelWidth","rowLabelSize","t","prop","rows","length","gridH","$v","size","height","Math","max","map","measuredTextSize","width","computeRange","dataRange","symRange","scaleLinear","domain","min","startColor","negativeEndColor","positiveEndColor","isSym","bound","upperBound","lowerBound","data","get"],"mappings":"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","sourcesContent":["import { ColorSchemeGradient, schemeGradient } from \"crux/dist/color\";\nimport { Component, ComponentOption } from \"crux/dist/element\";\nimport * as d3 from \"d3\";\nimport * as text_size from \"crux/dist/utils/text-size\";\nimport { findUpperBound } from \"utils/maths\";\n\n\nexport interface SignedHeatMapOption extends ComponentOption {\n    rows: [];\n    columns: [];\n    data: any;\n    gridW: number;\n    gridH: number;\n    positiveEndColor: string;\n    negativeEndColor: string;\n    startColor: string;\n    dataRange: [];\n    symRange: boolean;\n    showPAnno: boolean;\n}\n\nexport class SignedHeatMap extends Component<SignedHeatMapOption> {\n\n    private _negScale!: any;\n    private _posScale!: any;\n    private _negativeColorScheme!: ColorSchemeGradient;\n    private _positiveColorScheme!: ColorSchemeGradient;\n    private range: any;\n    private maxRowLabelWidth: number;\n    private rowLabelSize: number;\n\n    render() {\n        return this.t`\n        Component{\n            Rows {\n                @for (row, i) in prop.rows {\n                    Columns {\n                        @for (col, j) in prop.columns {\n                            Component {\n                                width = prop.gridW\n                                height = prop.gridH\n                                behavior:tooltip {\n                                    content = (\"correlation: \" + parseFloat(prop.data[row][col][\"r\"]).toFixed(3)\n                                            + \" </br> p-value: \" + parseFloat(prop.data[row][col][\"p\"]).toFixed(3)) }\n                                Rect {\n                                    // key = n\n                                    height = 100%; width = 100%;\n                                    fill = getColor(prop.data[row][col][\"r\"]);\n                                }\n                                @if prop.showPAnno {\n                                    @if (prop.data[row][col][\"p\"] > 0.7) {\n                                        Text.centered {\n                                            text = \"*\"\n                                            fontSize = prop.gridH\n                                            fill = \"black\"\n                                            x = prop.gridW/2; y = prop.gridH/2\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        Component {\n                            Text {\n                                text = row\n                                fontSize = rowLabelSize\n                            }\n                        }\n                    }\n                }\n                Columns {\n                    @for c in prop.columns {\n                        Component {\n                            width = prop.gridW\n                            Text {\n                                text = c\n                                x = prop.gridW/2\n                                y = 2\n                                anchor = @anchor(\"r\",\"m\")\n                                rotation = @rotate(-90)\n                            }\n                        }\n                    }\n                }\n            }\n\n            Rows { // legend area\n                x = prop.gridW * prop.columns.length + maxRowLabelWidth + 20; y = 20;\n                Component {\n                    height = 60\n                    Columns {\n                        @for i in 10 {\n                            Component{\n                                height = 20; width = 5\n                                Rect.full {\n                                    fill = _negativeColorScheme.get(-(i-10)/10)\n                                }\n                                // Text {\n                                //     text = scale\n                                //     x = 22; y = 10\n                                //     anchor = @anchor(\"l\",\"m\")\n                                // }\n                            }\n                        }\n                        @for i in 10 {\n                            Component{\n                                height = 20; width = 5\n                                Rect.full {\n                                    fill = _positiveColorScheme.get(i/10)\n                                }\n                                // Text {\n                                //     text = scale\n                                //     x = 22; y = 10\n                                //     anchor = @anchor(\"l\",\"m\")\n                                // }\n                            }\n                        }\n                    }\n                    Text.centered {\n                        text = range.min\n                        x = 0; y = 25\n                    }\n                    Text.centered {\n                        text = range.max\n                        x = 100; y = 25\n                    }\n                    Line {\n                        x1 = 0; x2 = 100; y1 = 20; y2 = 20\n                        stroke = @color(\"line\")\n                    }\n                }\n                Component {\n                    @yield groupLegend\n                }\n            }\n        }`;\n\n    }\n\n    public didCreate() {\n        if (this.prop.rows.length * this.prop.gridH > 950)\n            this.$v.size.height = this.prop.rows.length * this.prop.gridH + 150;\n    }\n    public willRender() {\n        this.rowLabelSize = this.prop.gridH > 12 ? this.prop.gridH - 2 : this.prop.gridH;\n        this.maxRowLabelWidth = Math.max(...this.prop.rows.map(t =>\n            text_size.measuredTextSize(t, this.rowLabelSize).width));\n        this.range = this.computeRange(this.prop.dataRange[0],\n            this.prop.dataRange[1], this.prop.symRange);\n        this._negScale = d3.scaleLinear().domain([this.range.min, 0]).range([-1, 0]);\n        this._posScale = d3.scaleLinear().domain([0, this.range.max]).range([0, 1]);\n        this._negativeColorScheme = schemeGradient(this.prop.startColor, this.prop.negativeEndColor);\n        this._positiveColorScheme = schemeGradient(this.prop.startColor, this.prop.positiveEndColor);\n    }\n\n    protected computeRange(min, max, isSym): any {\n        if (isSym) {\n            let bound = (max > -min) ? max : -min;\n            bound = findUpperBound(bound);\n            return {min: -bound, max: bound};\n        } else {\n            const upperBound = findUpperBound(max);\n            const lowerBound = findUpperBound(-min);\n            return {min: -lowerBound, max: upperBound};\n        }\n    }\n\n    getColor(data: number): string {\n        if (data > 0) return this._positiveColorScheme.get(this._posScale(data));\n        else {\n            return this._negativeColorScheme.get(-this._negScale(data));\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}