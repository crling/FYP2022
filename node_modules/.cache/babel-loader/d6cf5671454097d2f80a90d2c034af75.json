{"ast":null,"code":"var _class, _temp;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (typeof call === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport { event } from \"crux/dist/utils\";\nimport { Component, Vue } from \"vue-property-decorator\";\n\nvar EditText = Component(_class = (_temp = /*#__PURE__*/function (_Vue) {\n  _inherits(EditText, _Vue);\n\n  var _super = _createSuper(EditText);\n\n  function EditText() {\n    var _this;\n\n    _classCallCheck(this, EditText);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.data = {};\n    _this.isDirty = false;\n    return _this;\n  }\n\n  _createClass(EditText, [{\n    key: \"mounted\",\n    value: function mounted() {\n      var _this2 = this;\n\n      event.on(\"edit-text-start\", function (_, d) {\n        _this2.data = _objectSpread({}, d);\n        _this2.isDirty = false;\n\n        _this2.$refs.modal.show();\n      });\n    }\n  }, {\n    key: \"restore\",\n    value: function restore() {\n      this.data.text = this.data.originalText;\n    }\n  }, {\n    key: \"updateData\",\n    value: function updateData(e) {\n      if (!this.isDirty) return;\n      event.emit(\"edit-text-done\", _objectSpread({}, this.data));\n    }\n  }]);\n\n  return EditText;\n}(Vue), _temp)) || _class;\n\nexport { EditText as default };","map":{"version":3,"sources":["edit-text-vue.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA,SAAA,KAAA,QAAA,iBAAA;AACA,SAAA,SAAA,EAAA,GAAA,QAAA,wBAAA;;IAGA,Q,GADA,S;;;;;;;;;;;;;;;UAEA,I,GAAA,E;UACA,O,GAAA,K;;;;;;8BAEA;AAAA;;AACA,MAAA,KAAA,CAAA,EAAA,CAAA,iBAAA,EAAA,UAAA,CAAA,EAAA,CAAA,EAAA;AACA,QAAA,MAAA,CAAA,IAAA,qBAAA,CAAA;AACA,QAAA,MAAA,CAAA,OAAA,GAAA,KAAA;;AACA,QAAA,MAAA,CAAA,KAAA,CAAA,KAAA,CAAA,IAAA;AACA,OAJA;AAKA;;;8BACA;AACA,WAAA,IAAA,CAAA,IAAA,GAAA,KAAA,IAAA,CAAA,YAAA;AACA;;;+BAEA,C,EAAA;AACA,UAAA,CAAA,KAAA,OAAA,EAAA;AACA,MAAA,KAAA,CAAA,IAAA,CAAA,gBAAA,oBAAA,KAAA,IAAA;AACA;;;;EAlBA,G;;SAAA,Q","sourcesContent":["<template>\n    <div>\n        <b-modal ref=\"modal\" :title=\"`Edit Text: ${data.originalText}`\" no-stacking no-fade centered ok-only @ok=\"updateData\">\n            <div style=\"max-height: 50vh; overflow: auto;\">\n                <b-input-group class=\"mt-1\">\n                    <b-form-input v-model=\"data.text\" @change=\"isDirty = true\" />\n                    <b-input-group-append>\n                        <b-button  variant=\"primary\" @click=\"restore()\">Restore</b-button>\n                    </b-input-group-append>\n                </b-input-group>\n            </div>\n        </b-modal>\n    </div>\n</template>\n\n<script lang=\"ts\">\nimport { event } from \"crux/dist/utils\";\nimport { Component, Vue } from \"vue-property-decorator\";\n\n@Component\nexport default class EditText extends Vue {\n    data: any = {};\n    isDirty = false;\n\n    mounted() {\n        event.on(\"edit-text-start\", (_, d) => {\n            this.data = {...d};\n            this.isDirty = false;\n            (this.$refs.modal as any).show();\n        });\n    }\n    private restore() {\n        this.data.text = this.data.originalText;\n    }\n\n    private updateData(e: Event) {\n        if (!this.isDirty) return;\n        event.emit(\"edit-text-done\", {...this.data});\n    }\n}\n</script>\n"],"sourceRoot":"app/javascript/oviz-components"},"metadata":{},"sourceType":"module"}