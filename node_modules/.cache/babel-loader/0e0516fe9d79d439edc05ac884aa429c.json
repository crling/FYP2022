{"ast":null,"code":"/** vue-property-decorator verson 9.0.0 MIT LICENSE copyright 2020 kaorun343 */\n/// <reference types='reflect-metadata'/>\n'use strict';\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport Vue from 'vue';\nimport Component, { createDecorator, mixins } from 'vue-class-component';\nexport { Component, Vue, mixins as Mixins };\n/** Used for keying reactive provide/inject properties */\n\nvar reactiveInjectKey = '__reactiveInject__';\n/**\n * decorator of an inject\n * @param from key\n * @return PropertyDecorator\n */\n\nexport function Inject(options) {\n  return createDecorator(function (componentOptions, key) {\n    if (typeof componentOptions.inject === 'undefined') {\n      componentOptions.inject = {};\n    }\n\n    if (!Array.isArray(componentOptions.inject)) {\n      componentOptions.inject[key] = options || key;\n    }\n  });\n}\n/**\n * decorator of a reactive inject\n * @param from key\n * @return PropertyDecorator\n */\n\nexport function InjectReactive(options) {\n  return createDecorator(function (componentOptions, key) {\n    if (typeof componentOptions.inject === 'undefined') {\n      componentOptions.inject = {};\n    }\n\n    if (!Array.isArray(componentOptions.inject)) {\n      var fromKey_1 = !!options ? options.from || options : key;\n      var defaultVal_1 = !!options && options[\"default\"] || undefined;\n      if (!componentOptions.computed) componentOptions.computed = {};\n\n      componentOptions.computed[key] = function () {\n        var obj = this[reactiveInjectKey];\n        return obj ? obj[fromKey_1] : defaultVal_1;\n      };\n\n      componentOptions.inject[reactiveInjectKey] = reactiveInjectKey;\n    }\n  });\n}\n\nfunction produceProvide(original) {\n  var provide = function provide() {\n    var _this = this;\n\n    var rv = typeof original === 'function' ? original.call(this) : original;\n    rv = Object.create(rv || null); // set reactive services (propagates previous services if necessary)\n\n    rv[reactiveInjectKey] = this[reactiveInjectKey] || {};\n\n    for (var i in provide.managed) {\n      rv[provide.managed[i]] = this[i];\n    }\n\n    var _loop_1 = function _loop_1(i) {\n      rv[provide.managedReactive[i]] = this_1[i]; // Duplicates the behavior of `@Provide`\n\n      Object.defineProperty(rv[reactiveInjectKey], provide.managedReactive[i], {\n        enumerable: true,\n        get: function get() {\n          return _this[i];\n        }\n      });\n    };\n\n    var this_1 = this;\n\n    for (var i in provide.managedReactive) {\n      _loop_1(i);\n    }\n\n    return rv;\n  };\n\n  provide.managed = {};\n  provide.managedReactive = {};\n  return provide;\n}\n\nfunction needToProduceProvide(original) {\n  return typeof original !== 'function' || !original.managed && !original.managedReactive;\n}\n/**\n * decorator of a provide\n * @param key key\n * @return PropertyDecorator | void\n */\n\n\nexport function Provide(key) {\n  return createDecorator(function (componentOptions, k) {\n    var provide = componentOptions.provide;\n\n    if (needToProduceProvide(provide)) {\n      provide = componentOptions.provide = produceProvide(provide);\n    }\n\n    provide.managed[k] = key || k;\n  });\n}\n/**\n * decorator of a reactive provide\n * @param key key\n * @return PropertyDecorator | void\n */\n\nexport function ProvideReactive(key) {\n  return createDecorator(function (componentOptions, k) {\n    var provide = componentOptions.provide; // inject parent reactive services (if any)\n\n    if (!Array.isArray(componentOptions.inject)) {\n      componentOptions.inject = componentOptions.inject || {};\n      componentOptions.inject[reactiveInjectKey] = {\n        from: reactiveInjectKey,\n        \"default\": {}\n      };\n    }\n\n    if (needToProduceProvide(provide)) {\n      provide = componentOptions.provide = produceProvide(provide);\n    }\n\n    provide.managedReactive[k] = key || k;\n  });\n}\n/** @see {@link https://github.com/vuejs/vue-class-component/blob/master/src/reflect.ts} */\n\nvar reflectMetadataIsSupported = typeof Reflect !== 'undefined' && typeof Reflect.getMetadata !== 'undefined';\n\nfunction applyMetadata(options, target, key) {\n  if (reflectMetadataIsSupported) {\n    if (!Array.isArray(options) && typeof options !== 'function' && typeof options.type === 'undefined') {\n      var type = Reflect.getMetadata('design:type', target, key);\n\n      if (type !== Object) {\n        options.type = type;\n      }\n    }\n  }\n}\n/**\n * decorator of model\n * @param  event event name\n * @param options options\n * @return PropertyDecorator\n */\n\n\nexport function Model(event, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return function (target, key) {\n    applyMetadata(options, target, key);\n    createDecorator(function (componentOptions, k) {\n      ;\n      (componentOptions.props || (componentOptions.props = {}))[k] = options;\n      componentOptions.model = {\n        prop: k,\n        event: event || k\n      };\n    })(target, key);\n  };\n}\n/**\n * decorator of a prop\n * @param  options the options for the prop\n * @return PropertyDecorator | void\n */\n\nexport function Prop(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return function (target, key) {\n    applyMetadata(options, target, key);\n    createDecorator(function (componentOptions, k) {\n      ;\n      (componentOptions.props || (componentOptions.props = {}))[k] = options;\n    })(target, key);\n  };\n}\n/**\n * decorator of a synced prop\n * @param propName the name to interface with from outside, must be different from decorated property\n * @param options the options for the synced prop\n * @return PropertyDecorator | void\n */\n\nexport function PropSync(propName, options) {\n  if (options === void 0) {\n    options = {};\n  } // @ts-ignore\n\n\n  return function (target, key) {\n    applyMetadata(options, target, key);\n    createDecorator(function (componentOptions, k) {\n      ;\n      (componentOptions.props || (componentOptions.props = {}))[propName] = options;\n      (componentOptions.computed || (componentOptions.computed = {}))[k] = {\n        get: function get() {\n          return this[propName];\n        },\n        set: function set(value) {\n          // @ts-ignore\n          this.$emit(\"update:\" + propName, value);\n        }\n      };\n    })(target, key);\n  };\n}\n/**\n * decorator of a watch function\n * @param  path the path or the expression to observe\n * @param  WatchOption\n * @return MethodDecorator\n */\n\nexport function Watch(path, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _a = options.deep,\n      deep = _a === void 0 ? false : _a,\n      _b = options.immediate,\n      immediate = _b === void 0 ? false : _b;\n  return createDecorator(function (componentOptions, handler) {\n    if (_typeof(componentOptions.watch) !== 'object') {\n      componentOptions.watch = Object.create(null);\n    }\n\n    var watch = componentOptions.watch;\n\n    if (_typeof(watch[path]) === 'object' && !Array.isArray(watch[path])) {\n      watch[path] = [watch[path]];\n    } else if (typeof watch[path] === 'undefined') {\n      watch[path] = [];\n    }\n\n    watch[path].push({\n      handler: handler,\n      deep: deep,\n      immediate: immediate\n    });\n  });\n} // Code copied from Vue/src/shared/util.js\n\nvar hyphenateRE = /\\B([A-Z])/g;\n\nvar hyphenate = function hyphenate(str) {\n  return str.replace(hyphenateRE, '-$1').toLowerCase();\n};\n/**\n * decorator of an event-emitter function\n * @param  event The name of the event\n * @return MethodDecorator\n */\n\n\nexport function Emit(event) {\n  return function (_target, propertyKey, descriptor) {\n    var key = hyphenate(propertyKey);\n    var original = descriptor.value;\n\n    descriptor.value = function emitter() {\n      var _this = this;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var emit = function emit(returnValue) {\n        var emitName = event || key;\n\n        if (returnValue === undefined) {\n          if (args.length === 0) {\n            _this.$emit(emitName);\n          } else if (args.length === 1) {\n            _this.$emit(emitName, args[0]);\n          } else {\n            _this.$emit.apply(_this, [emitName].concat(args));\n          }\n        } else {\n          if (args.length === 0) {\n            _this.$emit(emitName, returnValue);\n          } else if (args.length === 1) {\n            _this.$emit(emitName, returnValue, args[0]);\n          } else {\n            _this.$emit.apply(_this, [emitName, returnValue].concat(args));\n          }\n        }\n      };\n\n      var returnValue = original.apply(this, args);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(emit);\n      } else {\n        emit(returnValue);\n      }\n\n      return returnValue;\n    };\n  };\n}\n/**\n * decorator of a ref prop\n * @param refKey the ref key defined in template\n */\n\nexport function Ref(refKey) {\n  return createDecorator(function (options, key) {\n    options.computed = options.computed || {};\n    options.computed[key] = {\n      cache: false,\n      get: function get() {\n        return this.$refs[refKey || key];\n      }\n    };\n  });\n}\n\nfunction isPromise(obj) {\n  return obj instanceof Promise || obj && typeof obj.then === 'function';\n}","map":null,"metadata":{},"sourceType":"module"}