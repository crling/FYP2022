{"ast":null,"code":"/**\n * Newick format parser in JavaScript.\n *\n * Copyright (c) Jason Davies 2010.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * Example tree (from http://en.wikipedia.org/wiki/Newick_format):\n *\n * +--0.1--A\n * F-----0.2-----B            +-------0.3----C\n * +------------------0.5-----E\n *                            +---------0.4------D\n *\n * Newick format:\n * (A:0.1,B:0.2,(C:0.3,D:0.4)E:0.5)F;\n *\n * Converted to JSON:\n * {\n *   name: \"F\",\n *   children: [\n *     {name: \"A\", length: 0.1},\n *     {name: \"B\", length: 0.2},\n *     {\n *       name: \"E\",\n *       length: 0.5,\n *       children: [\n *         {name: \"C\", length: 0.3},\n *         {name: \"D\", length: 0.4}\n *       ]\n *     }\n *   ]\n * }\n *\n * Converted to JSON, but with no names or lengths:\n * {\n *   children: [\n *     {}, {}, {\n *       children: [{}, {}]\n *     }\n *   ]\n * }\n */\nexport function parseNewick(s) {\n  var ancestors = [];\n  var tree = {};\n  var subtree;\n  var tokens = s.split(/\\s*(;|\\(|\\)|,|:)\\s*/);\n\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    switch (token) {\n      case \"(\":\n        // new children\n        subtree = {};\n        tree.children = [subtree];\n        ancestors.push(tree);\n        tree = subtree;\n        break;\n\n      case \",\":\n        // another branch\n        subtree = {};\n        ancestors[ancestors.length - 1].children.push(subtree);\n        tree = subtree;\n        break;\n\n      case \")\":\n        // optional name next\n        tree = ancestors.pop();\n        break;\n\n      case \":\":\n        // optional length next\n        break;\n\n      default:\n        var x = tokens[i - 1];\n\n        if (x === \")\" || x === \"(\" || x === \",\") {\n          tree.name = token;\n        } else if (x === \":\") {\n          tree.length = parseFloat(token);\n        }\n\n    }\n  }\n\n  return tree;\n}","map":null,"metadata":{},"sourceType":"module"}