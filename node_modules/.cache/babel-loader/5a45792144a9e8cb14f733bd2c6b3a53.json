{"ast":null,"code":"import Oviz from \"crux\";\nimport template from \"./template.bvt\";\nimport { register } from \"page/visualizers\";\nimport { getGroups } from \"utils/array\"; // import * as d3 from \"d3\";\n// import * as text_size from \"crux/dist/utils/text-size\";\n\n// import { editorConfig } from \"./editor\";\nimport { groupedChartColors } from \"oviz-common/palette\";\nimport { schemeSet1 } from \"d3-scale-chromatic\";\nvar ylabel = \"Relative abundance(log10)\";\nvar classifiedIndex = 0;\nvar valueRange = [2.5, 3.5];\nvar title = \"grouped box plot\";\nvar MODULE_NAME = \"hier-tree\";\n\nvar getDistinctValues = function getDistinctValues(arr) {\n  return arr.reduce(function (r, x) {\n    if (!r.includes(x)) r.push(x);\n    return r;\n  }, []);\n};\n\nvar leavesCount = 0;\n\nfunction assignCluster(treeNode, clusterDict) {\n  if (treeNode.children) {\n    var childrenCluters = treeNode.children.map(function (c) {\n      return assignCluster(c, clusterDict);\n    });\n    var distinctClusters = getDistinctValues(childrenCluters);\n\n    if (distinctClusters.length === 1 && distinctClusters[0] !== null) {\n      // treeNode.data = {cluster: dictinctClusters[0]}\n      treeNode.cluster = distinctClusters[0];\n      return distinctClusters[0];\n    } else {\n      return null;\n    }\n  } else {\n    leavesCount++;\n    return clusterDict[treeNode.name];\n  }\n}\n\nfunction init() {\n  if (!window.gon || window.gon.module_name !== MODULE_NAME) return;\n\n  var _Oviz$visualize = Oviz.visualize({\n    el: \"#canvas\",\n    template: template,\n    data: {\n      ylabel: ylabel,\n      valueRange: valueRange,\n      title: title,\n      config: {\n        plotWidth: 1000,\n        showOutliers: true,\n        xLabelRotation: 45\n      },\n      colors: {\n        naColor: \"#aaa\"\n      },\n      gridSize: 10\n    },\n    loadData: {\n      hierTreeData: {\n        fileKey: \"hierTreeData\",\n        type: \"newick\",\n        dependsOn: [\"hierClusterData\"],\n        loaded: function loaded(data) {\n          assignCluster(data, this.data.clusterDict);\n          return data;\n        }\n      },\n      hierClusterData: {\n        fileKey: \"hierClusterData\",\n        type: \"tsv\",\n        loaded: function loaded(data) {\n          var _this = this;\n\n          this.data.clusterDict = {};\n          this.data.clusters = getGroups(data, data.columns[1]);\n          this.data.colorMap = {};\n          this.data.clusterLegendData = [];\n          this.data.clusters.forEach(function (c, i) {\n            _this.data.colorMap[c] = groupedChartColors[i];\n\n            _this.data.clusterLegendData.push({\n              label: c,\n              fill: groupedChartColors[i]\n            });\n          });\n          data.forEach(function (x) {\n            _this.data.clusterDict[x[data.columns[0]]] = x[data.columns[1]];\n          });\n          return null;\n        }\n      },\n      hierGroupData: {\n        fileKey: \"hierGroupData\",\n        type: \"tsv\",\n        loaded: function loaded(data) {\n          var _this2 = this;\n\n          this.data.groupDict = {};\n          this.data.groups = getGroups(data, data.columns[1]);\n          this.data.groupColorMap = {};\n          this.data.groupLegendData = [];\n          this.data.groups.forEach(function (g, i) {\n            _this2.data.groupColorMap[g] = schemeSet1[i];\n\n            _this2.data.groupLegendData.push({\n              label: g,\n              fill: schemeSet1[i]\n            });\n          });\n          data.forEach(function (x) {\n            _this2.data.groupDict[x[data.columns[0]]] = x[data.columns[1]];\n          });\n          return null;\n        }\n      }\n    },\n    setup: function setup() {\n      this.data.treeWidth = 15 * leavesCount;\n      this.size.width = 15 * leavesCount + 100; // registerEditorConfig(editorConfig(this));\n    }\n  }),\n      visualizer = _Oviz$visualize.visualizer;\n\n  return visualizer;\n}\n\nregister(MODULE_NAME, init);\nexport function registerHierTree() {\n  register(MODULE_NAME, init);\n}","map":{"version":3,"sources":["/Users/wangzhenyu/Desktop/fyp_workspace/meta_platform/app/javascript/viz/hier-tree/index.ts"],"names":["Oviz","template","register","getGroups","groupedChartColors","schemeSet1","ylabel","classifiedIndex","valueRange","title","MODULE_NAME","getDistinctValues","arr","reduce","r","x","includes","push","leavesCount","assignCluster","treeNode","clusterDict","children","childrenCluters","map","c","distinctClusters","length","cluster","name","init","window","gon","module_name","visualize","el","data","config","plotWidth","showOutliers","xLabelRotation","colors","naColor","gridSize","loadData","hierTreeData","fileKey","type","dependsOn","loaded","hierClusterData","clusters","columns","colorMap","clusterLegendData","forEach","i","label","fill","hierGroupData","groupDict","groups","groupColorMap","groupLegendData","g","setup","treeWidth","size","width","visualizer","registerHierTree"],"mappings":"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","sourcesContent":["import Oviz from \"crux\"\nimport template from \"./template.bvt\"\nimport {register} from \"page/visualizers\";\nimport { getGroups} from \"utils/array\";\n// import * as d3 from \"d3\";\n// import * as text_size from \"crux/dist/utils/text-size\";\nimport {findBoundsForValues} from \"utils/maths\";\n\nimport { registerEditorConfig } from \"utils/editor\";\n// import { editorConfig } from \"./editor\";\nimport { groupedChartColors} from \"oviz-common/palette\"\nimport { schemeSet1, schemeSet2, schemeSet3 } from \"d3-scale-chromatic\";\n\nconst ylabel = \"Relative abundance(log10)\";\nconst classifiedIndex = 0;\nconst valueRange = [2.5, 3.5];\nconst title = \"grouped box plot\"\n\nconst MODULE_NAME = \"hier-tree\";\n\ninterface BoxplotData {\n    values: any[], \n    outliers: any[], \n    means: number[],\n}\nconst getDistinctValues = (arr) => {\n    return arr.reduce((r, x) => {\n        if (!r.includes(x)) r.push(x);\n        return r;\n        }, []);\n}\nlet leavesCount = 0;\n\nfunction assignCluster(treeNode, clusterDict) {\n    if (treeNode.children) {\n        const childrenCluters = treeNode.children.map(c => assignCluster(c, clusterDict));\n        const distinctClusters = getDistinctValues(childrenCluters);\n        if (distinctClusters.length === 1 && distinctClusters[0] !== null) {\n            // treeNode.data = {cluster: dictinctClusters[0]}\n            treeNode.cluster = distinctClusters[0];\n            return distinctClusters[0];\n        } else {\n            return null;\n        }\n    } else {\n        leavesCount ++;\n        return clusterDict[treeNode.name];\n    }\n}\nfunction init() {\n    if (!window.gon || window.gon.module_name !== MODULE_NAME) return;\n\n    const {visualizer} = Oviz.visualize({\n        el: \"#canvas\",\n        template,\n        data: {ylabel, valueRange, title,\n            config: {\n                plotWidth: 1000,\n                showOutliers: true,\n                xLabelRotation: 45,\n            },\n            colors: {\n                naColor: \"#aaa\",\n            },\n            gridSize: 10,\n        },\n        loadData: {\n            hierTreeData: {\n                fileKey: \"hierTreeData\",\n                type: \"newick\",\n                dependsOn: [\"hierClusterData\"],\n                loaded(data) {\n                    assignCluster(data, this.data.clusterDict);\n                    return data;\n                },\n            },\n            hierClusterData: {\n                fileKey: \"hierClusterData\",\n                type: \"tsv\",\n                loaded(data) {\n                    this.data.clusterDict = {};\n                    this.data.clusters = getGroups(data, data.columns[1]);\n                    this.data.colorMap = {};\n                    this.data.clusterLegendData = [];\n                    this.data.clusters.forEach((c, i) => {\n                        this.data.colorMap[c] = groupedChartColors[i];\n                        this.data.clusterLegendData.push({label: c, fill: groupedChartColors[i]});\n                    });\n                    data.forEach(x => {\n                        this.data.clusterDict[x[data.columns[0]]] = x[data.columns[1]];\n                    });\n                    return null;\n                }\n            },\n            hierGroupData: {\n                fileKey: \"hierGroupData\",\n                type: \"tsv\",\n                loaded(data) {\n                    this.data.groupDict = {};\n                    this.data.groups = getGroups(data, data.columns[1]);\n                    this.data.groupColorMap = {};\n                    this.data.groupLegendData = [];\n                    this.data.groups.forEach((g, i) => {\n                        this.data.groupColorMap[g] = schemeSet1[i];\n                        this.data.groupLegendData.push({label: g, fill: schemeSet1[i]});\n                    });\n                    \n                    data.forEach(x => {\n                        \n                        this.data.groupDict[x[data.columns[0]]] = x[data.columns[1]];\n                    });\n                    return null;\n                }\n            }\n        },\n        setup() {            \n            this.data.treeWidth = 15 * leavesCount;\n            this.size.width = 15 * leavesCount + 100;\n            // registerEditorConfig(editorConfig(this));\n        },\n    });\n    \n    return visualizer;\n}\n\nregister(MODULE_NAME, init);\n\nexport function registerHierTree() {\n    register(MODULE_NAME, init);\n}"]},"metadata":{},"sourceType":"module"}