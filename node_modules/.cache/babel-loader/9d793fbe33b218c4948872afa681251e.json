{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\", \"\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (typeof call === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport Oviz from \"crux\";\nimport { Component } from \"crux/dist/element\";\nimport template from \"./scatter.bvt\";\nexport var ComplexScatterplot = /*#__PURE__*/function (_Component) {\n  _inherits(ComplexScatterplot, _Component);\n\n  var _super = _createSuper(ComplexScatterplot);\n\n  function ComplexScatterplot() {\n    var _this;\n\n    _classCallCheck(this, ComplexScatterplot);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.dataChanged = true;\n    _this.rankChanged = void 0;\n    _this.axisChanged = void 0;\n    _this.config = void 0;\n    _this.colors = void 0;\n    _this.ranks = void 0;\n    _this.availableAxises = void 0;\n    _this.scatterData = void 0;\n    _this.scatterVectorData = void 0;\n    _this.vectorLabel = void 0;\n    _this.groups = void 0;\n    _this.clusters = void 0;\n    _this.mainDict = void 0;\n    _this.clusterDict = void 0;\n    _this.sampleInfoDict = void 0;\n    _this.markedScatter = void 0;\n    _this.markedLines = [{\n      x: 0,\n      dashArray: \"1,2\",\n      stroke: \"#aaa\"\n    }, {\n      y: 0,\n      dashArray: \"1,2\",\n      stroke: \"#aaa\"\n    }];\n    _this.render = Oviz.t(_templateObject(), template);\n    return _this;\n  }\n\n  _createClass(ComplexScatterplot, [{\n    key: \"computeErrorEllipse\",\n    // public willRender() {\n    //     // \n    //     if (this._firstRender) {\n    //         this.scatterData = this.prop.data;\n    //         this.hiddenSamples = this.prop.hiddenSamples;\n    //     }\n    // }\n\n    /*\n        willRender() {\n            if (this._firstRender) {\n                this.legend1Pos = {x: 45, y: 115};\n                this.legend2Pos = {x: 45, y: 55};\n                const shapes = [\"Circle\", \"Rect\", \"Triangle\"];\n                if (this.clusters) {\n                    this.colorMap = this.getMap(this.clusters, this.colors);\n                    if (this.groups) {\n                        this.shapeMap = this.getMap(this.groups, shapes);\n                        this.groupLegendData = this.groups.map((x, i) => {\n                            return {type: \"custom\", label: x, fill: \"grey\"};\n                        });\n                    }\n                } else if (this.groups) {\n                    this.colorMap = this.getMap(this.groups, this.colors);\n                    this.groupLegendData = this.groups.map((x, i) => {\n                        return {type: \"custom\", label: x, fill: this.colors[i]}\n                    });\n                }\n            }\n    \n            if (this.rankChanged) {\n                this.rankLabel = this.ranks[this.config.rankIndex].text;\n                this.scatterData = this.mainDict[this.rankLabel];\n                this.availableAxises = this.scatterData.columns.filter((_, i) => i > 0)\n                                    .map((x, i) => ({\"value\": i, \"text\": x}));\n                this.config.xAxisIndex = editorRef.xAxis.value = 0;\n                this.config.yAxisIndex = editorRef.yAxis.value = 1;\n    \n                editorRef.xAxis.config.options = editorRef.yAxis.config.options = this.availableAxises;\n    \n                this.rankChanged = false;\n            }\n    \n            if (this._firstRender || this.dataChanged) {\n                this.xLabel = this.availableAxises[this.config.xAxisIndex].text;\n                if (this.config.yAxisIndex === 1 && this.availableAxises.length === 1){\n                    this.yLabel = this.availableAxises[0].text;\n                    this.config.yAxisIndex = 0;\n                }\n    \n                this.yLabel = this.availableAxises[this.config.yAxisIndex].text;\n                this.parsedScatterData = this.scatterData.map((d, i) => {\n                    const datum = {sampleId: d.sampleId, \n                        group: this.sampleInfoDict[d.sampleId].group,\n                        cluster: this.clusterDict ? this.clusterDict[d.sampleId][this.rankLabel] :null};\n                    datum[this.xLabel] = d[this.xLabel];\n                    datum[this.yLabel] = d[this.yLabel];\n                    return datum;\n                });\n    \n                if (this.clusters) {\n                    this.categoryRange = this.rangeIsValid(this.config.categoryRange) ?  this.config.categoryRange\n                        : findBoundsForValues(this.scatterData.map(d => d[this.xLabel]), 1, false, 0.1);\n                    this.valueRange = this.rangeIsValid(this.config.valueRange) ? this.config.valueRange\n                        : findBoundsForValues(this.scatterData.map(d => d[this.yLabel]), 1, false, 0.1);\n                } else {\n                    this.categoryRange = this.rangeIsValid(this.config.categoryRange) ?  this.config.categoryRange\n                    : findBoundsForValues(this.scatterData.map(d => d[this.xLabel]), 1);\n                    this.valueRange = this.rangeIsValid(this.config.valueRange) ? this.config.valueRange\n                        : findBoundsForValues(this.scatterData.map(d => d[this.yLabel]), 1);\n                }\n    \n                const svgRatioX = this.config.plotWidth / (this.categoryRange[1] - this.categoryRange[0]);\n                const svgRatioY = this.config.plotHeight / (this.valueRange[1] - this.valueRange[0]);\n    \n                if (this.clusters) {\n                    const parsedData = {};\n                    this.clusters.forEach(key => {\n                        const initialData = this.parsedScatterData.filter(x => x.cluster === key);\n                        const clusterDatum = this.computeErrorEllipse(initialData, this.xLabel, this.yLabel,\n                            svgRatioX, svgRatioY);\n                        parsedData[key] = clusterDatum;\n                    });\n                    this.parsedClusterData = parsedData;\n                }\n                if (this.clusters) {\n                    this.colorMap = this.getMap(this.clusters, this.colors);\n                } else if (this.groups) {\n                    this.colorMap = this.getMap(this.groups, this.colors);\n                }\n                this.dataChanged = false;\n            }\n        }\n    */\n    // 这个是旧的椭圆算法\n    value: function computeErrorEllipse(samples, xIndex, yIndex, svgRatioX, svgRatioY) {\n      var ellipseData = {\n        cx: 0,\n        cy: 0,\n        rx: 0,\n        ry: 0,\n        rotationAngle: 0\n      };\n      var s = 5.991;\n      var statX = new Oviz.algo.Statistics(samples.map(function (x) {\n        return x[xIndex];\n      }));\n      var statY = new Oviz.algo.Statistics(samples.map(function (y) {\n        return y[yIndex];\n      }));\n      ellipseData.cx = statX.mean();\n      ellipseData.cy = statY.mean();\n      var varX = 0,\n          varY = 0,\n          cov = 0;\n      samples.forEach(function (d) {\n        varX += Math.pow((d[xIndex] - statX.mean()) * svgRatioX, 2) / (samples.length - 1);\n        varY += Math.pow((d[yIndex] - statY.mean()) * svgRatioY, 2) / (samples.length - 1);\n        cov += (d[xIndex] - statX.mean()) * svgRatioX * (d[yIndex] - statY.mean()) * svgRatioY / (samples.length - 1);\n      });\n      var eParams = {\n        a: 1,\n        b: -(varX + varY),\n        c: varX * varY - Math.pow(cov, 2)\n      };\n      var eigenValue1 = (-eParams.b + Math.sqrt(Math.pow(eParams.b, 2) - 4 * eParams.a * eParams.c)) / (2 * eParams.a);\n      var eigenValue2 = (-eParams.b - Math.sqrt(Math.pow(eParams.b, 2) - 4 * eParams.a * eParams.c)) / (2 * eParams.a);\n      ellipseData.rx = Math.sqrt(s * Math.abs(eigenValue1));\n      ellipseData.ry = Math.sqrt(s * Math.abs(eigenValue2));\n      var rotationRad = Math.atan((varX - eigenValue1) / cov);\n      ellipseData.rotationAngle = rotationRad * 180 / Math.PI;\n      var triFunctions = {\n        sin: function sin(r) {\n          return r * Math.sin(rotationRad);\n        },\n        cos: function cos(r) {\n          return r * Math.cos(rotationRad);\n        }\n      };\n      var dx = triFunctions.cos(ellipseData.rx);\n      var dy = triFunctions.sin(ellipseData.rx);\n      var ellipsePath = \"M 0 0\\n                    A \".concat(ellipseData.rx, \" \").concat(ellipseData.ry, \" \").concat(ellipseData.rotationAngle, \" 0 1 \").concat(2 * dx, \" \").concat(2 * dy, \"\\n                    A \").concat(ellipseData.rx, \" \").concat(ellipseData.ry, \" \").concat(ellipseData.rotationAngle, \" 0 1 0 0 Z\");\n      var center = {\n        x: statX.mean(),\n        y: statY.mean()\n      };\n      var ellipseDatum = {\n        dx: dx,\n        dy: dy,\n        ellipsePath: ellipsePath,\n        xAxisPath: \"M 0 0 L \".concat(2 * dx, \" \").concat(2 * dy),\n        yAxisPath: \"M \".concat(dx - triFunctions.sin(ellipseData.ry), \" \").concat(dy + triFunctions.cos(ellipseData.ry), \"\\n            L \").concat(dx + triFunctions.sin(ellipseData.ry), \" \").concat(dy - triFunctions.cos(ellipseData.ry))\n      };\n      return {\n        center: center,\n        ellipseData: ellipseDatum\n      };\n    }\n  }, {\n    key: \"markScatter\",\n    value: function markScatter(d) {\n      if (d.data.sampleId === this.markedScatter) {\n        this.markedScatter = null;\n        this.redraw();\n      } else {\n        this.markedScatter = d.data.sampleId;\n        this.markedLines[0].x = d.pos;\n        this.markedLines[1].y = d.value;\n        this.$v.forceRedraw = true;\n        this.redraw();\n      }\n    }\n  }, {\n    key: \"hideScatter\",\n    value: function hideScatter(d) {\n      var result = confirm(\"You want to hide \".concat(d.data.sampleId, \"?\"));\n\n      if (result) {\n        if (d.data.sampleId === this.markedScatter) {\n          this.markedScatter = null;\n        }\n\n        d.data.show = false;\n        this.redraw();\n      }\n    }\n  }, {\n    key: \"generateScatterContent\",\n    value: function generateScatterContent(scatter) {\n      return Object.keys(scatter).reduce(function (acc, cur) {\n        if (!!scatter[cur]) {\n          if (typeof scatter[cur] === \"number\") return acc + \"\".concat(cur, \": \").concat(scatter[cur].toFixed(3), \"<br>\");else return acc + \"\".concat(cur, \": \").concat(scatter[cur], \"<br>\");\n        } else return acc;\n      }, \"\");\n    }\n  }, {\n    key: \"getMap\",\n    value: function getMap(keyArray, valueArray) {\n      var map = new Map();\n      keyArray.forEach(function (key, i) {\n        map.set(key, valueArray[i]);\n      });\n      return map;\n    }\n  }, {\n    key: \"defaultProp\",\n    value: function defaultProp() {\n      return _objectSpread(_objectSpread({}, _get(_getPrototypeOf(ComplexScatterplot.prototype), \"defaultProp\", this)), {}, {\n        scatterSize: 8,\n        flip: false,\n        hollow: false\n      });\n    }\n  }]);\n\n  return ComplexScatterplot;\n}(Component); // export function processRawData(data: any[], xLabel: string, yLabel: string): ScatterData {\n//     const result = {valueRange: null, categoryRange: null, data: null, xLabel, yLabel};\n//     data.forEach()\n//     return result;\n// }","map":{"version":3,"sources":["/Users/wangzhenyu/Desktop/fyp_workspace/meta_platform/app/javascript/oviz-components/complex-scatterplot.ts"],"names":["Oviz","Component","template","ComplexScatterplot","dataChanged","rankChanged","axisChanged","config","colors","ranks","availableAxises","scatterData","scatterVectorData","vectorLabel","groups","clusters","mainDict","clusterDict","sampleInfoDict","markedScatter","markedLines","x","dashArray","stroke","y","render","t","samples","xIndex","yIndex","svgRatioX","svgRatioY","ellipseData","cx","cy","rx","ry","rotationAngle","s","statX","algo","Statistics","map","statY","mean","varX","varY","cov","forEach","d","Math","pow","length","eParams","a","b","c","eigenValue1","sqrt","eigenValue2","abs","rotationRad","atan","PI","triFunctions","sin","r","cos","dx","dy","ellipsePath","center","ellipseDatum","xAxisPath","yAxisPath","data","sampleId","redraw","pos","value","$v","forceRedraw","result","confirm","show","scatter","Object","keys","reduce","acc","cur","toFixed","keyArray","valueArray","Map","key","i","set","scatterSize","flip","hollow"],"mappings":"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","sourcesContent":["import Oviz from \"crux\";\nimport { Component } from \"crux/dist/element\";\nimport { findBoundsForValues } from \"utils/maths\";\nimport { GridPlotOption } from \"./grid-plot\";\nimport template from \"./scatter.bvt\";\n\nexport interface ErrorEllipseDatum {\n    dx: number;\n    dy: number;\n    ellipsePath: string;\n    xAxisPath: string;\n    yAxisPath: string;\n}\n\nexport interface ScatterClusterDatum {\n    center: {x, y};\n    ellipseData: ErrorEllipseDatum;\n}\n\nexport interface ComplextScatterplotOption extends GridPlotOption {\n    hollow: boolean;\n    scatterSize: number;\n    hiddenSamples: Set<string>;\n    scatterFill?: string;\n    scatterStroke?: string;\n    generateTooltip: (d) => string;\n}\nexport class ComplexScatterplot extends Component<ComplextScatterplotOption> {\n\n    public dataChanged: boolean = true;\n    public rankChanged: boolean;\n    public axisChanged: boolean;\n    public config: any;\n    public colors: string;\n\n    public ranks: Array<{ value: string; text: string }>;\n    public availableAxises: Array<{ value: string; text: string }>;\n\n    protected scatterData: any;\n    public scatterVectorData: any[];\n    public vectorLabel: string;\n    public groups: string[];\n    public clusters: string[];\n\n    public mainDict: Record<string, any>;\n    public clusterDict;\n    public sampleInfoDict: any;\n\n    private markedScatter: string;\n\n    private markedLines: [any, any] = [\n        { x: 0, dashArray: \"1,2\", stroke: \"#aaa\"},\n        { y: 0, dashArray: \"1,2\", stroke: \"#aaa\"},\n    ];\n\n    // private _dataChanged = true;\n\n    public render = Oviz.t`${template}`;\n\n    // public willRender() {\n    //     // \n    //     if (this._firstRender) {\n    //         this.scatterData = this.prop.data;\n    //         this.hiddenSamples = this.prop.hiddenSamples;\n    //     }\n    // }\n/*\n    willRender() {\n        if (this._firstRender) {\n            this.legend1Pos = {x: 45, y: 115};\n            this.legend2Pos = {x: 45, y: 55};\n            const shapes = [\"Circle\", \"Rect\", \"Triangle\"];\n            if (this.clusters) {\n                this.colorMap = this.getMap(this.clusters, this.colors);\n                if (this.groups) {\n                    this.shapeMap = this.getMap(this.groups, shapes);\n                    this.groupLegendData = this.groups.map((x, i) => {\n                        return {type: \"custom\", label: x, fill: \"grey\"};\n                    });\n                }\n            } else if (this.groups) {\n                this.colorMap = this.getMap(this.groups, this.colors);\n                this.groupLegendData = this.groups.map((x, i) => {\n                    return {type: \"custom\", label: x, fill: this.colors[i]}\n                });\n            }\n        }\n\n        if (this.rankChanged) {\n            this.rankLabel = this.ranks[this.config.rankIndex].text;\n            this.scatterData = this.mainDict[this.rankLabel];\n            this.availableAxises = this.scatterData.columns.filter((_, i) => i > 0)\n                                .map((x, i) => ({\"value\": i, \"text\": x}));\n            this.config.xAxisIndex = editorRef.xAxis.value = 0;\n            this.config.yAxisIndex = editorRef.yAxis.value = 1;\n\n            editorRef.xAxis.config.options = editorRef.yAxis.config.options = this.availableAxises;\n\n            this.rankChanged = false;\n        }\n\n        if (this._firstRender || this.dataChanged) {\n            this.xLabel = this.availableAxises[this.config.xAxisIndex].text;\n            if (this.config.yAxisIndex === 1 && this.availableAxises.length === 1){\n                this.yLabel = this.availableAxises[0].text;\n                this.config.yAxisIndex = 0;\n            }\n\n            this.yLabel = this.availableAxises[this.config.yAxisIndex].text;\n            this.parsedScatterData = this.scatterData.map((d, i) => {\n                const datum = {sampleId: d.sampleId, \n                    group: this.sampleInfoDict[d.sampleId].group,\n                    cluster: this.clusterDict ? this.clusterDict[d.sampleId][this.rankLabel] :null};\n                datum[this.xLabel] = d[this.xLabel];\n                datum[this.yLabel] = d[this.yLabel];\n                return datum;\n            });\n\n            if (this.clusters) {\n                this.categoryRange = this.rangeIsValid(this.config.categoryRange) ?  this.config.categoryRange\n                    : findBoundsForValues(this.scatterData.map(d => d[this.xLabel]), 1, false, 0.1);\n                this.valueRange = this.rangeIsValid(this.config.valueRange) ? this.config.valueRange\n                    : findBoundsForValues(this.scatterData.map(d => d[this.yLabel]), 1, false, 0.1);\n            } else {\n                this.categoryRange = this.rangeIsValid(this.config.categoryRange) ?  this.config.categoryRange\n                : findBoundsForValues(this.scatterData.map(d => d[this.xLabel]), 1);\n                this.valueRange = this.rangeIsValid(this.config.valueRange) ? this.config.valueRange\n                    : findBoundsForValues(this.scatterData.map(d => d[this.yLabel]), 1);\n            }\n\n            const svgRatioX = this.config.plotWidth / (this.categoryRange[1] - this.categoryRange[0]);\n            const svgRatioY = this.config.plotHeight / (this.valueRange[1] - this.valueRange[0]);\n\n            if (this.clusters) {\n                const parsedData = {};\n                this.clusters.forEach(key => {\n                    const initialData = this.parsedScatterData.filter(x => x.cluster === key);\n                    const clusterDatum = this.computeErrorEllipse(initialData, this.xLabel, this.yLabel,\n                        svgRatioX, svgRatioY);\n                    parsedData[key] = clusterDatum;\n                });\n                this.parsedClusterData = parsedData;\n            }\n            if (this.clusters) {\n                this.colorMap = this.getMap(this.clusters, this.colors);\n            } else if (this.groups) {\n                this.colorMap = this.getMap(this.groups, this.colors);\n            }\n            this.dataChanged = false;\n        }\n    }\n*/\n\n// 这个是旧的椭圆算法\n    protected computeErrorEllipse(samples, xIndex, yIndex, svgRatioX, svgRatioY): ScatterClusterDatum {\n        const ellipseData = {cx: 0, cy: 0, rx: 0, ry: 0, rotationAngle: 0};\n        const s = 5.991;\n        const statX = new Oviz.algo.Statistics(samples.map(x => x[xIndex]));\n        const statY = new Oviz.algo.Statistics(samples.map(y => y[yIndex]));\n\n        ellipseData.cx =  statX.mean();\n        ellipseData.cy = statY.mean();\n\n        let varX = 0, varY = 0, cov = 0;\n        samples.forEach(d => {\n            varX += Math.pow( (d[xIndex] - statX.mean()) * svgRatioX, 2) / (samples.length - 1);\n            varY += Math.pow( (d[yIndex] - statY.mean()) * svgRatioY, 2) / (samples.length - 1);\n            cov += (d[xIndex] - statX.mean()) * svgRatioX * (d[yIndex] - statY.mean()) * svgRatioY / (samples.length - 1);\n        });\n\n        const eParams = {a: 1, b: -(varX + varY), c: varX * varY - Math.pow(cov, 2)};\n        const eigenValue1 = (-eParams.b + Math.sqrt(Math.pow(eParams.b, 2) - 4 * eParams.a * eParams.c)) / (2 * eParams.a);\n        const eigenValue2 = (-eParams.b - Math.sqrt(Math.pow(eParams.b, 2) - 4 * eParams.a * eParams.c)) / (2 * eParams.a );\n        ellipseData.rx = Math.sqrt(s * Math.abs(eigenValue1));\n        ellipseData.ry = Math.sqrt(s * Math.abs(eigenValue2));\n\n        const rotationRad = Math.atan((varX - eigenValue1) / cov);\n        ellipseData.rotationAngle  = rotationRad * 180 / Math.PI;\n        const triFunctions = {\n            sin(r) { return r * Math.sin(rotationRad); },\n            cos(r) { return r * Math.cos(rotationRad); },\n        };\n        const dx = triFunctions.cos(ellipseData.rx);\n        const dy = triFunctions.sin(ellipseData.rx);\n        const ellipsePath = `M 0 0\n                    A ${ellipseData.rx} ${ellipseData.ry} ${ellipseData.rotationAngle} 0 1 ${2 * dx} ${2 * dy}\n                    A ${ellipseData.rx} ${ellipseData.ry} ${ellipseData.rotationAngle} 0 1 0 0 Z`;\n        const center = {x: statX.mean(), y: statY.mean()};\n        const ellipseDatum = {\n            dx,\n            dy,\n            ellipsePath,\n            xAxisPath: `M 0 0 L ${2 * dx} ${2 * dy}`,\n            yAxisPath: `M ${dx - triFunctions.sin(ellipseData.ry)} ${dy + triFunctions.cos(ellipseData.ry)}\n            L ${dx + triFunctions.sin(ellipseData.ry)} ${dy - triFunctions.cos(ellipseData.ry)}`,\n        };\n        return {center, ellipseData: ellipseDatum};\n    }\n\n    protected markScatter(d) {\n        if (d.data.sampleId === this.markedScatter) {\n            this.markedScatter = null;\n            this.redraw();\n        } else {\n            this.markedScatter = d.data.sampleId;\n            this.markedLines[0].x = d.pos;\n            this.markedLines[1].y = d.value;\n            this.$v.forceRedraw = true;\n            this.redraw();\n        }\n    }\n\n    protected hideScatter(d) {\n        const result = confirm(`You want to hide ${d.data.sampleId}?`);\n        if (result) {\n            if (d.data.sampleId === this.markedScatter) {\n                this.markedScatter = null;\n            }\n            d.data.show = false;\n            this.redraw();\n        }\n    }\n\n    protected generateScatterContent(scatter) {\n        return Object.keys(scatter)\n                     .reduce(((acc, cur) => {\n                        if (!!scatter[cur])\n                            if (typeof scatter[cur] === \"number\")\n                                return acc + `${cur}: ${scatter[cur].toFixed(3)}<br>`;\n                            else\n                                return acc + `${cur}: ${scatter[cur]}<br>`;\n                        else return acc;\n                }), \"\");\n    }\n\n    protected getMap(keyArray, valueArray) {\n        const map = new Map();\n        keyArray.forEach((key, i) => {\n            map.set(key, valueArray[i]);\n        });\n        return map;\n    }\n\n    public defaultProp() {\n        return {\n            ...super.defaultProp,\n            scatterSize: 8,\n            flip: false,\n            hollow: false,\n        };\n    }\n}\n\ntype ScatterData = {\n    valueRange: [number, number],\n    categoryRange: [number, number],\n    data: any[],\n    xLabel: string,\n    yLabel: string,\n}\n// export function processRawData(data: any[], xLabel: string, yLabel: string): ScatterData {\n//     const result = {valueRange: null, categoryRange: null, data: null, xLabel, yLabel};\n//     data.forEach()\n//     return result;\n\n// }"]},"metadata":{},"sourceType":"module"}