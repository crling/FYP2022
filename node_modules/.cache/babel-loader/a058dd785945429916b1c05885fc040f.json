{"ast":null,"code":"function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\", \"\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (typeof call === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport Oviz from \"crux\";\nimport { Component } from \"crux/dist/element\";\nimport { findBoundsForValues } from \"utils/maths\";\nimport template from \"./template.bvt\";\nimport { editorRef } from \"./editor\";\nexport var ComplexScatterplotBk = /*#__PURE__*/function (_Component) {\n  _inherits(ComplexScatterplotBk, _Component);\n\n  var _super = _createSuper(ComplexScatterplotBk);\n\n  function ComplexScatterplotBk() {\n    var _this;\n\n    _classCallCheck(this, ComplexScatterplotBk);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.dataChanged = true;\n    _this.rankChanged = void 0;\n    _this.axisChanged = void 0;\n    _this.config = void 0;\n    _this.colors = void 0;\n    _this.ranks = void 0;\n    _this.availableAxises = void 0;\n    _this.scatterData = void 0;\n    _this.scatterVectorData = void 0;\n    _this.vectorLabel = void 0;\n    _this.groups = void 0;\n    _this.clusters = void 0;\n    _this.mainDict = void 0;\n    _this.clusterDict = void 0;\n    _this.sampleInfoDict = void 0;\n    _this.parsedScatterData = void 0;\n    _this.parsedClusterData = void 0;\n    _this.rankLabel = void 0;\n    _this.xLabel = void 0;\n    _this.categoryRange = void 0;\n    _this.yLabel = void 0;\n    _this.valueRange = void 0;\n    _this.groupLegendData = void 0;\n    _this.shapeMap = void 0;\n    _this.colorMap = void 0;\n    _this.legend2Pos = void 0;\n    _this.legend1Pos = void 0;\n    _this.render = Oviz.t(_templateObject(), template);\n    return _this;\n  }\n\n  _createClass(ComplexScatterplotBk, [{\n    key: \"willRender\",\n    value: function willRender() {\n      var _this2 = this;\n\n      if (this._firstRender) {\n        this.legend1Pos = {\n          x: 45,\n          y: 115\n        };\n        this.legend2Pos = {\n          x: 45,\n          y: 55\n        };\n        var shapes = [\"Circle\", \"Rect\", \"Triangle\"];\n\n        if (this.clusters) {\n          this.colorMap = this.getMap(this.clusters, this.colors);\n\n          if (this.groups) {\n            this.shapeMap = this.getMap(this.groups, shapes);\n            this.groupLegendData = this.groups.map(function (x, i) {\n              return {\n                type: \"Custom\",\n                label: x,\n                fill: \"grey\"\n              };\n            });\n          }\n        } else if (this.groups) {\n          this.colorMap = this.getMap(this.groups, this.colors);\n          this.groupLegendData = this.groups.map(function (x, i) {\n            return {\n              type: \"Custom\",\n              label: x,\n              fill: _this2.colors[i]\n            };\n          });\n        }\n      }\n\n      if (this.rankChanged) {\n        this.rankLabel = this.ranks[this.config.rankIndex].text;\n        this.scatterData = this.mainDict[this.rankLabel];\n        this.availableAxises = this.scatterData.columns.filter(function (_, i) {\n          return i > 0;\n        }).map(function (x, i) {\n          return {\n            \"value\": i,\n            \"text\": x\n          };\n        });\n        this.config.xAxisIndex = editorRef.xAxis.value = 0;\n        this.config.yAxisIndex = editorRef.yAxis.value = 1;\n        editorRef.xAxis.config.options = editorRef.yAxis.config.options = this.availableAxises;\n        this.rankChanged = false;\n      }\n\n      if (this._firstRender || this.dataChanged) {\n        this.xLabel = this.availableAxises[this.config.xAxisIndex].text;\n\n        if (this.config.yAxisIndex === 1 && this.availableAxises.length === 1) {\n          this.yLabel = this.availableAxises[0].text;\n          this.config.yAxisIndex = 0;\n        }\n\n        this.yLabel = this.availableAxises[this.config.yAxisIndex].text;\n        this.parsedScatterData = this.scatterData.map(function (d, i) {\n          var datum = {\n            sampleId: d.sampleId,\n            group: _this2.sampleInfoDict[d.sampleId].group,\n            cluster: _this2.clusterDict ? _this2.clusterDict[d.sampleId][_this2.rankLabel] : null\n          };\n          datum[_this2.xLabel] = d[_this2.xLabel];\n          datum[_this2.yLabel] = d[_this2.yLabel];\n          return datum;\n        });\n\n        if (this.clusters) {\n          this.categoryRange = this.rangeIsValid(this.config.categoryRange) ? this.config.categoryRange : findBoundsForValues(this.scatterData.map(function (d) {\n            return d[_this2.xLabel];\n          }), 1, false, 0.1);\n          this.valueRange = this.rangeIsValid(this.config.valueRange) ? this.config.valueRange : findBoundsForValues(this.scatterData.map(function (d) {\n            return d[_this2.yLabel];\n          }), 1, false, 0.1);\n        } else {\n          this.categoryRange = this.rangeIsValid(this.config.categoryRange) ? this.config.categoryRange : findBoundsForValues(this.scatterData.map(function (d) {\n            return d[_this2.xLabel];\n          }), 1);\n          this.valueRange = this.rangeIsValid(this.config.valueRange) ? this.config.valueRange : findBoundsForValues(this.scatterData.map(function (d) {\n            return d[_this2.yLabel];\n          }), 1);\n        }\n\n        var svgRatioX = this.config.plotWidth / (this.categoryRange[1] - this.categoryRange[0]);\n        var svgRatioY = this.config.plotHeight / (this.valueRange[1] - this.valueRange[0]);\n\n        if (this.clusters) {\n          var parsedData = {};\n          this.clusters.forEach(function (key) {\n            var initialData = _this2.parsedScatterData.filter(function (x) {\n              return x.cluster === key;\n            });\n\n            var clusterDatum = _this2.computeErrorEllipse(initialData, _this2.xLabel, _this2.yLabel, svgRatioX, svgRatioY);\n\n            parsedData[key] = clusterDatum;\n          });\n          this.parsedClusterData = parsedData;\n        }\n\n        if (this.clusters) {\n          this.colorMap = this.getMap(this.clusters, this.colors);\n        } else if (this.groups) {\n          this.colorMap = this.getMap(this.groups, this.colors);\n        }\n\n        this.dataChanged = false;\n      }\n    }\n  }, {\n    key: \"rangeIsValid\",\n    value: function rangeIsValid(range) {\n      if (!!range && !!range[0] && !!range[1]) return true;\n      return false;\n    }\n  }, {\n    key: \"computeErrorEllipse\",\n    value: function computeErrorEllipse(samples, xIndex, yIndex, svgRatioX, svgRatioY) {\n      var ellipseData = {\n        cx: 0,\n        cy: 0,\n        rx: 0,\n        ry: 0,\n        rotationAngle: 0\n      };\n      var s = 5.991;\n      var statX = new Oviz.algo.Statistics(samples.map(function (x) {\n        return x[xIndex];\n      }));\n      var statY = new Oviz.algo.Statistics(samples.map(function (y) {\n        return y[yIndex];\n      }));\n      ellipseData.cx = statX.mean();\n      ellipseData.cy = statY.mean();\n      var varX = 0,\n          varY = 0,\n          cov = 0;\n      samples.forEach(function (d) {\n        varX += Math.pow((d[xIndex] - statX.mean()) * svgRatioX, 2) / (samples.length - 1);\n        varY += Math.pow((d[yIndex] - statY.mean()) * svgRatioY, 2) / (samples.length - 1);\n        cov += (d[xIndex] - statX.mean()) * svgRatioX * (d[yIndex] - statY.mean()) * svgRatioY / (samples.length - 1);\n      });\n      var eParams = {\n        a: 1,\n        b: -(varX + varY),\n        c: varX * varY - Math.pow(cov, 2)\n      };\n      var eigenValue1 = (-eParams.b + Math.sqrt(Math.pow(eParams.b, 2) - 4 * eParams.a * eParams.c)) / (2 * eParams.a);\n      var eigenValue2 = (-eParams.b - Math.sqrt(Math.pow(eParams.b, 2) - 4 * eParams.a * eParams.c)) / (2 * eParams.a);\n      ellipseData.rx = Math.sqrt(s * Math.abs(eigenValue1));\n      ellipseData.ry = Math.sqrt(s * Math.abs(eigenValue2));\n      var rotationRad = Math.atan((varX - eigenValue1) / cov);\n      ellipseData.rotationAngle = rotationRad * 180 / Math.PI;\n      var triFunctions = {\n        sin: function sin(r) {\n          return r * Math.sin(rotationRad);\n        },\n        cos: function cos(r) {\n          return r * Math.cos(rotationRad);\n        }\n      };\n      var dx = triFunctions.cos(ellipseData.rx);\n      var dy = triFunctions.sin(ellipseData.rx);\n      var ellipsePath = \"M 0 0\\n                    A \".concat(ellipseData.rx, \" \").concat(ellipseData.ry, \" \").concat(ellipseData.rotationAngle, \" 0 1 \").concat(2 * dx, \" \").concat(2 * dy, \"\\n                    A \").concat(ellipseData.rx, \" \").concat(ellipseData.ry, \" \").concat(ellipseData.rotationAngle, \" 0 1 0 0 Z\");\n      var center = {\n        x: statX.mean(),\n        y: statY.mean()\n      };\n      var ellipseDatum = {\n        dx: dx,\n        dy: dy,\n        ellipsePath: ellipsePath,\n        xAxisPath: \"M 0 0 L \".concat(2 * dx, \" \").concat(2 * dy),\n        yAxisPath: \"M \".concat(dx - triFunctions.sin(ellipseData.ry), \" \").concat(dy + triFunctions.cos(ellipseData.ry), \"\\n            L \").concat(dx + triFunctions.sin(ellipseData.ry), \" \").concat(dy - triFunctions.cos(ellipseData.ry))\n      };\n      return {\n        center: center,\n        ellipseData: ellipseDatum\n      };\n    }\n  }, {\n    key: \"generateScatterContent\",\n    value: function generateScatterContent(scatter) {\n      return Object.keys(scatter).reduce(function (acc, cur) {\n        if (!!scatter[cur]) {\n          if (typeof scatter[cur] === \"number\") return acc + \"\".concat(cur, \": \").concat(scatter[cur].toFixed(3), \"<br>\");else return acc + \"\".concat(cur, \": \").concat(scatter[cur], \"<br>\");\n        } else return acc;\n      }, \"\");\n    }\n  }, {\n    key: \"getMap\",\n    value: function getMap(keyArray, valueArray) {\n      var map = new Map();\n      keyArray.forEach(function (key, i) {\n        map.set(key, valueArray[i]);\n      });\n      return map;\n    }\n  }, {\n    key: \"dragStart\",\n    value: function dragStart(_, el) {\n      var _this3 = this;\n\n      el.$parent.$on[\"mousemove\"] = function (evp, elp) {\n        var _Oviz$utils$mouse = Oviz.utils.mouse(elp, evp),\n            _Oviz$utils$mouse2 = _slicedToArray(_Oviz$utils$mouse, 2),\n            newX = _Oviz$utils$mouse2[0],\n            newY = _Oviz$utils$mouse2[1];\n\n        if (el.id === \"legend1\") {\n          _this3.legend1Pos = {\n            x: newX,\n            y: newY\n          };\n        } else {\n          _this3.legend2Pos = {\n            x: newX,\n            y: newY\n          };\n        }\n\n        _this3.setState({\n          newX: newX,\n          newY: newY\n        });\n      };\n\n      el.stage = \"dragging\";\n    }\n  }, {\n    key: \"dragEnd\",\n    value: function dragEnd(_, el) {\n      delete el.$parent.$on[\"mousemove\"];\n      el.stage = null;\n      this.setState({\n        newX: null,\n        newY: null\n      });\n    }\n  }]);\n\n  return ComplexScatterplotBk;\n}(Component);","map":{"version":3,"sources":["/Users/wangzhenyu/Desktop/fyp_workspace/meta_platform/app/javascript/viz/scatterplot/complex-scatterplot.ts"],"names":["Oviz","Component","findBoundsForValues","template","editorRef","ComplexScatterplotBk","dataChanged","rankChanged","axisChanged","config","colors","ranks","availableAxises","scatterData","scatterVectorData","vectorLabel","groups","clusters","mainDict","clusterDict","sampleInfoDict","parsedScatterData","parsedClusterData","rankLabel","xLabel","categoryRange","yLabel","valueRange","groupLegendData","shapeMap","colorMap","legend2Pos","legend1Pos","render","t","_firstRender","x","y","shapes","getMap","map","i","type","label","fill","rankIndex","text","columns","filter","_","xAxisIndex","xAxis","value","yAxisIndex","yAxis","options","length","d","datum","sampleId","group","cluster","rangeIsValid","svgRatioX","plotWidth","svgRatioY","plotHeight","parsedData","forEach","key","initialData","clusterDatum","computeErrorEllipse","range","samples","xIndex","yIndex","ellipseData","cx","cy","rx","ry","rotationAngle","s","statX","algo","Statistics","statY","mean","varX","varY","cov","Math","pow","eParams","a","b","c","eigenValue1","sqrt","eigenValue2","abs","rotationRad","atan","PI","triFunctions","sin","r","cos","dx","dy","ellipsePath","center","ellipseDatum","xAxisPath","yAxisPath","scatter","Object","keys","reduce","acc","cur","toFixed","keyArray","valueArray","Map","set","el","$parent","$on","evp","elp","utils","mouse","newX","newY","id","setState","stage"],"mappings":"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","sourcesContent":["import Oviz from \"crux\";\nimport { Component, ComponentOption } from \"crux/dist/element\";\nimport { findBoundsForValues } from \"utils/maths\";\nimport template from \"./template.bvt\";\n\nimport { editorRef } from \"./editor\";\n\nexport interface ErrorEllipseDatum {\n    dx: number;\n    dy: number;\n    ellipsePath: string;\n    xAxisPath: string;\n    yAxisPath: string;\n}\n\nexport interface ScatterClusterDatum {\n    center: {x, y};\n    ellipseData: ErrorEllipseDatum;\n}\nexport class ComplexScatterplotBk extends Component<ComponentOption> {\n\n    public dataChanged: boolean = true;\n    public rankChanged: boolean;\n    public axisChanged: boolean;\n    public config: any;\n    public colors: string;\n\n    public ranks: Array<{ value: string; text: string }>;\n    public availableAxises: Array<{ value: string; text: string }>;\n\n    public scatterData: any;\n    public scatterVectorData: any[];\n    public vectorLabel: string;\n    public groups: string[];\n    public clusters: string[];\n\n    public mainDict: Record<string, any>;\n    public clusterDict;\n    public sampleInfoDict: any;\n\n    private parsedScatterData: any[];\n    private parsedClusterData: Record<string, ScatterClusterDatum>;\n    private rankLabel;\n    private xLabel;\n    private categoryRange;\n    private yLabel;\n    private valueRange;\n\n    private groupLegendData;\n\n    private shapeMap: Map<string, string>;\n    private colorMap: Map<string|number, string>;\n\n    private legend2Pos: {x: number, y: number};\n\n    private legend1Pos: {x: number, y: number};\n\n    public render = Oviz.t`${template}`;\n\n    willRender() {\n        if (this._firstRender) {\n            this.legend1Pos = {x: 45, y: 115};\n            this.legend2Pos = {x: 45, y: 55};\n            const shapes = [\"Circle\", \"Rect\", \"Triangle\"];\n            if (this.clusters) {\n                this.colorMap = this.getMap(this.clusters, this.colors);\n                if (this.groups) {\n                    this.shapeMap = this.getMap(this.groups, shapes);\n                    this.groupLegendData = this.groups.map((x, i) => {\n                        return {type: \"Custom\", label: x, fill: \"grey\"};\n                    });\n                }\n            } else if (this.groups) {\n                this.colorMap = this.getMap(this.groups, this.colors);\n                this.groupLegendData = this.groups.map((x, i) => {\n                    return {type: \"Custom\", label: x, fill: this.colors[i]}\n                });\n            }\n        }\n\n        if (this.rankChanged) {\n            this.rankLabel = this.ranks[this.config.rankIndex].text;\n            this.scatterData = this.mainDict[this.rankLabel];\n            this.availableAxises = this.scatterData.columns.filter((_, i) => i > 0)\n                                .map((x, i) => ({\"value\": i, \"text\": x}));\n            this.config.xAxisIndex = editorRef.xAxis.value = 0;\n            this.config.yAxisIndex = editorRef.yAxis.value = 1;\n\n            editorRef.xAxis.config.options = editorRef.yAxis.config.options = this.availableAxises;\n\n            this.rankChanged = false;\n        }\n\n        if (this._firstRender || this.dataChanged) {\n            this.xLabel = this.availableAxises[this.config.xAxisIndex].text;\n            if (this.config.yAxisIndex === 1 && this.availableAxises.length === 1){\n                this.yLabel = this.availableAxises[0].text;\n                this.config.yAxisIndex = 0;\n            }\n\n            this.yLabel = this.availableAxises[this.config.yAxisIndex].text;\n            this.parsedScatterData = this.scatterData.map((d, i) => {\n                const datum = {sampleId: d.sampleId, \n                    group: this.sampleInfoDict[d.sampleId].group,\n                    cluster: this.clusterDict ? this.clusterDict[d.sampleId][this.rankLabel] :null};\n                datum[this.xLabel] = d[this.xLabel];\n                datum[this.yLabel] = d[this.yLabel];\n                return datum;\n            });\n\n            if (this.clusters) {\n                this.categoryRange = this.rangeIsValid(this.config.categoryRange) ?  this.config.categoryRange\n                    : findBoundsForValues(this.scatterData.map(d => d[this.xLabel]), 1, false, 0.1);\n                this.valueRange = this.rangeIsValid(this.config.valueRange) ? this.config.valueRange\n                    : findBoundsForValues(this.scatterData.map(d => d[this.yLabel]), 1, false, 0.1);\n            } else {\n                this.categoryRange = this.rangeIsValid(this.config.categoryRange) ?  this.config.categoryRange\n                : findBoundsForValues(this.scatterData.map(d => d[this.xLabel]), 1);\n                this.valueRange = this.rangeIsValid(this.config.valueRange) ? this.config.valueRange\n                    : findBoundsForValues(this.scatterData.map(d => d[this.yLabel]), 1);\n            }\n\n            const svgRatioX = this.config.plotWidth / (this.categoryRange[1] - this.categoryRange[0]);\n            const svgRatioY = this.config.plotHeight / (this.valueRange[1] - this.valueRange[0]);\n\n            if (this.clusters) {\n                const parsedData = {};\n                this.clusters.forEach(key => {\n                    const initialData = this.parsedScatterData.filter(x => x.cluster === key);\n                    const clusterDatum = this.computeErrorEllipse(initialData, this.xLabel, this.yLabel,\n                        svgRatioX, svgRatioY);\n                    parsedData[key] = clusterDatum;\n                });\n                this.parsedClusterData = parsedData;\n            }\n            if (this.clusters) {\n                this.colorMap = this.getMap(this.clusters, this.colors);\n            } else if (this.groups) {\n                this.colorMap = this.getMap(this.groups, this.colors);\n            }\n            this.dataChanged = false;\n        }\n    }\n\n    protected rangeIsValid(range: Array<number>): boolean {\n        if (!!range && !!range[0] && !!range[1]) return true;\n        return false;\n    }\n\n    protected computeErrorEllipse(samples, xIndex, yIndex, svgRatioX, svgRatioY): ScatterClusterDatum {\n        const ellipseData = {cx: 0, cy: 0, rx: 0, ry: 0, rotationAngle: 0};\n        const s = 5.991;\n        const statX = new Oviz.algo.Statistics(samples.map(x => x[xIndex]));\n        const statY = new Oviz.algo.Statistics(samples.map(y => y[yIndex]));\n\n        ellipseData.cx =  statX.mean();\n        ellipseData.cy = statY.mean();\n\n        let varX = 0, varY = 0, cov = 0;\n        samples.forEach(d => {\n            varX += Math.pow( (d[xIndex] - statX.mean()) * svgRatioX, 2) / (samples.length - 1);\n            varY += Math.pow( (d[yIndex] - statY.mean()) * svgRatioY, 2) / (samples.length - 1);\n            cov += (d[xIndex] - statX.mean()) * svgRatioX * (d[yIndex] - statY.mean()) * svgRatioY / (samples.length - 1);\n        });\n\n        const eParams = {a: 1, b: -(varX + varY), c: varX * varY - Math.pow(cov, 2)};\n        const eigenValue1 = (-eParams.b + Math.sqrt(Math.pow(eParams.b, 2) - 4 * eParams.a * eParams.c)) / (2 * eParams.a);\n        const eigenValue2 = (-eParams.b - Math.sqrt(Math.pow(eParams.b, 2) - 4 * eParams.a * eParams.c)) / (2 * eParams.a );\n        ellipseData.rx = Math.sqrt(s * Math.abs(eigenValue1));\n        ellipseData.ry = Math.sqrt(s * Math.abs(eigenValue2));\n\n        const rotationRad = Math.atan((varX - eigenValue1) / cov);\n        ellipseData.rotationAngle  = rotationRad * 180 / Math.PI;\n        const triFunctions = {\n            sin(r) { return r * Math.sin(rotationRad); },\n            cos(r) { return r * Math.cos(rotationRad); },\n        };\n        const dx = triFunctions.cos(ellipseData.rx);\n        const dy = triFunctions.sin(ellipseData.rx);\n        const ellipsePath = `M 0 0\n                    A ${ellipseData.rx} ${ellipseData.ry} ${ellipseData.rotationAngle} 0 1 ${2 * dx} ${2 * dy}\n                    A ${ellipseData.rx} ${ellipseData.ry} ${ellipseData.rotationAngle} 0 1 0 0 Z`;\n        const center = {x: statX.mean(), y: statY.mean()};\n        const ellipseDatum = {\n            dx,\n            dy,\n            ellipsePath,\n            xAxisPath: `M 0 0 L ${2 * dx} ${2 * dy}`,\n            yAxisPath: `M ${dx - triFunctions.sin(ellipseData.ry)} ${dy + triFunctions.cos(ellipseData.ry)}\n            L ${dx + triFunctions.sin(ellipseData.ry)} ${dy - triFunctions.cos(ellipseData.ry)}`,\n        };\n        return {center, ellipseData: ellipseDatum};\n    }\n\n    protected generateScatterContent(scatter) {\n        return Object.keys(scatter)\n                     .reduce(((acc, cur) => {\n                        if (!!scatter[cur])\n                            if (typeof scatter[cur] === \"number\")\n                                return acc + `${cur}: ${scatter[cur].toFixed(3)}<br>`;\n                            else\n                                return acc + `${cur}: ${scatter[cur]}<br>`;\n                        else return acc;\n                }), \"\");\n    }\n\n    protected getMap(keyArray, valueArray) {\n        const map = new Map();\n        keyArray.forEach((key, i) => {\n            map.set(key, valueArray[i]);\n        });\n        return map;\n    }\n\n    protected dragStart(_, el) {\n        el.$parent.$on[\"mousemove\"] = (evp, elp) => {\n            const [newX, newY] = Oviz.utils.mouse(elp, evp);\n            if (el.id === \"legend1\") {\n                this.legend1Pos = {x: newX, y: newY};\n            } else {\n                this.legend2Pos = {x: newX, y: newY};\n            }\n            this.setState({newX, newY});\n        };\n        el.stage = \"dragging\";\n    }\n\n    protected dragEnd(_, el) {\n        delete el.$parent.$on[\"mousemove\"];\n        el.stage = null;\n        this.setState({newX: null, newY: null});\n    }\n}\n"]},"metadata":{},"sourceType":"module"}