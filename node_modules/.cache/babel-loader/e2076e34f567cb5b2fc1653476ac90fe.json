{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport Oviz from \"crux\";\nimport { editorConfig, editorRef } from \"./editor\";\nimport { ScatterBoxPlot } from \"./scatter-box-plot\";\nimport { ComplexBoxplot, processBoxData } from \"oviz-components/complex-boxplot\";\nimport { ComplexScatterplot } from \"oviz-components/complex-scatterplot\";\nimport { EditText } from \"oviz-components/edit-text\";\nimport { GridPlot } from \"oviz-components/grid-plot\";\nimport { groupedChartColors } from \"oviz-common/palette\";\nimport { register } from \"page/visualizers\";\nimport { rankDict } from \"utils/bio-info\";\nimport DataUtils from \"utils/data\";\nimport { registerEditorConfig } from \"utils/editor\";\nimport { findBoundsForValues } from \"utils/maths\";\nimport { minmax } from \"crux/dist/utils/math\";\nimport { brewPalette, MetaInfo } from \"viz/meta-overview/data\";\nvar xAxisIndex = 0;\nvar yAxisIndex = 1;\nvar startColor = \"blue\";\nvar endColor = \"red\"; // const ageDiv = 40;\n\nvar shapes = [\"Circle\", \"Triangle\", \"Rect\"];\nvar colorScheme = Oviz.color.ColorSchemeGradient.create(startColor, endColor);\nvar MODULE_NAME = \"scatter-box-plot\";\n\nfunction init() {\n  if (!window.gon || window.gon.module_name !== MODULE_NAME) return;\n\n  var _Oviz$visualize = Oviz.visualize({\n    el: \"#canvas\",\n    root: new ScatterBoxPlot(),\n    components: {\n      GridPlot: GridPlot,\n      EditText: EditText,\n      ComplexBoxplot: ComplexBoxplot,\n      ComplexScatterplot: ComplexScatterplot\n    },\n    renderer: \"svg\",\n    width: 800,\n    height: 800,\n    data: {\n      colorScheme: colorScheme,\n      startColor: startColor,\n      endColor: endColor,\n      shapes: shapes,\n      colors: {},\n      mainGridLength: 300,\n      boxGridHeight: 100,\n      scatterConfig: {\n        hasPadding: false,\n        labelFontSize: 12,\n        tickFontSize: 12,\n        scatterSize: 8,\n        hollow: false\n      },\n      boxConfig: {\n        showOutliers: true,\n        drawViolin: false,\n        drawScatter: false,\n        hollowBox: false,\n        labelFontSize: 12,\n        tickFontSize: 12,\n        useCat: true\n      },\n      xBoxConfig: {\n        invertValueAxis: true,\n        flip: true,\n        discreteCategory: true\n      },\n      yBoxConfig: {}\n    },\n    loadData: {\n      scatterBoxMain: {\n        fileKey: \"scatterBoxMain\",\n        type: \"tsv\",\n        multiple: true,\n        dependsOn: [\"scatterBoxGroup\"],\n        loaded: function loaded(data) {\n          var _this = this;\n\n          this.data.mainDict = {};\n          this.data.ranks = [];\n          data.forEach(function (d, i) {\n            // process rank information\n            var rankLabel = rankDict[d.columns[0]];\n\n            _this.data.ranks.push({\n              value: rankLabel,\n              text: rankLabel\n            });\n\n            var mainD = d.map(function (x) {\n              x[\"sampleId\"] = x[d.columns[0]];\n              delete x[d.columns[0]];\n              return x;\n            });\n            _this.data.mainDict[rankLabel] = d;\n\n            if (i === 0) {\n              _this.data.rank = rankLabel;\n              setMainData(d, _this);\n            }\n          });\n          return null;\n        }\n      },\n      scatterBoxGroup: {\n        fileKey: \"scatterBoxGroup\",\n        type: \"tsv\",\n        loaded: function loaded(data) {\n          var _this2 = this;\n\n          this.data.metaFeatures = data.columns.slice(1, data.columns.length); // this.data.metaDict = {};\n\n          this.data.metaInfo = {};\n          this.data.discardedFeatures = [];\n          var curPos = 0;\n          var catKey, groupKey, colorKey;\n          this.data.metaFeatures.forEach(function (k, i) {\n            if (DataUtils.isDistcint(data, k)) {\n              var values = data.map(function (x) {\n                return x[k];\n              }).reduce(function (a, x) {\n                if (a.indexOf(x) < 0 && !DataUtils.isNull(x)) a.push(x);\n                return a;\n              }, []);\n\n              if (values.length > 10) {\n                _this2.data.discardedFeatures.push(k);\n\n                _this2.data.metaFeatures.splice(i, 1);\n\n                alert(\"Meta info \\\"\".concat(k, \"\\\" contains more than 10 categories, will not be drawn\"));\n              } else {\n                _this2.data.metaInfo[k] = new MetaInfo(k, false, null, null, values, curPos + values.length <= brewPalette.length ? groupedChartColors.slice(curPos, curPos + values.length) : null);\n                curPos += values.length;\n\n                if (!!groupKey && !catKey) {\n                  catKey = k;\n                }\n\n                if (!groupKey) groupKey = k;\n              }\n            } else {\n              var _values = data.map(function (x) {\n                return parseFloat(x[k]);\n              });\n\n              var _minmax = minmax(_values),\n                  _minmax2 = _slicedToArray(_minmax, 2),\n                  min = _minmax2[0],\n                  max = _minmax2[1];\n\n              _this2.data.metaInfo[k] = new MetaInfo(k, true, min, max, _values);\n              _this2.data.metaInfo[k].colorStart = \"#0247FE\";\n              _this2.data.metaInfo[k].colorEnd = \"#FE4702\";\n\n              _this2.data.metaInfo[k].updateColorGetter();\n\n              if (!colorKey) colorKey = k;\n            }\n          });\n          var sampleKey = data.columns[0];\n          if (!catKey) catKey = groupKey;\n          if (!colorKey) colorKey = groupKey;\n          this.data.categories = this.data.metaInfo[catKey].values;\n          this.data.catKey = catKey;\n          this.data.groupDict = {};\n          this.data.groups = this.data.metaInfo[groupKey].values;\n          this.data.groupLegend = this.data.groups.map(function (x, i) {\n            return {\n              label: x,\n              fill: \"#aaa\",\n              type: shapes[i]\n            };\n          });\n          this.data.groupKey = groupKey;\n          data.forEach(function (x) {\n            _this2.data.groupDict[x[sampleKey]] = x;\n          });\n          this.data.colorKey = colorKey;\n          this.data.shapeDict = {};\n          this.data.groups.forEach(function (k, i) {\n            return _this2.data.shapeDict[k] = shapes[i];\n          });\n          return null;\n        }\n      }\n    },\n    setup: function setup() {\n      var _this3 = this;\n\n      console.log(this[\"_data\"]); // set cat colors\n\n      this.data.colors.cats = this.data.categories.map(function (x) {\n        return _this3.data.metaInfo[_this3.data.catKey].color(x);\n      });\n      var colorMetaInfo = this.data.metaInfo[this.data.colorKey];\n\n      if (colorMetaInfo.isNumber) {\n        this.data.colors.classes = [colorMetaInfo.colorStart, colorMetaInfo.colorEnd];\n      } else {\n        this.data.colors.classes = colorMetaInfo.values.map(function (x) {\n          return colorMetaInfo.color(x);\n        });\n        this.data.classLegend = colorMetaInfo.values.map(function (x, i) {\n          return {\n            label: x,\n            fill: colorMetaInfo.color(x),\n            type: \"Rect\"\n          };\n        });\n      }\n\n      this.data.hiddenSamples = new Set();\n      this.defineGradient(\"bg\", \"horizontal\", [startColor, endColor]);\n      registerEditorConfig(editorConfig(this), editorRef);\n\n      this.data.data.generateTooltip = function (d) {\n        return [_this3.data.xLabel, _this3.data.yLabel].concat(_toConsumableArray(_this3.data.metaFeatures)).map(function (k) {\n          return \"\".concat(k, \": \").concat(typeof d[k] === \"number\" ? d[k].toFixed(3) : d[k], \"<br>\");\n        }).join(\"\");\n      };\n\n      this.data.legendWidth = this.data.boxGridHeight + 40;\n    }\n  }),\n      visualizer = _Oviz$visualize.visualizer;\n\n  return visualizer;\n}\n\nexport var setMainData = function setMainData(d, v, xLabel, yLabel) {\n  v.data.axises = d.columns.slice(1).map(function (x) {\n    return {\n      value: x,\n      text: x\n    };\n  });\n  var chosenX = xLabel || v.data.axises[xAxisIndex].value;\n  var chosenY = yLabel || v.data.axises[yAxisIndex].value;\n  v.data.xLabel = chosenX;\n  v.data.yLabel = chosenY;\n  v.data.scatterData = [];\n  processRawData(d, v);\n\n  var shapeGetter = function shapeGetter(s) {\n    return v.data.shapeDict[s[v.data.groupKey]];\n  };\n\n  var groups = v.data.metaInfo[v.data.groupKey].values;\n\n  var colorGetter = function colorGetter(s) {\n    return v.data.metaInfo[v.data.colorKey].color(s[v.data.colorKey]);\n  };\n\n  v.data.data = {\n    xLabel: v.data.xLabel,\n    yLabel: v.data.yLabel,\n    data: v.data.scatterData,\n    valueRange: v.data.yRange,\n    categoryRange: v.data.xRange,\n    shapeGetter: shapeGetter,\n    colorGetter: colorGetter\n  };\n  v.data.samples = d.map(function (x) {\n    return x.sampleId;\n  });\n  v.data.boxDataX.valueRange = v.data.data.categoryRange;\n  v.data.boxDataY.valueRange = v.data.data.valueRange;\n};\n\nvar processRawData = function processRawData(d, v) {\n  var xValues = [];\n  var yValues = [];\n  d.forEach(function (x) {\n    var xValue = parseFloat(x[v.data.xLabel]);\n    var yValue = parseFloat(x[v.data.yLabel]);\n\n    var temp = _objectSpread({\n      sampleId: x.sampleId,\n      show: true,\n      pos: xValue,\n      value: yValue\n    }, v.data.groupDict[x.sampleId]);\n\n    temp[v.data.xLabel] = xValue;\n    temp[v.data.yLabel] = yValue;\n    v.data.scatterData.push(temp);\n    xValues.push(xValue);\n    yValues.push(yValue);\n  });\n  v.data.xRange = findBoundsForValues(xValues, 2, false, 0.1);\n  v.data.yRange = findBoundsForValues(yValues, 2, false, 0.1);\n  var categories = v.data.categories;\n  var xBoxValues = categories.map(function (_) {\n    return [];\n  });\n  var yBoxValues = categories.map(function (_) {\n    return [];\n  });\n  v.data.scatterData.forEach(function (x) {\n    var catIndex = categories.indexOf(x[v.data.catKey]);\n    xBoxValues[catIndex].push(x.pos);\n    yBoxValues[catIndex].push(x.value);\n  });\n  v.data.boxDataX = processBoxData(xBoxValues, categories);\n  v.data.boxDataY = processBoxData(yBoxValues, categories);\n};\n\nregister(MODULE_NAME, init);\nexport function registerScatterBoxPlot() {\n  register(MODULE_NAME, init);\n}","map":{"version":3,"sources":["/Users/wangzhenyu/Desktop/fyp_workspace/meta_platform/app/javascript/viz/scatter-box-plot/index.ts"],"names":["Oviz","editorConfig","editorRef","ScatterBoxPlot","ComplexBoxplot","processBoxData","ComplexScatterplot","EditText","GridPlot","groupedChartColors","register","rankDict","DataUtils","registerEditorConfig","findBoundsForValues","minmax","brewPalette","MetaInfo","xAxisIndex","yAxisIndex","startColor","endColor","shapes","colorScheme","color","ColorSchemeGradient","create","MODULE_NAME","init","window","gon","module_name","visualize","el","root","components","renderer","width","height","data","colors","mainGridLength","boxGridHeight","scatterConfig","hasPadding","labelFontSize","tickFontSize","scatterSize","hollow","boxConfig","showOutliers","drawViolin","drawScatter","hollowBox","useCat","xBoxConfig","invertValueAxis","flip","discreteCategory","yBoxConfig","loadData","scatterBoxMain","fileKey","type","multiple","dependsOn","loaded","mainDict","ranks","forEach","d","i","rankLabel","columns","push","value","text","mainD","map","x","rank","setMainData","scatterBoxGroup","metaFeatures","slice","length","metaInfo","discardedFeatures","curPos","catKey","groupKey","colorKey","k","isDistcint","values","reduce","a","indexOf","isNull","splice","alert","parseFloat","min","max","colorStart","colorEnd","updateColorGetter","sampleKey","categories","groupDict","groups","groupLegend","label","fill","shapeDict","setup","console","log","cats","colorMetaInfo","isNumber","classes","classLegend","hiddenSamples","Set","defineGradient","generateTooltip","xLabel","yLabel","toFixed","join","legendWidth","visualizer","v","axises","chosenX","chosenY","scatterData","processRawData","shapeGetter","s","colorGetter","valueRange","yRange","categoryRange","xRange","samples","sampleId","boxDataX","boxDataY","xValues","yValues","xValue","yValue","temp","show","pos","xBoxValues","_","yBoxValues","catIndex","registerScatterBoxPlot"],"mappings":"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","sourcesContent":["import Oviz from \"crux\";\n\nimport { editorConfig, editorRef } from \"./editor\";\nimport { ScatterBoxPlot } from \"./scatter-box-plot\";\n\nimport { ComplexBoxplot, processBoxData } from \"oviz-components/complex-boxplot\";\nimport { ComplexScatterplot } from \"oviz-components/complex-scatterplot\";\nimport { EditText } from \"oviz-components/edit-text\";\nimport { GridPlot } from \"oviz-components/grid-plot\";\nimport { groupedChartColors } from \"oviz-common/palette\";\nimport { register } from \"page/visualizers\";\nimport { rankDict, sortByRankKey} from \"utils/bio-info\";\nimport DataUtils from \"utils/data\";\nimport { registerEditorConfig } from \"utils/editor\";\nimport { findBoundsForValues } from \"utils/maths\";\n\nimport { minmax } from \"crux/dist/utils/math\";\nimport { brewPalette, MetaInfo } from \"viz/meta-overview/data\";\n\nconst xAxisIndex = 0;\nconst yAxisIndex = 1;\nconst startColor = \"blue\";\nconst endColor = \"red\";\n\n// const ageDiv = 40;\nconst shapes = [\"Circle\", \"Triangle\", \"Rect\"];\n\nconst colorScheme = Oviz.color.ColorSchemeGradient.create(startColor, endColor);\n\nconst MODULE_NAME = \"scatter-box-plot\";\n\nfunction init() {\n\n    if (!window.gon || window.gon.module_name !== MODULE_NAME) return;\n\n    const {visualizer} = Oviz.visualize({\n        el: \"#canvas\",\n        root: new ScatterBoxPlot(),\n        components: {GridPlot, EditText, ComplexBoxplot, ComplexScatterplot},\n        renderer: \"svg\",\n        width: 800,\n        height: 800,\n        data: {\n            colorScheme, startColor, endColor, shapes,\n            colors: {},\n            mainGridLength: 300,\n            boxGridHeight: 100,\n            scatterConfig: {\n                hasPadding: false,\n                labelFontSize: 12,\n                tickFontSize: 12,\n                scatterSize: 8,\n                hollow: false,\n            },\n            boxConfig: {\n                showOutliers: true,\n                drawViolin: false,\n                drawScatter: false,\n                hollowBox: false,\n                labelFontSize: 12,\n                tickFontSize: 12,\n                useCat: true,\n            },\n            xBoxConfig: {\n                invertValueAxis: true,\n                flip: true,\n                discreteCategory: true,\n            },\n            yBoxConfig: {\n              \n            },\n        },\n        loadData: {\n            scatterBoxMain: {\n                fileKey: \"scatterBoxMain\",\n                type: \"tsv\",\n                multiple: true,\n                dependsOn: [\"scatterBoxGroup\"],\n                loaded(data) {\n                    this.data.mainDict = {};\n                    this.data.ranks = [];\n                    data.forEach((d, i) => {\n                        // process rank information\n                        const rankLabel = rankDict[d.columns[0]];\n                        this.data.ranks.push({value: rankLabel, text: rankLabel});\n                        const mainD = d.map(x => {\n                            x[\"sampleId\"] = x[d.columns[0]];\n                            delete x[d.columns[0]];\n                            return x;\n                        });\n                        this.data.mainDict[rankLabel] = d;\n                        if (i === 0) {\n                            this.data.rank = rankLabel;\n                            setMainData(d, this);\n                        }\n                    });\n                    return null;\n                },\n            },\n            scatterBoxGroup: {\n                fileKey: \"scatterBoxGroup\",\n                type: \"tsv\",\n                loaded(data) {\n                    this.data.metaFeatures = data.columns.slice(1, data.columns.length);\n                    // this.data.metaDict = {};\n                    this.data.metaInfo = {};\n                    this.data.discardedFeatures = [];\n                    let curPos = 0;\n                    let catKey: string, groupKey: string, colorKey: string;\n                    this.data.metaFeatures.forEach((k, i) => {\n                        if (DataUtils.isDistcint(data, k)) {\n                            const values = data.map(x => x[k]).reduce((a, x) => {\n                                if (a.indexOf(x) < 0 && (!DataUtils.isNull(x))) a.push(x);\n                                return a;\n                            }, []);\n                            if (values.length > 10) {\n                                this.data.discardedFeatures.push(k);\n                                this.data.metaFeatures.splice(i, 1);\n                                alert(`Meta info \"${k}\" contains more than 10 categories, will not be drawn`);\n                            } else {\n                                this.data.metaInfo[k] = new MetaInfo(k, false, null, null, values,\n                                    curPos + values.length <= brewPalette.length ?\n                                        groupedChartColors.slice(curPos, curPos + values.length) : null);\n                                curPos += values.length;\n                                if (!!groupKey && !catKey) {\n                                    catKey = k;\n                                }\n                                if (!groupKey) groupKey = k;\n                            }\n                        } else {\n                            const values = data.map(x => parseFloat(x[k]));\n                            const [min, max] = minmax(values);\n                            this.data.metaInfo[k] = new MetaInfo(k, true, min, max, values);\n                            this.data.metaInfo[k].colorStart = \"#0247FE\";\n                            this.data.metaInfo[k].colorEnd = \"#FE4702\";\n                            this.data.metaInfo[k].updateColorGetter();\n                            if (!colorKey) colorKey = k;\n                        }\n                    });\n                    const sampleKey = data.columns[0];\n                    if (!catKey) catKey = groupKey;\n                    if (!colorKey) colorKey = groupKey;\n                    this.data.categories = this.data.metaInfo[catKey].values;\n                    this.data.catKey = catKey;\n                    this.data.groupDict = {};\n                    this.data.groups = this.data.metaInfo[groupKey].values;\n                    this.data.groupLegend = this.data.groups.map((x, i) => {\n                        return {label: x, fill: \"#aaa\", type: shapes[i]};\n                    });\n                    this.data.groupKey = groupKey;\n                    data.forEach(x => {\n                        this.data.groupDict[x[sampleKey]] = x;\n                    });\n                    this.data.colorKey = colorKey;\n                    this.data.shapeDict = {};\n                    this.data.groups.forEach((k, i) => this.data.shapeDict[k] = shapes[i]);\n                    return null;\n                },\n            },\n        },\n        setup() {\n            console.log(this[\"_data\"]);\n\n            // set cat colors\n            this.data.colors.cats = this.data.categories.map(x => this.data.metaInfo[this.data.catKey].color(x));\n            const colorMetaInfo = this.data.metaInfo[this.data.colorKey];\n            if (colorMetaInfo.isNumber) {\n                this.data.colors.classes = [colorMetaInfo.colorStart, colorMetaInfo.colorEnd];\n            } else {\n                this.data.colors.classes = colorMetaInfo.values.map(x => colorMetaInfo.color(x));\n                this.data.classLegend = colorMetaInfo.values.map((x, i) => {\n                    return {label: x, fill: colorMetaInfo.color(x), type: \"Rect\"};\n                });\n            }\n            this.data.hiddenSamples = new Set();\n            this.defineGradient(\"bg\", \"horizontal\", [startColor, endColor]);\n            registerEditorConfig(editorConfig(this), editorRef);\n            this.data.data.generateTooltip =  (d) => {\n                return [this.data.xLabel, this.data.yLabel, ...this.data.metaFeatures].map(k =>\n                    `${k}: ${typeof d[k] === \"number\" ?  d[k].toFixed(3) : d[k]}<br>`).join(\"\");\n            };\n            this.data.legendWidth = this.data.boxGridHeight + 40;\n        },\n    });\n\n    return visualizer;\n}\n\nexport const setMainData = (d, v, xLabel?, yLabel?) => {\n    v.data.axises = d.columns.slice(1).map(x => ({value: x, text: x}));\n    const chosenX = xLabel || v.data.axises[xAxisIndex].value;\n    const chosenY = yLabel || v.data.axises[yAxisIndex].value;\n    v.data.xLabel = chosenX;\n    v.data.yLabel = chosenY;\n    v.data.scatterData = [];\n    processRawData(d, v);\n\n    const shapeGetter = (s) => v.data.shapeDict[s[v.data.groupKey]]\n    const groups = v.data.metaInfo[v.data.groupKey].values;\n    const colorGetter = (s) => v.data.metaInfo[v.data.colorKey].color(s[v.data.colorKey]);\n    v.data.data = {\n        xLabel: v.data.xLabel, yLabel: v.data.yLabel,\n        data: v.data.scatterData,\n        valueRange: v.data.yRange,\n        categoryRange: v.data.xRange,\n        shapeGetter, colorGetter,\n    };\n    v.data.samples =  d.map(x => x.sampleId);\n    v.data.boxDataX.valueRange = v.data.data.categoryRange;\n    v.data.boxDataY.valueRange = v.data.data.valueRange;\n};\n\nconst processRawData = (d, v) => {\n    const xValues = [];\n    const yValues = [];\n    d.forEach(x => {\n        const xValue = parseFloat(x[v.data.xLabel]);\n        const yValue = parseFloat(x[v.data.yLabel]);\n        const temp = {sampleId: x.sampleId,\n            show: true,\n            pos: xValue,\n            value: yValue,\n            // values: [xValue, yValue]\n            ...v.data.groupDict[x.sampleId]};\n        temp[v.data.xLabel] = xValue;\n        temp[v.data.yLabel] = yValue;\n        v.data.scatterData.push(temp);\n        xValues.push(xValue);\n        yValues.push(yValue);\n    });\n    v.data.xRange = findBoundsForValues(xValues, 2, false, 0.1);\n    v.data.yRange = findBoundsForValues(yValues, 2, false, 0.1);\n\n    const categories = v.data.categories;\n    const xBoxValues = categories.map(_ => []);\n    const yBoxValues = categories.map(_ => []);\n    v.data.scatterData.forEach(x => {\n        const catIndex = categories.indexOf(x[v.data.catKey]);\n        xBoxValues[catIndex].push(x.pos);\n        yBoxValues[catIndex].push(x.value);\n    });\n    v.data.boxDataX = processBoxData(xBoxValues, categories);\n    v.data.boxDataY = processBoxData(yBoxValues, categories);\n};\n\nregister(MODULE_NAME, init);\n\nexport function registerScatterBoxPlot() {\n    register(MODULE_NAME, init);\n}\n"]},"metadata":{},"sourceType":"module"}