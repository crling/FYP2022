{"ast":null,"code":"function _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n        Component{\\n            Rows {\\n                @for (row, i) in prop.data {\\n                    @if (prop.drawRows) {\\n                        Component {\\n                            width = prop.gridW * 1.5\\n                            Text {\\n                                anchor = @anchor(\\\"r\\\",\\\"t\\\")\\n                                text = prop.rows[i] + \\\"  \\\"\\n                            }\\n                        }\\n                    }\\n                    Columns {\\n                        @for (d, j) in row {\\n                            Component {\\n                                width = prop.gridW\\n                                height = prop.gridH\\n                                Rect {\\n                                    // key = n\\n                                    height = 100%; width = 100%;\\n                                    stroke = \\\"black\\\"\\n                                    strokeWidth = 1\\n                                    fill = colorMap.get(d)\\n                                    behavior:tooltip { content = getTooltipContent(d, i, j) }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                Columns {\\n                    @for c in prop.columns {\\n                        Component {\\n                            width = prop.gridW\\n                            Text {\\n                                text = c\\n                                x = prop.gridW/2\\n                                y = 2\\n                                anchor = @anchor(\\\"r\\\",\\\"m\\\")\\n                                rotation = @rotate(-1 * prop.colLabelRotaton)\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (typeof call === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport { Component } from \"crux/dist/element\";\nexport var DiscreteHeatMap = /*#__PURE__*/function (_Component) {\n  _inherits(DiscreteHeatMap, _Component);\n\n  var _super = _createSuper(DiscreteHeatMap);\n\n  function DiscreteHeatMap() {\n    var _this;\n\n    _classCallCheck(this, DiscreteHeatMap);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.colorMap = new Map();\n    return _this;\n  }\n\n  _createClass(DiscreteHeatMap, [{\n    key: \"render\",\n    value: function render() {\n      return this.t(_templateObject());\n    }\n  }, {\n    key: \"willRender\",\n    value: function willRender() {\n      var _this2 = this;\n\n      this.prop.values.forEach(function (d, i) {\n        _this2.colorMap.set(d, _this2.prop.colors[i]);\n      });\n    }\n  }, {\n    key: \"getTooltipContent\",\n    value: function getTooltipContent(d, i, j) {\n      return \"\".concat(this.prop.rowName, \": \").concat(this.prop.rows[i], \"</br>\\n            \").concat(this.prop.colName, \": \").concat(this.prop.columns[j], \"</br>\\n            data: \").concat(this.prop.valueMap.get(d));\n    }\n  }]);\n\n  return DiscreteHeatMap;\n}(Component);","map":{"version":3,"sources":["/Users/wangzhenyu/Desktop/fyp_workspace/meta_platform/app/javascript/viz/discrete-heatmap/discrete-heatmap.ts"],"names":["Component","DiscreteHeatMap","colorMap","Map","t","prop","values","forEach","d","i","set","colors","j","rowName","rows","colName","columns","valueMap","get"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,SAAT,QAA2C,mBAA3C;AAiBA,WAAaC,eAAb;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA,UACYC,QADZ,GACqD,IAAIC,GAAJ,EADrD;AAAA;AAAA;;AAAA;AAAA;AAAA,6BAEa;AACL,aAAO,KAAKC,CAAZ;AA+CH;AAlDL;AAAA;AAAA,iCAoDiB;AAAA;;AACT,WAAKC,IAAL,CAAUC,MAAV,CAAiBC,OAAjB,CAAyB,UAACC,CAAD,EAAIC,CAAJ,EAAS;AAC9B,QAAA,MAAI,CAACP,QAAL,CAAcQ,GAAd,CAAkBF,CAAlB,EAAqB,MAAI,CAACH,IAAL,CAAUM,MAAV,CAAiBF,CAAjB,CAArB;AACH,OAFD;AAGH;AAxDL;AAAA;AAAA,sCAyDgCD,CAzDhC,EAyDmCC,CAzDnC,EAyDsCG,CAzDtC,EAyDyC;AACjC,uBAAU,KAAKP,IAAL,CAAUQ,OAApB,eAAgC,KAAKR,IAAL,CAAUS,IAAV,CAAeL,CAAf,CAAhC,gCACM,KAAKJ,IAAL,CAAUU,OADhB,eAC4B,KAAKV,IAAL,CAAUW,OAAV,CAAkBJ,CAAlB,CAD5B,sCAEY,KAAKP,IAAL,CAAUY,QAAV,CAAmBC,GAAnB,CAAuBV,CAAvB,CAFZ;AAGH;AA7DL;;AAAA;AAAA,EAAqCR,SAArC","sourcesContent":["import { Component, ComponentOption } from \"crux/dist/element\";\n\nexport interface DiscreteHeatMapOption extends ComponentOption {\n    rows: [];\n    columns: [];\n    data: [][];\n    rowName: string;\n    colName: string;\n    gridW: number;\n    gridH: number;\n    colors: string[];\n    values: any[];\n    valueMap: any;\n    drawRows: boolean;\n    colLabelRotaton: number; // the rotation angle for column labels\n}\n\nexport class DiscreteHeatMap extends Component<DiscreteHeatMapOption> {\n    private colorMap: Map<number | string, string> = new Map();\n    render() {\n        return this.t`\n        Component{\n            Rows {\n                @for (row, i) in prop.data {\n                    @if (prop.drawRows) {\n                        Component {\n                            width = prop.gridW * 1.5\n                            Text {\n                                anchor = @anchor(\"r\",\"t\")\n                                text = prop.rows[i] + \"  \"\n                            }\n                        }\n                    }\n                    Columns {\n                        @for (d, j) in row {\n                            Component {\n                                width = prop.gridW\n                                height = prop.gridH\n                                Rect {\n                                    // key = n\n                                    height = 100%; width = 100%;\n                                    stroke = \"black\"\n                                    strokeWidth = 1\n                                    fill = colorMap.get(d)\n                                    behavior:tooltip { content = getTooltipContent(d, i, j) }\n                                }\n                            }\n                        }\n                    }\n                }\n                Columns {\n                    @for c in prop.columns {\n                        Component {\n                            width = prop.gridW\n                            Text {\n                                text = c\n                                x = prop.gridW/2\n                                y = 2\n                                anchor = @anchor(\"r\",\"m\")\n                                rotation = @rotate(-1 * prop.colLabelRotaton)\n                            }\n                        }\n                    }\n                }\n            }\n        }`;\n\n    }\n\n    willRender() {\n        this.prop.values.forEach((d, i)=> {\n            this.colorMap.set(d, this.prop.colors[i]);\n        })\n    }\n    protected getTooltipContent(d, i, j) {\n        return `${this.prop.rowName}: ${this.prop.rows[i]}</br>\n            ${this.prop.colName}: ${this.prop.columns[j]}</br>\n            data: ${this.prop.valueMap.get(d)}`;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}