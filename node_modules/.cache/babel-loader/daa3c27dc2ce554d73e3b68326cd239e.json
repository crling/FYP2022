{"ast":null,"code":"function _templateObject2() {\n  var data = _taggedTemplateLiteral([\"<polygon points=\\\"\\n                \", \"\\n                \\\">\"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"<rect x=\\\"0\\\" y=\\\"0\\\"\\n                width=\\\"\", \"\\\"\\n                height=\\\"\", \"\\\"\\n                rx=\\\"\", \"\\\" ry=\\\"\", \"\\\">\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nimport { oneLineTrim } from \"common-tags\";\nimport { GeometryValue } from \"../../defs/geometry\";\nexport function svgPropFillAndStroke(elm) {\n  var result = {};\n  var v;\n  if (v = elm.prop.fill) result.fill = v;\n  if (v = elm.prop.fillOpacity) result[\"fill-opacity\"] = v;\n  if (v = elm.prop.stroke) result.stroke = v;\n  if (v = elm.prop.strokeOpacity) result[\"stroke-opacity\"] = v;\n  if (v = elm.prop.strokeWidth) result[\"stroke-width\"] = v;\n  if (v = elm.prop.dashArray) result[\"stroke-dasharray\"] = v;\n  if (v = elm.prop.events) result[\"pointer-events\"] = v;\n  return result;\n}\nexport function svgPropXAndY(elm) {\n  var result = {};\n  var v;\n  if (v = elm.$geometry.x) result.x = v;\n  if (v = elm.$geometry.y) result.y = v;\n  return result;\n}\nexport function svgRotation(elm) {\n  var result = {};\n  var v;\n\n  if (v = elm.prop.rotation) {\n    var v1 = v[1] === \"_\" ? elm.$geometry.x : v[1];\n    var v2 = v[2] === \"_\" ? elm.$geometry.y : v[2];\n    result.transform = \"rotate(\".concat(v[0], \",\").concat(v1, \",\").concat(v2, \")\");\n  }\n\n  return result;\n}\nexport function svgPropClip(elm) {\n  var result = {};\n  var v;\n\n  if (v = elm.prop.clip) {\n    var width = elm.$geometry.width;\n    var height = elm.$geometry.height;\n    var clipPath;\n\n    if (v.type === \"bound\") {\n      clipPath = oneLineTrim(_templateObject(), width, height, v.rx || 0, v.ry || 0);\n    } else if (v.type === \"polygon\") {\n      var points = v.points.map(function (p, i) {\n        return _typeof(p) === \"object\" ? GeometryValue.cal(p, i % 2 ? height : width) : p;\n      });\n      clipPath = oneLineTrim(_templateObject2(), points.map(function (p, i) {\n        return p.toString() + (i % 2 ? \" \" : \",\");\n      }).join(\"\"));\n    } else {\n      throw new Error(\"Clip: unknown type \\\"\".concat(v.type, \"\\\"\"));\n    }\n\n    var id = \"clip-\".concat(elm.uid);\n    elm.$v.rendererCtx.appendDef(id, \"clipPath\", {}, clipPath);\n    result[\"clip-path\"] = \"url(#\".concat(id, \")\");\n  }\n\n  return result;\n}\nexport function svgInnerHTML(elm) {\n  var result = {};\n  var v;\n  if (v = elm.prop.html) result.innerHTML = v;\n  return result;\n}\nexport function svgPropPassthrough(props) {\n  return function (elm) {\n    var result = {};\n\n    for (var _i = 0, _Object$keys = Object.keys(props); _i < _Object$keys.length; _i++) {\n      var k = _Object$keys[_i];\n      var v = props[k];\n      var value = elm.prop[v];\n\n      if (value !== null && value !== undefined) {\n        result[k] = value;\n      }\n    }\n\n    return result;\n  };\n}","map":null,"metadata":{},"sourceType":"module"}