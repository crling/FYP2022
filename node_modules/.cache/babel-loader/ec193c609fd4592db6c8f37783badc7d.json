{"ast":null,"code":"function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { Component } from \"../../element\";\nimport { isRenderable } from \"../../element/is\";\nimport IS_NODE from \"../../utils/is-node\";\nimport { toRad } from \"../../utils/math\";\nimport { gatherEventListeners } from \"../utils\";\n\nfunction render(element, context) {\n  var v = element.$v;\n\n  if (!v) {\n    throw new Error(\"The element must be placed in a visualizer\");\n  }\n\n  if (!context.ctx) {\n    init(v, context);\n  }\n\n  context.ctx.clearRect(0, 0, context.ctx.canvas.width, context.ctx.canvas.height);\n  var ratio = window.devicePixelRatio || 1;\n  context.ctx.save();\n  context.ctx.scale(ratio, ratio);\n\n  _render(context.ctx, v.root);\n\n  context.ctx.restore();\n}\n\nfunction _render(ctx, element) {\n  if (element.prop.visible === false) {\n    return;\n  }\n\n  if (isRenderable(element)) {\n    return _render(ctx, element.children[0]);\n  }\n\n  ctx.save();\n  element.renderToCanvas(ctx);\n  var useOffline = false;\n  var offlineCanvas = null;\n  var currentCtx = ctx;\n  var offset = [0, 0];\n\n  if (element instanceof Component && element.isStatic) {\n    if (element.prop.maxBoundOffset) {\n      offset = element.prop.maxBoundOffset;\n\n      if (!Array.isArray(offset)) {\n        throw new Error(\"maxBoundOffset must be an array of numbers\");\n      }\n    }\n\n    if (!element.$v.forceRedraw && element.canvasCache) {\n      ctx.drawImage(element.canvasCache, -offset[0], -offset[1]);\n      ctx.restore();\n      return;\n    }\n\n    useOffline = true;\n    var oc = document.createElement(\"canvas\");\n    oc.width = element.$v.size.width + offset[0];\n    oc.height = element.$v.size.height + offset[1];\n    offlineCanvas = element.canvasCache = oc;\n    currentCtx = offlineCanvas.getContext(\"2d\");\n    currentCtx.translate(offset[0], offset[1]);\n  }\n\n  var listeners = element._gatheredListeners = gatherEventListeners(element);\n\n  if (listeners) {\n    Object.keys(listeners).forEach(function (ev) {\n      element.$v._registeredEvents.add(MOUSE_EVENT_MAP[ev]);\n    });\n  }\n\n  if (element instanceof Component) {\n    element.children.filter(function (c) {\n      return c._isActive;\n    }).forEach(function (e) {\n      return _render(currentCtx, e);\n    });\n  }\n\n  if (useOffline) {\n    ctx.drawImage(offlineCanvas, -offset[0], -offset[1]);\n  }\n\n  ctx.restore();\n}\n\nfunction init(v, context) {\n  if (IS_NODE) {\n    throw Error(\"The \\\"svg\\\" renderer only works in browser environments.\");\n  }\n\n  var canvas = document.createElement(\"canvas\");\n  var ctx = canvas.getContext(\"2d\");\n\n  if (!ctx) {\n    throw new Error(\"Cannot get canvas context\");\n  } // const ratio = window.devicePixelRatio || 1;\n\n\n  context.ctx = ctx;\n  context.gradients = {};\n  setSize(v, context);\n  ctx.font = \"12px Arial\"; // ctx.scale(ratio, ratio);\n\n  for (var _i = 0, _Object$keys = Object.keys(MOUSE_EVENT_MAP); _i < _Object$keys.length; _i++) {\n    var event = _Object$keys[_i];\n    addMouseEventListener(v, context, canvas, event);\n  }\n\n  v.container.appendChild(canvas);\n}\n\nfunction setSize(v, context) {\n  if (!context.ctx) return;\n  var canvas = context.ctx.canvas;\n  var ratio = window.devicePixelRatio || 1;\n  var _v$size = v.size,\n      width = _v$size.width,\n      height = _v$size.height;\n  canvas.width = width * ratio;\n  canvas.height = height * ratio;\n  canvas.style.width = \"\".concat(width, \"px\");\n  canvas.style.height = \"\".concat(height, \"px\");\n}\n\nfunction defineGradient(id, def, v, context) {\n  var g = context.ctx.createLinearGradient(def.x1, def.y1, def.x2, def.y2);\n\n  var _iterator = _createForOfIteratorHelper(def.stops),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var stop = _step.value;\n      g.addColorStop(stop.offset * 0.01, stop.color);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  context.gradients[id] = g;\n}\n\nfunction getGradient(name, v, context) {\n  return context.gradients[name];\n}\n\nvar MOUSE_EVENT_MAP = {\n  mouseenter: \"_mousemove\",\n  mouseleave: \"_mousemove\",\n  mousemove: \"_mousemove\",\n  mouseup: \"mouseup\",\n  mousedown: \"mousedown\",\n  click: \"click\",\n  wheel: \"wheel\"\n};\n\nfunction addMouseEventListener(v, context, canvas, event) {\n  var mappedEvent = MOUSE_EVENT_MAP[event];\n  var isMouseMove = mappedEvent === \"_mousemove\";\n  var isMouseLeave = event === \"mouseleave\";\n  canvas.addEventListener(event, function (e) {\n    if (!v._registeredEvents.has(mappedEvent)) return;\n    var ratio = window.devicePixelRatio || 1;\n    var b = canvas.getBoundingClientRect();\n    var x = (e.clientX - b.left) * ratio;\n    var y = (e.clientY - b.top) * ratio;\n    context.ctx.save();\n    context.ctx.scale(ratio, ratio);\n    var element = isMouseLeave ? null : findElement(context.ctx, v.root, x, y);\n    context.ctx.restore();\n\n    if (isMouseMove) {\n      var _iterator2 = _createForOfIteratorHelper(v._focusedElements.values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var el = _step2.value;\n          el._isFocused = false;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n\n    if (element) {\n      bubbleEvent(mappedEvent, element);\n    } // handle unfocused elements\n\n\n    if (isMouseMove) {\n      var blurredElements = [];\n\n      var _iterator3 = _createForOfIteratorHelper(v._focusedElements.values()),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _el2 = _step3.value;\n\n          if (!_el2._isFocused) {\n            blurredElements.push(_el2);\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      for (var _i2 = 0, _blurredElements = blurredElements; _i2 < _blurredElements.length; _i2++) {\n        var _el = _blurredElements[_i2];\n\n        if (_el._gatheredListeners && \"mouseleave\" in _el._gatheredListeners) {\n          callListener(_el._gatheredListeners.mouseleave, e, _el, x, y);\n        }\n\n        v._focusedElements[\"delete\"](_el);\n      }\n    }\n\n    if (element) {\n      triggerEvents(mappedEvent, e, element, x, y);\n    } else {\n      if (v._currentCursor) {\n        v._currentCursor = null;\n        context.ctx.canvas.style.cursor = \"\";\n      }\n    }\n  });\n}\n\nfunction findElement(ctx, el, x, y) {\n  if (!shouldAcceptEvents(el)) return null;\n\n  if (el instanceof Component) {\n    if (isRenderable(el)) {\n      return findElement(ctx, el.children[0], x, y);\n    } else {\n      ctx.save();\n      if (!el.$_cachedTransform) return null;\n\n      var _el$$_cachedTransform = _slicedToArray(el.$_cachedTransform, 3),\n          tx = _el$$_cachedTransform[0],\n          ty = _el$$_cachedTransform[1],\n          rc = _el$$_cachedTransform[2];\n\n      if (tx !== 0 || ty !== 0) {\n        ctx.translate(tx, ty);\n      }\n\n      if (rc !== 0) {\n        ctx.rotate(toRad(rc));\n      }\n\n      var r;\n\n      for (var i = el.children.length - 1; i >= 0; i--) {\n        if (r = findElement(ctx, el.children[i], x, y)) {\n          ctx.restore();\n          return r;\n        }\n      }\n\n      ctx.restore();\n    }\n\n    return null;\n  } else {\n    if (el._isActive && el.path && ctx.isPointInPath(el.path, x, y)) {\n      return el;\n    }\n\n    return null;\n  }\n}\n\nfunction shouldAcceptEvents(el) {\n  var events = el.prop.events;\n  if (events === \"all\") return true;else if (events === \"none\") return false;\n  return el.prop[\"fill\"] !== \"none\";\n}\n\nfunction bubbleEvent(event, el) {\n  var p = el;\n  var isMouseMove = event === \"_mousemove\";\n\n  while (p) {\n    if (isMouseMove) {\n      p._isFocused = true;\n    }\n\n    p = p.parent;\n  }\n}\n\nfunction triggerEvents(event, origEvent, el, x, y) {\n  var p = el;\n  var isMouseMove = event === \"_mousemove\";\n  var cursor = null;\n  var cursorIsSet = false;\n\n  while (p) {\n    if (!cursorIsSet && (cursor = p.prop.cursor)) {\n      cursorIsSet = true;\n    }\n\n    if (p._gatheredListeners) {\n      if (isMouseMove) {\n        if (el.$v._focusedElements.has(p)) {\n          if (\"mousemove\" in p._gatheredListeners) {\n            callListener(p._gatheredListeners.mousemove, origEvent, p, x, y);\n          }\n        } else {\n          if (\"mouseenter\" in p._gatheredListeners) {\n            callListener(p._gatheredListeners.mouseenter, origEvent, p, x, y);\n          }\n        }\n      } else {\n        if (event in p._gatheredListeners) {\n          callListener(p._gatheredListeners[event], origEvent, p, x, y);\n          return;\n        }\n      }\n    }\n\n    if (isMouseMove) {\n      el.$v._focusedElements.add(p);\n    }\n\n    p = p.parent;\n  }\n\n  if (cursor !== el.$v._currentCursor) {\n    el.$v._currentCursor = cursor;\n    el.$v.rendererCtx.ctx.canvas.style.cursor = cursor ? cursor : \"\";\n  }\n}\n\nfunction callListener(listener, e, el, x, y) {\n  e._m_x = x;\n  e._m_y = y;\n\n  if (typeof listener === \"function\") {\n    listener.call(null, e, el);\n  } else if (listener[0] !== null) {\n    listener[0].apply(null, listener.slice(1));\n  } else {\n    for (var i = 1; i < listener.length; i++) {\n      callListener(listener[i], e, el, x, y);\n    }\n  }\n}\n\nvar renderer = {\n  init: init,\n  render: render,\n  setSize: setSize,\n  defineGradient: defineGradient,\n  getGradient: getGradient\n};\nexport default renderer;","map":null,"metadata":{},"sourceType":"module"}