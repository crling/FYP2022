{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport * as lodash from \"lodash\";\nimport { GeometryValue } from \"../../defs/geometry\";\nimport { useTemplate } from \"../../ext/decorator\";\nimport { Component } from \"../component\";\nimport { XYPlot } from \"../plot\";\nimport { scaled, scaleDomain } from \"../scale\";\n\nvar Axis =\n/** @class */\nfunction () {\n  var Axis = /*#__PURE__*/function (_Component) {\n    _inherits(Axis, _Component);\n\n    var _super = _createSuper(Axis);\n\n    function Axis() {\n      _classCallCheck(this, Axis);\n\n      return _super.apply(this, arguments);\n    }\n\n    _createClass(Axis, [{\n      key: \"defaultProp\",\n      value: function defaultProp() {\n        return {\n          orientation: \"bottom\",\n          tickCount: 5,\n          tickFormat: function tickFormat(d) {\n            return d.toString();\n          },\n          includeEndTicks: true,\n          roundEndTicks: false,\n          stroke: \"#000\"\n        };\n      }\n    }, {\n      key: \"willRender\",\n      value: function willRender() {\n        if (this.$parent instanceof XYPlot && this.$parent.flipped !== this.isHorizontal) {\n          var domain = this.$parent.categories;\n          this._tickValues = this.$parent.discreteCategory ? domain : undefined; // lodash.range(domain[0], domain[1] + 1);\n        }\n\n        if (this._firstRender) {\n          if (this.prop.orientation === \"top\" || this.prop.orientation === \"bottom\") {\n            this.isInXScaleSystem = true;\n          } else {\n            this.isInYScaleSystem = true;\n          }\n        }\n      }\n    }, {\n      key: \"getX\",\n      // @ts-ignore\n      value: function getX() {\n        return this.isHorizontal ? GeometryValue.fullSize : 0;\n      } // @ts-ignore\n\n    }, {\n      key: \"getY\",\n      value: function getY() {\n        return this.isHorizontal ? 0 : GeometryValue.fullSize;\n      } // @ts-ignore\n\n    }, {\n      key: \"isHorizontal\",\n      get: function get() {\n        return this.prop.orientation === \"top\" || this.prop.orientation === \"bottom\";\n      }\n    }, {\n      key: \"isInner\",\n      get: function get() {\n        return this.prop.orientation === \"top\" || this.prop.orientation === \"left\";\n      }\n    }, {\n      key: \"getLabelAnchor\",\n      get: function get() {\n        return (this.isHorizontal ? 32\n        /* Center */\n        : this.isInner ? 64\n        /* Right */\n        : 16\n        /* Left */\n        ) | (this.isHorizontal ? this.isInner ? 8\n        /* Bottom */\n        : 2\n        /* Top */\n        : 4\n        /* Middle */\n        );\n      } // @ts-ignore\n\n    }, {\n      key: \"ticks\",\n      get: function get() {\n        var ticks = getTicks(this.getScale(this.isHorizontal), this._tickValues || this.prop.ticks, this.prop.tickInterval, this.prop.tickCount, this.prop.includeEndTicks, this.prop.roundEndTicks, this.isHorizontal);\n\n        if (this.prop.includeEndTicks && !(this._tickValues || this.prop.ticks) && this.isHorizontal) {\n          var tf = this.prop.tickFormat;\n\n          if (isOverlap(ticks[0], ticks[1], tf)) {\n            ticks[1].show = false;\n          }\n\n          var last = ticks.length - 1;\n\n          if (isOverlap(ticks[last], ticks[last - 1], tf)) {\n            ticks[last - 1].show = false;\n          }\n        }\n\n        return ticks;\n      }\n    }], [{\n      key: \"propNameForInitializer\",\n      value: function propNameForInitializer() {\n        return \"orientation\";\n      }\n    }]);\n\n    return Axis;\n  }(Component);\n\n  Axis = __decorate([useTemplate(\"\\nComponent {\\n    width = isHorizontal ? prop.width : 0\\n    height = isHorizontal ? 0 : prop.height\\n    Line {\\n        x1 = 0; x2 = getX()\\n        y1 = 0; y2 = getY()\\n        shapeRendering = \\\"crispEdges\\\"\\n        stroke = prop.color\\n        @props prop.opt.line\\n    }\\n    @let offset = isInner ? -4 : 4\\n    @let labelAnchor = getLabelAnchor\\n    @for (tick, index) in ticks {\\n        Component {\\n            key = index\\n            x = isHorizontal ? tick.pos : 0\\n            y = isHorizontal ? 0 : tick.pos\\n            Line {\\n                x1 = 0\\n                x2 = isHorizontal ? 0 : offset\\n                y1 = 0\\n                y2 = isHorizontal ? offset : 0\\n                stroke = prop.color\\n                @props prop.opt.tick\\n            }\\n            @yield label with tick default {\\n                Text {\\n                    text = prop.tickFormat(tick.value)\\n                    x = isHorizontal ? 0 : offset\\n                    y = isHorizontal ? offset : 0\\n                    anchor = labelAnchor\\n                    fontSize = 10\\n                    visible = tick.show\\n                    fill = prop.color\\n                    @props prop.opt.label\\n                }\\n            }\\n        }\\n    }\\n}\\n\")], Axis);\n  return Axis;\n}();\n\nexport { Axis };\nexport function getTicks(scale, providedTicks, interval, count, includeEndTicks, roundEndTicks, isHorizontal) {\n  if (!scale) {\n    throw new Error(\"Axis: you must supply a scale.\");\n  }\n\n  var hasProvidedTicks = Array.isArray(providedTicks);\n  var ticks;\n\n  if (hasProvidedTicks) {\n    ticks = providedTicks;\n  } else {\n    ticks = [];\n    var domain = scaleDomain(scale);\n    var isNumeric = domain.length === 2 && typeof domain[0] === \"number\";\n\n    if (isNumeric) {\n      var i;\n      var isInversed = domain[1] < domain[0];\n\n      if (interval) {\n        i = isInversed ? -interval : interval;\n      } else {\n        if (!count) {\n          throw new Error(\"Axis: \\\"ticks\\\", \\\"tickInterval\\\" or \\\"tickCount\\\" must be provided.\");\n        }\n\n        var rawInterval = (domain[1] - domain[0]) / count;\n        var absInterval = Math.abs(rawInterval);\n        var digits = baseDigitOf(absInterval);\n        i = lodash.minBy([0.1, 0.2, 0.5, 1, 2, 5].map(function (x) {\n          return x * digits;\n        }), function (x) {\n          if (!isInversed && x > domain[1]) {\n            return Number.MAX_SAFE_INTEGER;\n          }\n\n          return Math.abs(x - absInterval);\n        });\n        if (isInversed) i = -i;\n      } // check whether domain[0] can be divided by interval\n\n\n      var start = Math.ceil(domain[0] / i) * i;\n      var counter = start;\n\n      while ((isInversed ? counter - domain[1] : domain[1] - counter) > 1e-15) {\n        if (Math.abs(counter) < 0.000001 && i > 0.0000001) counter = 0;\n        ticks.push(pretty(counter));\n        counter += i;\n      } // add start and end ticks\n\n\n      if (includeEndTicks && isNumeric) {\n        ticks.unshift(roundEndTicks ? Math.round(domain[0]) : domain[0]);\n        ticks.push(roundEndTicks ? Math.round(domain[1]) : domain[1]);\n      }\n    } else {\n      ticks = domain;\n    }\n  }\n\n  var tickValues = ticks.map(function (t) {\n    return {\n      value: t,\n      pos: scaled(scale, t),\n      show: true\n    };\n  });\n  return tickValues;\n}\n\nfunction isOverlap(a, b, tf) {\n  var aLabel = tf ? tf(a.value) : a.value;\n  var bLabel = tf ? tf(b.value) : b.value;\n  var FACTOR = 3;\n  return Math.abs(a.pos - b.pos) < FACTOR * (aLabel.length + bLabel.length);\n}\n\nfunction pretty(n) {\n  return parseFloat(n.toPrecision(12));\n}\n\nfunction baseDigitOf(n) {\n  if (n === 0) return 0;\n  var count = 1;\n\n  if (n > 1) {\n    while (n / 10 >= 1) {\n      n /= 10;\n      count *= 10;\n    }\n  } else {\n    while (n * 10 <= 1) {\n      n *= 10;\n      count /= 10;\n    }\n  }\n\n  return count;\n}","map":null,"metadata":{},"sourceType":"module"}