{"ast":null,"code":"function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport Crux from \"crux\";\nimport * as text_size from \"crux/dist/utils/text-size\";\nimport * as d3 from \"d3-hierarchy\";\nexport var dataOpt = {\n  min: 0.05,\n  Abundance: 0,\n  nodeAbundance: 100,\n  aName: \"\",\n  maxLength: 0,\n  maxHeight: 0,\n  treeHeight: 800,\n  treeDepth: 3,\n  classficationRank: null,\n  treeRadius: 0,\n  color: Crux.color.ColorSchemeGradient.create(\"#eef4fa\", \"#1565C0\"),\n  isRadical: null,\n  isChanged: false\n};\nexport function convert(key) {\n  switch (key) {\n    case \"R\":\n      {\n        key = 8;\n        break;\n      }\n\n    case \"D\":\n      {\n        key = 7;\n        break;\n      }\n\n    case \"K\":\n      {\n        key = 6;\n        break;\n      }\n\n    case \"P\":\n      {\n        key = 5;\n        break;\n      }\n\n    case \"C\":\n      {\n        key = 4;\n        break;\n      }\n\n    case \"O\":\n      {\n        key = 3;\n        break;\n      }\n\n    case \"F\":\n      {\n        key = 2;\n        break;\n      }\n\n    case \"G\":\n      {\n        key = 1;\n        break;\n      }\n\n    case 8:\n      {\n        key = \"Root\";\n        break;\n      }\n\n    case 7:\n      {\n        key = \"Domain\";\n        break;\n      }\n\n    case 6:\n      {\n        key = \"Kingdom\";\n        break;\n      }\n\n    case 5:\n      {\n        key = \"Phylum\";\n        break;\n      }\n\n    case 4:\n      {\n        key = \"Class\";\n        break;\n      }\n\n    case 3:\n      {\n        key = \"Order\";\n        break;\n      }\n\n    case 2:\n      {\n        key = \"Family\";\n        break;\n      }\n\n    case 1:\n      {\n        key = \"Genus\";\n        break;\n      }\n\n    case 0:\n      {\n        key = \"Species\";\n      }\n  }\n\n  return key;\n}\nexport function lightenColor(color) {\n  color = color.split(\"(\")[1].substring(0, color.length - 1);\n  var h = parseFloat(color.split(\",\")[0]);\n  var s = parseInt(color.split(\",\")[1].substring(0, color.length - 1)) - 20;\n  var l = parseInt(color.split(\",\")[2].substring(0, color.length - 1)) + 20;\n  return \"hsl(\".concat(h, \",\").concat(s, \"%,\").concat(l, \"%)\");\n}\nexport function loadKraken(_data, min) {\n  var data = [];\n\n  _data.some(function (d) {\n    if (d.R < \"A\" || d.R > \"Z\" || d.R === \"U\" || d.R.length !== 1) {\n      if (d.R === \"U\") {\n        dataOpt.nodeAbundance = parseFloat((100 - parseFloat(d.Abundance)).toFixed(2));\n      }\n\n      return;\n    } else if (d.R === \"S\") {\n      d.root = d.root.trim();\n      data.push(d);\n    } else {\n      var currentRank = convert(d.R);\n      d.root = d.root.trim();\n\n      if (data.length === 0 || currentRank < convert(data[data.length - 1].R)) {\n        data.push(d);\n      } else {\n        if (data[data.length - 1].R === \"S\") {\n          var validS = [];\n\n          while (data[data.length - 1].R === \"S\") {\n            var abu = parseFloat(data[data.length - 1].Abundance);\n\n            if (abu > min) {\n              validS.push(data.pop());\n            } else {\n              data.pop();\n            }\n          }\n\n          if (validS.length === 0) {\n            while (data.length > 1 && data[data.length - 1].R !== \"S\") {\n              data.pop();\n            }\n          } else {\n            while (validS.length !== 0) {\n              var s = validS.pop();\n              var abund = parseFloat(s.Abundance);\n\n              if (dataOpt.Abundance < abund) {\n                dataOpt.Abundance = abund;\n                dataOpt.aName = s.root;\n              }\n\n              var len = text_size.measuredTextSize(s.root);\n\n              if (dataOpt.maxLength < len.width) {\n                dataOpt.maxLength = len.width;\n                dataOpt.maxHeight = len.height;\n              }\n\n              data.push(s);\n            }\n          }\n        } else {\n          while (currentRank > convert(data[data.length - 1].R)) {\n            data.pop();\n          }\n\n          if (currentRank === convert(data[data.length - 1].R)) {\n            data.pop();\n          }\n        }\n\n        data.push(d);\n      }\n    }\n  });\n\n  if (data[data.length - 1].R !== \"S\") {\n    while (data.length !== 0 && data[data.length - 1].R !== \"S\") {\n      data.pop();\n    }\n  } else {\n    var validS = [];\n    var abu = parseFloat(data[data.length - 1].Abundance);\n\n    if (abu > min) {\n      if (dataOpt.Abundance < abu) {\n        dataOpt.Abundance = abu;\n        dataOpt.aName = data[data.length - 1].root;\n      }\n\n      var len = text_size.measuredTextSize(data[data.length - 1].root.trim());\n\n      if (dataOpt.maxLength < len.width) {\n        dataOpt.maxLength = len.width;\n        dataOpt.maxHeight = len.height;\n      }\n\n      validS.push(data.pop());\n    } else {\n      data.pop();\n    }\n\n    if (validS.length === 0) {\n      while (data.length > 1 && data[data.length - 1].R !== \"S\") {\n        data.pop();\n      }\n    } else {\n      while (validS.length !== 0) {\n        data.push(validS.pop());\n      }\n    }\n  }\n\n  return data;\n}\nexport function loadYuJ(data) {\n  var only_s = [];\n  var Name = data.columns[0];\n  var Abundance = data.columns[1];\n  data.some(function (d) {\n    if (typeof d[Name] === \"string\") {\n      d[Name] = d[Name].split(\"|\");\n    }\n\n    var arr_len = d[Name].length;\n\n    if (arr_len === 7 && d[Abundance] > dataOpt.min) {\n      d[Name].some(function (n) {\n        if (!only_s[n]) {\n          only_s[n] = 1;\n        }\n      });\n      var abund = parseFloat(d[Abundance]);\n\n      if (abund > dataOpt.Abundance) {\n        dataOpt.Abundance = abund;\n        dataOpt.aName = d[Name][6].substring(3);\n      }\n\n      var len = text_size.measuredTextSize(d[Name][6]);\n\n      if (dataOpt.maxLength < len.width) {\n        dataOpt.maxLength = len.width;\n        dataOpt.maxHeight = len.height;\n      }\n    }\n  });\n  var all_node = [];\n  data.some(function (d) {\n    var arr_len = d[Name].length;\n\n    if (only_s[d[Name][arr_len - 1]]) {\n      all_node[d[Name][arr_len - 1]] = d;\n    }\n  });\n  var kraken_data = [];\n  kraken_data.push({\n    Abundance: \"100\",\n    R: \"R\",\n    id: \"\",\n    root: \"Root\"\n  });\n  kraken_data.push({\n    Abundance: \"100\",\n    R: \"D\",\n    id: \"\",\n    root: \"Domain_undefined\"\n  });\n\n  for (var key in only_s) {\n    var kraken = {\n      Abundance: all_node[key][Abundance].toString(),\n      R: key[0].toUpperCase(),\n      id: \"?term=\" + key.substring(3),\n      root: key.substring(3)\n    };\n    kraken_data.push(kraken);\n  }\n\n  return kraken_data;\n}\nexport function getTreeData(data) {\n  var directory = new Map();\n  var treeData = \"((((((((\";\n  data.some(function (d, i) {\n    if (d.R !== \"S\") {\n      if (directory.size !== 8) {\n        directory.set(convert(d.R), d.root);\n      } else {\n        var height = convert(d.R);\n        treeData = treeData.substring(0, treeData.length - 1);\n        treeData += \")\";\n        var j = 1;\n\n        while (j <= height) {\n          treeData += directory.get(j) + \")\";\n          directory[\"delete\"](j++);\n        }\n\n        treeData = treeData.substring(0, treeData.length - 1);\n        treeData += \",\";\n        j = height;\n\n        while (j--) {\n          treeData += \"(\";\n        }\n\n        directory.set(height, d.root);\n      }\n\n      return;\n    }\n\n    if (directory.size !== 8) {\n      var _j = 1;\n\n      while (_j < 8) {\n        if (!directory.get(_j)) {\n          directory.set(_j, \"Undefine\".concat(i));\n        }\n\n        _j++;\n      }\n    }\n\n    directory = new Map(_toConsumableArray(directory.entries()).sort());\n    treeData += d.root + \",\";\n  });\n  treeData = treeData.substring(0, treeData.length - 1) + \")\";\n  directory.forEach(function (d) {\n    treeData += d + \")\";\n  });\n  directory.clear();\n  return treeData.substring(0, treeData.length - 1);\n}\nexport function getTreeSetUp(isRadical, leafCount) {\n  dataOpt.treeHeight = 0;\n  dataOpt.treeRadius = 0;\n  dataOpt.isChanged = false;\n\n  if (isRadical === null) {\n    dataOpt.isRadical = leafCount >= 30 ? true : false;\n  }\n\n  if (leafCount < 30) {\n    var a, b, c;\n\n    if (leafCount < 10) {\n      a = 200 + dataOpt.maxLength;\n      b = 50;\n      c = 20;\n    } else if (leafCount < 30) {\n      a = 400;\n      b = 30;\n      c = 15;\n    }\n\n    dataOpt.treeRadius = isRadical ? a : 0;\n    dataOpt.treeHeight = isRadical ? dataOpt.treeRadius * 2 + b : dataOpt.treeHeight = leafCount * (dataOpt.maxHeight + c);\n  } else {\n    var _a;\n\n    if (leafCount < 60) {\n      _a = dataOpt.maxHeight + 20;\n    } else if (leafCount < 80) {\n      _a = dataOpt.maxHeight + 10;\n    } else if (leafCount < 100) {\n      _a = dataOpt.maxHeight + 5;\n    } else {\n      _a = Math.log2(dataOpt.Abundance) * 2 + 10;\n      dataOpt.isChanged = true;\n      dataOpt.maxLength = Math.log2(dataOpt.Abundance) * 2 + 50;\n    }\n\n    dataOpt.treeRadius = leafCount * _a / (2 * Math.PI) + dataOpt.maxLength;\n    dataOpt.treeHeight = dataOpt.treeRadius * 2 + 120;\n  }\n}\nexport function getNodeLeafData(treeData) {\n  var newickData = Crux.utils.parseNewick(treeData);\n  var hierarchy = d3.hierarchy(newickData).sum(function (d) {\n    return d.length;\n  });\n  var allNodes = [];\n  var leaves = [];\n  var nodes = [];\n  hierarchy.each(function (n) {\n    if (n.children) {\n      nodes.push(n);\n    } else {\n      leaves.push(n);\n    }\n\n    allNodes.push(n);\n  });\n  var maxLinkNodes;\n  var linkNodes = [];\n  leaves.forEach(function (d) {\n    var current = d;\n    var tempNodes = {\n      leafName: \"\",\n      pathNodes: []\n    };\n    tempNodes.leafName = d.data.name;\n\n    while (current !== null) {\n      tempNodes.pathNodes.push(current);\n      current = current.parent;\n    }\n\n    linkNodes.push(tempNodes);\n\n    if (d.data.name === dataOpt.aName) {\n      maxLinkNodes = tempNodes;\n    }\n  });\n  var path = [];\n  linkNodes.forEach(function (d) {\n    var info = {\n      leafName: \"\",\n      linkNodes: \"\"\n    };\n    info.leafName = d.leafName;\n\n    for (var j = 8; j >= 0; j--) {\n      info.linkNodes += \"\".concat(convert(d.pathNodes[j].height), \": \").concat(d.pathNodes[j].data.name, \" <br>\");\n    }\n\n    path.push(info);\n  });\n  return {\n    newickData: newickData,\n    leaves: leaves,\n    nodes: nodes,\n    maxLinkNodes: maxLinkNodes,\n    path: path,\n    allNodes: allNodes\n  };\n}\nexport function getLinkColor(nodes) {\n  var depthNodes = nodes.filter(function (d) {\n    return d.depth === dataOpt.treeDepth;\n  });\n  var len = depthNodes.length;\n  var color = Crux.color.ColorSchemeCategory.create(len);\n  var depthNodesLegend = [];\n  var c = 0;\n  depthNodes.forEach(function (d, i) {\n    var info = {\n      x: 0,\n      y: 0,\n      name: d.data.name,\n      color: color.get(i)\n    };\n    c = Math.floor(len / 10) <= 3 ? Math.floor(len / 10) === 0 ? 1 : Math.floor(len / 10) : 3;\n    var a = i % c;\n    var b = Math.ceil((i + 1) / c) - 1;\n    info.x = a * 250;\n    info.y = b * 20;\n\n    if (dataOpt.isChanged) {\n      info.color = lightenColor(info.color);\n    }\n\n    depthNodesLegend.push(info);\n  });\n  var colorNodes = [];\n  var depthPathNodes = [];\n  nodes.forEach(function (d) {\n    var colorInfo = {\n      nodeName: d.data.name,\n      color: null\n    };\n    var depthInfo = {\n      nodeName: d.data.name,\n      depthName: null\n    };\n\n    if (d.depth < dataOpt.treeDepth) {\n      colorInfo.color = \"#aaa\";\n      colorNodes.push(colorInfo);\n    } else {\n      var tempNode = d;\n\n      while (tempNode.depth !== dataOpt.treeDepth) {\n        tempNode = tempNode.parent;\n      }\n\n      depthInfo.depthName = tempNode.data.name;\n      depthPathNodes.push(depthInfo);\n      depthNodes.forEach(function (d, j) {\n        if (d.data.name === tempNode.data.name) {\n          colorInfo.color = dataOpt.isChanged ? lightenColor(color.get(j)) : color.get(j);\n          return true;\n        }\n      });\n      colorNodes.push(colorInfo);\n    }\n  });\n  return {\n    colorNodes: colorNodes,\n    depthNodesLegend: depthNodesLegend,\n    depthPathNodes: depthPathNodes\n  };\n}\nexport function treeLoaded(_data) {\n  var data = [];\n\n  if (_data.columns.length === 2) {\n    data = loadYuJ(_data);\n  } else {\n    data = loadKraken(_data, dataOpt.min);\n  }\n\n  var data_dict = [];\n  data.some(function (d) {\n    data_dict[d.root] = d;\n  });\n  var treeData = getTreeData(data);\n  var nodeLeafData = getNodeLeafData(treeData);\n  var newickData = nodeLeafData.newickData;\n  var leaves = nodeLeafData.leaves;\n  var nodes = nodeLeafData.nodes;\n  var maxLinkNodes = nodeLeafData.maxLinkNodes;\n  var path = nodeLeafData.path;\n  var allNodes = nodeLeafData.allNodes;\n  getTreeSetUp(dataOpt.isRadical, leaves.length);\n  dataOpt.classficationRank = convert(8 - dataOpt.treeDepth);\n  var linkColor = getLinkColor(allNodes);\n  var colorNodes = linkColor.colorNodes;\n  var depthPathNodes = linkColor.depthPathNodes;\n  var depthNodesLegend = linkColor.depthNodesLegend;\n  return {\n    newickData: newickData,\n    allNodes: allNodes,\n    leaves: leaves,\n    nodes: nodes,\n    maxLinkNodes: maxLinkNodes,\n    path: path,\n    data_dict: data_dict,\n    dataOpt: dataOpt,\n    colorNodes: colorNodes,\n    depthPathNodes: depthPathNodes,\n    depthNodesLegend: depthNodesLegend,\n    _data: _data\n  };\n}","map":{"version":3,"sources":["/Users/wangzhenyu/Desktop/fyp_workspace/meta_platform/app/javascript/viz/static_abd/data.ts"],"names":["Crux","text_size","d3","dataOpt","min","Abundance","nodeAbundance","aName","maxLength","maxHeight","treeHeight","treeDepth","classficationRank","treeRadius","color","ColorSchemeGradient","create","isRadical","isChanged","convert","key","lightenColor","split","substring","length","h","parseFloat","s","parseInt","l","loadKraken","_data","data","some","d","R","toFixed","root","trim","push","currentRank","validS","abu","pop","abund","len","measuredTextSize","width","height","loadYuJ","only_s","Name","columns","arr_len","n","all_node","kraken_data","id","kraken","toString","toUpperCase","getTreeData","directory","Map","treeData","i","size","set","j","get","entries","sort","forEach","clear","getTreeSetUp","leafCount","a","b","c","Math","log2","PI","getNodeLeafData","newickData","utils","parseNewick","hierarchy","sum","allNodes","leaves","nodes","each","children","maxLinkNodes","linkNodes","current","tempNodes","leafName","pathNodes","name","parent","path","info","getLinkColor","depthNodes","filter","depth","ColorSchemeCategory","depthNodesLegend","x","y","floor","ceil","colorNodes","depthPathNodes","colorInfo","nodeName","depthInfo","depthName","tempNode","treeLoaded","data_dict","nodeLeafData","linkColor"],"mappings":"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","sourcesContent":["import Crux from \"crux\";\nimport * as text_size from \"crux/dist/utils/text-size\";\nimport * as d3 from \"d3-hierarchy\";\n\nexport let dataOpt = {\n    min: 0.05,\n    Abundance: 0,\n    nodeAbundance: 100,\n    aName: \"\",\n    maxLength: 0,\n    maxHeight: 0,\n    treeHeight: 800,\n    treeDepth: 3,\n    classficationRank: null,\n    treeRadius: 0,\n    color: Crux.color.ColorSchemeGradient.create(\"#eef4fa\", \"#1565C0\"),\n    isRadical: null,\n    isChanged: false,\n};\n\nexport function convert(key) {\n    switch (key) {\n        case \"R\": {\n            key = 8;\n            break;\n        }\n        case \"D\": {\n            key = 7;\n            break;\n        }\n        case \"K\": {\n            key = 6;\n            break;\n        }\n        case \"P\": {\n            key = 5;\n            break;\n        }\n        case \"C\": {\n            key = 4;\n            break;\n        }\n        case \"O\": {\n            key = 3;\n            break;\n        }\n        case \"F\": {\n            key = 2;\n            break;\n        }\n        case \"G\": {\n            key = 1;\n            break;\n        }\n        case 8: {\n            key = \"Root\";\n            break;\n        }\n        case 7: {\n            key = \"Domain\";\n            break;\n        }\n        case 6: {\n            key = \"Kingdom\";\n            break;\n        }\n        case 5: {\n            key = \"Phylum\";\n            break;\n        }\n        case 4: {\n            key = \"Class\";\n            break;\n        }\n        case 3: {\n            key = \"Order\";\n            break;\n        }\n        case 2: {\n            key = \"Family\";\n            break;\n        }\n        case 1: {\n            key = \"Genus\";\n            break;\n        }\n        case 0: {\n            key = \"Species\";\n        }\n    }\n    return key;\n}\n\nexport function lightenColor(color) {\n    color = color.split(\"(\")[1].substring(0, color.length - 1);\n    const h = parseFloat(color.split(\",\")[0]);\n    const s = parseInt(color.split(\",\")[1].substring(0, color.length - 1)) - 20;\n    const l = parseInt(color.split(\",\")[2].substring(0, color.length - 1)) + 20;\n    return `hsl(${h},${s}%,${l}%)`;\n}\n\nexport function loadKraken(_data, min) {\n    const data = [];\n\n    _data.some(d => {\n        if (d.R < \"A\" || d.R > \"Z\" || d.R === \"U\" || d.R.length !== 1) {\n            if (d.R === \"U\") {\n                dataOpt.nodeAbundance = parseFloat((100 - parseFloat(d.Abundance)).toFixed(2));\n            }\n            return;\n        } else if  (d.R === \"S\") {\n            d.root = d.root.trim();\n            data.push(d);\n        } else {\n\n            const currentRank = convert(d.R);\n            d.root = d.root.trim();\n\n            if (data.length === 0 || currentRank < convert(data[data.length - 1].R)) {\n                data.push(d);\n            } else {\n                if (data[data.length - 1].R === \"S\") {\n                    const validS = [];\n                    while (data[data.length - 1].R === \"S\") {\n                        const abu = parseFloat(data[data.length - 1].Abundance);\n                        if (abu > min) {\n                            validS.push(data.pop());\n                        } else {\n                            data.pop();\n                        }\n                    }\n\n                    if (validS.length === 0) {\n                        while (data.length > 1 && data[data.length - 1].R !== \"S\") {\n                            data.pop();\n                        }\n                    } else {\n                        while (validS.length !== 0) {\n                            const s = validS.pop();\n\n                            const abund = parseFloat(s.Abundance);\n                            if (dataOpt.Abundance < abund) {\n                                dataOpt.Abundance = abund;\n                                dataOpt.aName = s.root;\n                            }\n                            const len = text_size.measuredTextSize(s.root);\n                            if  (dataOpt.maxLength < len.width) {\n                                dataOpt.maxLength = len.width;\n                                dataOpt.maxHeight = len.height;\n                            }\n\n                            data.push(s);\n                        }\n                    }\n\n                } else {\n                    while (currentRank > convert(data[data.length - 1].R)) {\n                        data.pop();\n                    }\n                    if (currentRank === convert(data[data.length - 1].R)) {\n                        data.pop();\n                    }\n                }\n                data.push(d);\n            }\n        }\n    });\n\n    if (data[data.length - 1].R !== \"S\") {\n        while (data.length !== 0 && data[data.length - 1].R !== \"S\") {\n            data.pop();\n        }\n    } else {\n        const validS = [];\n        const abu = parseFloat(data[data.length - 1].Abundance);\n        if (abu > min) {\n            if (dataOpt.Abundance < abu) {\n                dataOpt.Abundance = abu;\n                dataOpt.aName = data[data.length - 1].root;\n            }\n            const len = text_size.measuredTextSize(data[data.length - 1].root.trim());\n            if  (dataOpt.maxLength < len.width) {\n                dataOpt.maxLength = len.width;\n                dataOpt.maxHeight = len.height;\n            }\n            validS.push(data.pop());\n        } else {\n            data.pop();\n        }\n\n        if (validS.length === 0) {\n            while (data.length > 1 && data[data.length - 1].R !== \"S\") {\n                data.pop();\n            }\n        } else {\n            while (validS.length !== 0) {\n                data.push(validS.pop());\n            }\n        }\n    }\n\n    return data;\n}\n\nexport function loadYuJ(data) {\n\n    const only_s = [];\n\n    const Name = data.columns[0];\n    const Abundance = data.columns[1];\n\n    data.some( d => {\n\n        if (typeof(d[Name]) === \"string\") {\n            d[Name] = d[Name].split(\"|\");\n        }\n\n        const arr_len = d[Name].length;\n\n        if (arr_len === 7 && d[Abundance] > dataOpt.min) {\n\n            d[Name].some(n => {\n                if (!only_s[n]) {\n                    only_s[n] = 1;\n                }\n            });\n\n            const abund = parseFloat(d[Abundance]);\n            if ( abund > dataOpt.Abundance) {\n                dataOpt.Abundance = abund;\n                dataOpt.aName = d[Name][6].substring(3);\n            }\n            const len = text_size.measuredTextSize(d[Name][6]);\n            if  (dataOpt.maxLength < len.width) {\n                dataOpt.maxLength = len.width;\n                dataOpt.maxHeight = len.height;\n            }\n\n        }\n    });\n\n    const all_node = [];\n\n    data.some( d => {\n\n        const arr_len = d[Name].length;\n\n        if (only_s[d[Name][arr_len - 1]]) {\n            all_node[d[Name][arr_len - 1]] = d;\n        }\n\n    });\n\n    const kraken_data = [];\n\n    kraken_data.push({\n        Abundance: \"100\",\n        R: \"R\",\n        id: \"\",\n        root: \"Root\",\n    });\n\n    kraken_data.push({\n        Abundance: \"100\",\n        R: \"D\",\n        id: \"\",\n        root: \"Domain_undefined\",\n    });\n\n    for (let key in only_s) {\n\n        const kraken = {\n            Abundance: all_node[key][Abundance].toString(),\n            R: key[0].toUpperCase(),\n            id: \"?term=\" + key.substring(3),\n            root: key.substring(3),\n        };\n\n        kraken_data.push(kraken)\n    }\n\n    return kraken_data;\n}\n\nexport function getTreeData(data) {\n\n    let directory = new Map();\n    let treeData = \"((((((((\";\n\n    data.some((d, i) => {\n        if (d.R !== \"S\") {\n            if (directory.size !== 8 ) {\n                directory.set(convert(d.R), d.root);\n            } else {\n                const height = convert(d.R);\n                treeData = treeData.substring(0, treeData.length - 1);\n                treeData += \")\";\n                let j = 1;\n                while (j <= height) {\n                    treeData += directory.get(j)  + \")\";\n                    directory.delete(j++);\n                }\n                treeData = treeData.substring(0, treeData.length - 1);\n                treeData += \",\";\n                j = height;\n                while (j--) {\n                    treeData += \"(\";\n                }\n                directory.set(height, d.root);\n            }\n            return;\n        }\n\n        if (directory.size !== 8) {\n            let j = 1;\n            while (j < 8) {\n                if  (!directory.get(j)) {\n                    directory.set(j, `Undefine${i}`);\n                }\n                j++;\n            }\n        }\n        directory = new Map([...directory.entries()].sort());\n\n        treeData += d.root + \",\";\n\n    });\n\n    treeData = treeData.substring(0, treeData.length - 1) + \")\";\n    directory.forEach(d => { treeData += d  +  \")\"; });\n\n    directory.clear();\n\n    return treeData.substring(0, treeData.length - 1);\n}\n\nexport function getTreeSetUp(isRadical, leafCount) {\n    dataOpt.treeHeight = 0;\n    dataOpt.treeRadius = 0;\n\n    dataOpt.isChanged = false;\n\n    if (isRadical === null) {\n        dataOpt.isRadical = (leafCount >= 30) ? true : false;\n    }\n    if (leafCount < 30) {\n        let a, b, c;\n        if (leafCount < 10) {\n            a = 200 + dataOpt.maxLength;\n            b = 50;\n            c = 20;\n        } else if  (leafCount < 30) {\n            a = 400;\n            b = 30;\n            c = 15;\n        }\n        dataOpt.treeRadius = (isRadical) ? a : 0;\n        dataOpt.treeHeight = (isRadical) ? dataOpt.treeRadius * 2 + b : dataOpt.treeHeight = leafCount * (dataOpt.maxHeight + c);\n    } else  {\n        let a;\n        if  (leafCount < 60) {\n            a = dataOpt.maxHeight + 20;\n        } else  if  (leafCount < 80) {\n            a = dataOpt.maxHeight + 10;\n        } else  if  (leafCount < 100) {\n            a = dataOpt.maxHeight + 5;\n        } else {\n            a = Math.log2(dataOpt.Abundance) * 2 + 10;\n            dataOpt.isChanged = true;\n            dataOpt.maxLength = Math.log2(dataOpt.Abundance) * 2 + 50;\n        }\n        dataOpt.treeRadius = (leafCount * a ) / (2 * Math.PI) + dataOpt.maxLength;\n        dataOpt.treeHeight = dataOpt.treeRadius * 2 + 120;\n    }\n\n}\n\nexport function getNodeLeafData(treeData) {\n    const newickData = Crux.utils.parseNewick(treeData);\n    const hierarchy = d3.hierarchy(newickData).sum(d => d.length);\n\n    const allNodes = [];\n    const leaves = [];\n    const nodes = [];\n\n    hierarchy.each(n => {\n        if  (n.children) {\n            nodes.push(n);\n        }  else  {\n            leaves.push(n);\n        }\n        allNodes.push(n);\n    });\n    let maxLinkNodes;\n    const linkNodes = [];\n    leaves.forEach (d => {\n        let current = d;\n        const tempNodes = {\n            leafName: \"\",\n            pathNodes: [],\n        };\n        tempNodes.leafName = d.data.name;\n        while (current !== null) {\n            tempNodes.pathNodes.push(current);\n            current = current.parent;\n        }\n        linkNodes.push(tempNodes);\n        if (d.data.name === dataOpt.aName) {\n            maxLinkNodes = tempNodes;\n        }\n    });\n\n    const path = [];\n    linkNodes.forEach (d => {\n        const info = {\n            leafName: \"\",\n            linkNodes: \"\",\n        };\n        info.leafName = d.leafName;\n        for (let j = 8; j >= 0; j--) {\n            info.linkNodes += `${convert(d.pathNodes[j].height)}: ${d.pathNodes[j].data.name} <br>`;\n        }\n        path.push(info);\n    });\n\n    return {newickData, leaves, nodes, maxLinkNodes, path, allNodes};\n}\n\nexport function getLinkColor(nodes) {\n\n    const depthNodes = nodes.filter(d => d.depth === dataOpt.treeDepth);\n    const len = depthNodes.length;\n\n    const color = Crux.color.ColorSchemeCategory.create(len);\n\n    const depthNodesLegend = [];\n    let c = 0;\n    depthNodes.forEach ((d , i) => {\n        const info = {\n            x: 0,\n            y: 0,\n            name: d.data.name,\n            color: color.get(i),\n        };\n\n        c = (Math.floor(len / 10) <= 3) ? (Math.floor(len / 10) === 0) ? 1 : Math.floor(len / 10) : 3;\n\n        const a = i % c;\n        const b = Math.ceil(((i + 1) / c)) - 1;\n        info.x = a * 250;\n        info.y = b * 20;\n\n        if (dataOpt.isChanged) {\n            info.color = lightenColor(info.color);\n        }\n        depthNodesLegend.push(info);\n    });\n\n    const colorNodes = [];\n    const depthPathNodes = [];\n    nodes.forEach(d => {\n        const colorInfo = {\n            nodeName: d.data.name,\n            color: null,\n        };\n        const depthInfo = {\n            nodeName: d.data.name,\n            depthName: null,\n        };\n        if (d.depth < dataOpt.treeDepth) {\n            colorInfo.color = \"#aaa\";\n            colorNodes.push(colorInfo);\n        } else  {\n            let tempNode = d;\n            while (tempNode.depth !== dataOpt.treeDepth) {\n                tempNode = tempNode.parent;\n            }\n            depthInfo.depthName = tempNode.data.name;\n            depthPathNodes.push(depthInfo);\n            depthNodes.forEach((d, j) => {\n                if (d.data.name === tempNode.data.name) {\n                    colorInfo.color = (dataOpt.isChanged) ? lightenColor(color.get(j)) : color.get(j);\n                    return true;\n                }\n            });\n            colorNodes.push(colorInfo);\n        }\n    });\n    return {colorNodes, depthNodesLegend, depthPathNodes};\n}\n\nexport function treeLoaded(_data) {\n\n    let data = [];\n\n    if (_data.columns.length === 2) {\n        data = loadYuJ(_data);\n    } else {\n        data = loadKraken(_data, dataOpt.min);\n    }\n\n    const data_dict = [];\n\n    data.some( d => {\n        data_dict[d.root] = d;\n    });\n\n    const treeData = getTreeData(data);\n\n    const nodeLeafData = getNodeLeafData(treeData);\n\n    const newickData = nodeLeafData.newickData;\n    const leaves = nodeLeafData.leaves;\n    const nodes = nodeLeafData.nodes;\n    const maxLinkNodes = nodeLeafData.maxLinkNodes;\n    const path = nodeLeafData.path;\n    const allNodes = nodeLeafData.allNodes;\n\n    getTreeSetUp(dataOpt.isRadical, leaves.length);\n    dataOpt.classficationRank = convert(8 - dataOpt.treeDepth);\n\n    const linkColor = getLinkColor(allNodes);\n\n    const colorNodes = linkColor.colorNodes;\n    const depthPathNodes = linkColor.depthPathNodes;\n    const depthNodesLegend = linkColor.depthNodesLegend;\n\n    return {newickData, allNodes, leaves, nodes, maxLinkNodes, path, data_dict, dataOpt, colorNodes, depthPathNodes, depthNodesLegend, _data};\n}\n"]},"metadata":{},"sourceType":"module"}